<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nearby Places - 118 Hang Bac, Hanoi Old Quarter</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f5f5f5;
        }

        .header {
            background: linear-gradient(135deg, #1976D2 0%, #42a5f5 100%);
            color: white;
            padding: 20px;
            text-align: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .header h1 {
            margin-bottom: 5px;
            font-size: 1.8rem;
        }

        .header p {
            opacity: 0.9;
            font-size: 1rem;
        }

        /* Hotel Location Input Section */
        .hotel-location-section {
            background: white;
            padding: 20px;
            border-bottom: 1px solid #e0e0e0;
        }

        .location-input-header {
            text-align: center;
            margin-bottom: 20px;
        }

        .location-input-header h3 {
            margin: 0 0 5px 0;
            color: #1976D2;
            font-size: 1.3rem;
        }

        .location-input-header p {
            margin: 0;
            color: #666;
            font-size: 0.95rem;
        }

        .location-input-container {
            display: flex;
            gap: 15px;
            align-items: end;
            margin-bottom: 15px;
        }

        .btn-update-location {
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            white-space: nowrap;
            box-shadow: 0 2px 8px rgba(76, 175, 80, 0.3);
        }

        .btn-update-location:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(76, 175, 80, 0.4);
        }

        .btn-update-location:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .current-location-display {
            text-align: center;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #4CAF50;
        }

        .current-location-display span {
            color: #2e7d32;
            font-weight: 600;
            font-size: 0.95rem;
        }

        @media (max-width: 768px) {
            .location-input-container {
                flex-direction: column;
                align-items: stretch;
            }

            .btn-update-location {
                margin-top: 10px;
            }
        }

        .controls {
            background: white;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: center;
            justify-content: center;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }

        .control-group label {
            font-weight: 600;
            color: #333;
            font-size: 0.9rem;
        }

        .radius-select {
            padding: 8px 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 1rem;
            background: white;
            cursor: pointer;
            transition: border-color 0.2s;
        }

        .radius-select:focus {
            outline: none;
            border-color: #1976D2;
        }

        .category-filters {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .category-filter {
            padding: 10px 18px;
            border: 3px solid #e0e0e0;
            border-radius: 25px;
            background: white;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1rem;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 8px;
            user-select: none;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .category-filter.active {
            background: #1976D2;
            color: white;
            border-color: #1976D2;
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(25, 118, 210, 0.4);
        }

        .category-filter:hover {
            transform: translateY(-2px) scale(1.02);
            box-shadow: 0 6px 16px rgba(0,0,0,0.2);
            border-color: #1976D2;
        }

        .category-filter:active {
            transform: scale(0.98);
        }

        .load-btn {
            background: linear-gradient(135deg, #4caf50 0%, #66bb6a 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 4px 12px rgba(76, 175, 80, 0.3);
        }

        .load-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(76, 175, 80, 0.4);
        }

        .load-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .map-container {
            height: calc(100vh - 200px);
            margin: 0;
            position: relative;
        }

        #map {
            width: 100%;
            height: 100%;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            z-index: 1000;
            display: none;
        }

        .loading.show {
            display: block;
        }

        .info-panel {
            background: white;
            padding: 15px;
            margin: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .stats {
            display: flex;
            justify-content: space-around;
            text-align: center;
        }

        .stat {
            flex: 1;
        }

        .stat-number {
            font-size: 2rem;
            font-weight: bold;
            color: #1976D2;
        }

        .stat-label {
            color: #666;
            font-size: 0.9rem;
        }

        @media (max-width: 768px) {
            .controls {
                padding: 15px;
            }
            
            .category-filters {
                justify-content: center;
            }
            
            .header h1 {
                font-size: 1.5rem;
            }
            
            .map-container {
                height: calc(100vh - 250px);
            }
        }

        /* Custom marker info window styling */
        .marker-info {
            max-width: 280px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        .marker-info img {
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .marker-info h3 {
            margin: 8px 0 4px 0;
            color: #333;
            font-size: 1.1rem;
            font-weight: 600;
        }

        .marker-info p {
            margin: 4px 0;
            color: #666;
            font-size: 0.9rem;
            line-height: 1.4;
        }

        .marker-info .rating {
            color: #ff9800;
            font-weight: bold;
        }

        .marker-info .distance {
            color: #1976D2;
            font-weight: bold;
        }

        .marker-info button {
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .marker-info button:hover {
            background: #1565C0 !important;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        /* Split-Screen Interface Styling */
        .split-container {
            background: white;
            margin: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .split-header {
            background: linear-gradient(135deg, #1976D2 0%, #42a5f5 100%);
            color: white;
            padding: 20px;
            text-align: center;
        }

        .split-header h3 {
            margin: 0 0 5px 0;
            font-size: 1.3rem;
        }

        .split-header p {
            margin: 0;
            opacity: 0.9;
            font-size: 0.9rem;
        }

        .split-content {
            display: flex;
            height: 600px;
        }

        .split-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .list-panel {
            border-right: 2px solid #e9ecef;
            max-width: 50%;
        }

        .map-panel {
            max-width: 50%;
        }

        .panel-header {
            background: #f8f9fa;
            padding: 15px 20px;
            border-bottom: 1px solid #e9ecef;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .panel-header h4 {
            margin: 0;
            font-size: 1.1rem;
            color: #333;
        }

        .place-count, .map-info {
            font-size: 0.9rem;
            color: #666;
            font-weight: 500;
        }

        .map-container-split {
            flex: 1;
            position: relative;
        }

        .map-container-split #map {
            width: 100%;
            height: 100%;
        }

        /* Places List Styling */
        .places-list {
            flex: 1;
            padding: 15px;
            overflow-y: auto;
        }

        .no-places-message {
            text-align: center;
            color: #666;
            font-size: 1.1rem;
            padding: 40px 20px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 2px dashed #ddd;
        }

        .place-item {
            display: flex;
            gap: 12px;
            padding: 12px;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            margin-bottom: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            background: white;
            min-height: 44px;
            -webkit-tap-highlight-color: rgba(25, 118, 210, 0.3);
            tap-highlight-color: rgba(25, 118, 210, 0.3);
            touch-action: manipulation;
        }

        .place-item:hover, .place-item:active {
            border-color: #1976D2;
            box-shadow: 0 4px 12px rgba(25, 118, 210, 0.15);
            transform: translateY(-2px);
        }

        /* Mobile touch feedback */
        @media (hover: none) {
            .place-item:active {
                background: #f5f5f5;
                border-color: #1976D2;
                transform: scale(0.98);
            }
        }

        .place-item.highlighted {
            border-color: #FFD700;
            background: #FFFACD;
            box-shadow: 0 6px 20px rgba(255, 215, 0, 0.3);
            transform: translateY(-2px);
        }

        .place-image {
            width: 70px;
            height: 70px;
            border-radius: 6px;
            object-fit: cover;
            background: #f0f0f0;
            flex-shrink: 0;
            display: block !important;
            min-height: 70px;
            max-width: 70px;
            max-height: 70px;
        }

        .place-image-placeholder {
            width: 70px;
            height: 70px;
            border-radius: 6px;
            background: linear-gradient(135deg, #e0e0e0 0%, #f0f0f0 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.8rem;
            color: #999;
            flex-shrink: 0;
        }

        .place-details {
            flex: 1;
            min-width: 0;
        }

        .place-name {
            font-size: 1rem;
            font-weight: 600;
            color: #333;
            margin-bottom: 4px;
            line-height: 1.3;
        }

        .place-address {
            font-size: 0.85rem;
            color: #666;
            margin-bottom: 6px;
            line-height: 1.3;
        }

        .place-hours {
            font-size: 0.8rem;
            color: #4CAF50;
            margin-bottom: 6px;
            line-height: 1.3;
            font-weight: 500;
            background: rgba(76, 175, 80, 0.1);
            padding: 2px 6px;
            border-radius: 4px;
            display: inline-block;
        }
        
        .place-hours-placeholder {
            font-size: 0.8rem;
            color: #9e9e9e;
            margin-bottom: 6px;
            line-height: 1.3;
            font-weight: 500;
            background: rgba(158, 158, 158, 0.1);
            padding: 2px 6px;
            border-radius: 4px;
            display: inline-block;
            font-style: italic;
        }

        .place-meta {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
        }

        .place-rating {
            color: #ff9800;
            font-weight: bold;
            font-size: 0.8rem;
        }

        .place-distance {
            color: #1976D2;
            font-weight: bold;
            font-size: 0.8rem;
        }

        .place-category {
            background: #e3f2fd;
            color: #1976D2;
            padding: 2px 6px;
            border-radius: 8px;
            font-size: 0.7rem;
            font-weight: 500;
        }

        /* Map View Styling */
        #mapTab {
            position: relative;
        }

        #mapTab #map {
            height: 500px;
            border-radius: 0;
        }

        /* Loading states */
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            z-index: 1000;
            display: none;
            text-align: center;
        }

        .loading.show {
            display: block;
        }

        /* Admin Panel Styling */
        .admin-toggle {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 1000;
        }

        .btn-admin {
            background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
            color: #333;
            border: none;
            padding: 12px 20px;
            border-radius: 25px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(255, 215, 0, 0.4);
            transition: all 0.3s ease;
        }

        .btn-admin:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 215, 0, 0.6);
        }

        .admin-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            width: 90%;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            z-index: 2000;
            padding: 0;
        }

        .admin-header {
            background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
            color: #333;
            padding: 20px;
            border-radius: 15px 15px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .admin-header h3 {
            margin: 0;
            font-size: 1.3rem;
        }

        .close-admin-btn {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #333;
            padding: 5px;
            border-radius: 50%;
            width: 35px;
            height: 35px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .close-admin-btn:hover {
            background: rgba(0,0,0,0.1);
        }

        #addRecommendationForm {
            padding: 20px;
        }

        .form-row {
            display: flex;
            gap: 15px;
        }

        .form-group {
            flex: 1;
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #333;
        }

        .form-group input,
        .form-group textarea {
            width: 100%;
            padding: 10px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 1rem;
            transition: border-color 0.2s;
        }

        .form-group input:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: #FFD700;
        }

        /* Image Upload Styles */
        .image-upload-area {
            width: 100%;
        }

        .image-drop-zone {
            border: 2px dashed #e0e0e0;
            border-radius: 8px;
            padding: 30px;
            text-align: center;
            background: #fafafa;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 15px;
            position: relative;
            min-height: 140px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .image-drop-zone:hover,
        .image-drop-zone.drag-over {
            border-color: #1976D2;
            background: #f3f7ff;
        }

        .image-drop-zone::before {
            content: "📋 PASTE ZONE - Press Ctrl+V";
            position: absolute;
            top: 8px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 11px;
            color: #007bff;
            font-weight: bold;
            opacity: 0.8;
            background: rgba(255, 255, 255, 0.9);
            padding: 2px 8px;
            border-radius: 3px;
            border: 1px solid #007bff;
        }

        .image-drop-zone.paste-active {
            border-color: #28a745;
            background: #f8fff8;
            box-shadow: 0 0 20px rgba(40, 167, 69, 0.3);
        }

        .image-drop-zone.paste-active::before {
            content: "✅ PASTING...";
            color: #28a745;
            border-color: #28a745;
        }

        .image-drop-zone.focused {
            border-color: #007bff;
            background: #f8f9fa;
            box-shadow: 0 0 15px rgba(0, 123, 255, 0.2);
        }

        .image-drop-zone.focused::before {
            content: "📋 READY TO PASTE - Press Ctrl+V";
            color: #007bff;
            border-color: #007bff;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 1; }
        }

        .drop-zone-content {
            pointer-events: none;
        }

        .drop-zone-icon {
            font-size: 3rem;
            display: block;
            margin-bottom: 10px;
        }

        .drop-zone-hint {
            font-size: 0.9rem;
            color: #666;
            margin-top: 5px;
        }

        .image-preview-container {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .image-preview-item {
            position: relative;
            border-radius: 8px;
            overflow: hidden;
            background: white;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .image-preview-item img {
            width: 120px;
            height: 120px;
            object-fit: cover;
            display: block;
        }

        .image-preview-remove {
            position: absolute;
            top: 5px;
            right: 5px;
            background: rgba(0,0,0,0.7);
            color: white;
            border: none;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            cursor: pointer;
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .image-preview-remove:hover {
            background: rgba(255,0,0,0.8);
        }

        .image-extract-address {
            position: absolute;
            bottom: 5px;
            left: 5px;
            background: rgba(0, 123, 255, 0.9);
            color: white;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            font-size: 11px;
            padding: 4px 8px;
            transition: background-color 0.3s;
            font-weight: 500;
        }

        .image-extract-address:hover {
            background: rgba(0, 123, 255, 1);
        }

        .image-extract-address:disabled {
            background: rgba(128, 128, 128, 0.8);
            cursor: not-allowed;
        }

        /* Address Extraction Section Styles */
        .address-extraction-section {
            width: 100%;
            margin-bottom: 20px;
        }

        .address-drop-zone {
            border: 2px dashed #ffc107;
            border-radius: 8px;
            padding: 30px;
            text-align: center;
            background: #fffbf0;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 15px;
            position: relative;
            min-height: 140px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .address-drop-zone:hover,
        .address-drop-zone.drag-over {
            border-color: #ff9800;
            background: #fff8e1;
        }

        .address-drop-zone::before {
            content: "📍 ADDRESS EXTRACTION ZONE - Press Ctrl+V";
            position: absolute;
            top: 8px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 11px;
            color: #ff9800;
            font-weight: bold;
            opacity: 0.8;
            background: rgba(255, 255, 255, 0.9);
            padding: 2px 8px;
            border-radius: 3px;
            border: 1px solid #ff9800;
        }

        .address-drop-zone.focused {
            border-color: #ff9800;
            background: #fff8e1;
            box-shadow: 0 0 15px rgba(255, 152, 0, 0.2);
        }

        .address-drop-zone.focused::before {
            content: "📍 READY TO EXTRACT ADDRESS - Press Ctrl+V";
            color: #ff9800;
            border-color: #ff9800;
            animation: pulse 1.5s infinite;
        }

        .address-drop-zone.processing {
            border-color: #2196f3;
            background: #f3f9ff;
            box-shadow: 0 0 20px rgba(33, 150, 243, 0.3);
        }

        .address-drop-zone.processing::before {
            content: "🔍 EXTRACTING ADDRESS...";
            color: #2196f3;
            border-color: #2196f3;
        }

        .address-preview-container {
            display: flex;
            justify-content: center;
            margin-bottom: 15px;
        }

        .address-preview-item {
            position: relative;
            border-radius: 8px;
            overflow: hidden;
            background: white;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            max-width: 300px;
        }

        .address-preview-item img {
            width: 100%;
            height: 200px;
            object-fit: cover;
            display: block;
        }

        .address-preview-remove {
            position: absolute;
            top: 5px;
            right: 5px;
            background: rgba(0,0,0,0.7);
            color: white;
            border: none;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            cursor: pointer;
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .address-preview-remove:hover {
            background: rgba(255,0,0,0.8);
        }

        .address-extract-btn {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 152, 0, 0.9);
            color: white;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-size: 12px;
            padding: 8px 16px;
            transition: background-color 0.3s;
            font-weight: 500;
        }

        .address-extract-btn:hover {
            background: rgba(255, 152, 0, 1);
        }

        .address-extract-btn:disabled {
            background: rgba(128, 128, 128, 0.8);
            cursor: not-allowed;
        }

        .extracted-address-display {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
        }

        .extracted-address-display h4 {
            margin: 0 0 10px 0;
            color: #495057;
        }

        .extracted-address-text {
            background: white;
            border: 1px solid #ced4da;
            border-radius: 4px;
            padding: 10px;
            margin-bottom: 10px;
            font-family: monospace;
            font-size: 14px;
            line-height: 1.5;
        }

        .btn-use-address {
            background: #28a745;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 500;
            transition: background-color 0.3s;
        }

        .btn-use-address:hover {
            background: #218838;
        }

        /* Structured Content Styles */
        .structured-content-section {
            margin-bottom: 20px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #e9ecef;
        }

        .structured-content-actions {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .btn-parse {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-parse:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(40, 167, 69, 0.3);
        }

        .btn-quick-add {
            background: linear-gradient(135deg, #007bff 0%, #0056b3 100%);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-quick-add:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 123, 255, 0.3);
        }

        .parsed-content-preview {
            margin-top: 15px;
            padding: 15px;
            background: white;
            border-radius: 6px;
            border: 1px solid #dee2e6;
            font-size: 0.9rem;
        }

        .parsed-content-preview h4 {
            margin: 0 0 10px 0;
            color: #495057;
            font-size: 1rem;
        }

        .parsed-content-preview .parsed-item {
            margin-bottom: 8px;
            padding: 4px 0;
            border-bottom: 1px solid #f1f3f4;
        }

        .parsed-content-preview .parsed-item:last-child {
            border-bottom: none;
        }

        .parsed-content-preview .parsed-label {
            font-weight: 600;
            color: #495057;
            display: inline-block;
            min-width: 80px;
        }

        .parsed-content-preview .parsed-value {
            color: #6c757d;
        }

        /* URL Display Styles */
        .generated-url-display {
            margin-bottom: 15px;
            padding: 15px;
            background: #e8f5e8;
            border-radius: 8px;
            border: 1px solid #d4edda;
        }

        .url-display-box {
            padding: 10px;
            background: white;
            border-radius: 6px;
            border: 1px solid #c3e6cb;
        }

        .url-display-box a {
            color: #155724;
            text-decoration: none;
            font-weight: 500;
        }

        .url-display-box a:hover {
            text-decoration: underline;
        }

        /* Delete Button Styles */
        .delete-recommendation-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid #dc3545;
            border-radius: 50%;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
            z-index: 10;
        }

        .delete-recommendation-btn:hover {
            background: #dc3545;
            color: white;
            transform: scale(1.1);
        }

        .delete-recommendation-btn:active {
            transform: scale(0.95);
        }

        .place-item {
            position: relative;
        }

        .form-actions {
            display: flex;
            gap: 20px;
            justify-content: space-between;
            align-items: center;
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #e0e0e0;
        }

        .export-import-actions {
            display: flex;
            gap: 10px;
        }

        .primary-actions {
            display: flex;
            gap: 10px;
        }

        .btn-export, .btn-import {
            background: #17a2b8;
            color: white;
            border: none;
            padding: 10px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: background-color 0.3s;
        }

        .btn-export:hover {
            background: #138496;
        }

        .btn-import {
            background: #28a745;
        }

        .btn-import:hover {
            background: #218838;
        }

        .btn-export:disabled, .btn-import:disabled {
            background: #6c757d;
            cursor: not-allowed;
        }

        .btn-primary {
            background: linear-gradient(135deg, #1976D2 0%, #42a5f5 100%);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-primary:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(25, 118, 210, 0.3);
        }

        .btn-secondary {
            background: #f5f5f5;
            color: #666;
            border: 1px solid #ddd;
            padding: 10px 20px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-secondary:hover {
            background: #e0e0e0;
        }

        .btn-extract {
            background: linear-gradient(135deg, #4CAF50 0%, #66bb6a 100%);
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 6px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            margin-left: 10px;
            transition: all 0.2s;
        }

        .btn-extract:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(76, 175, 80, 0.3);
        }

        .form-divider {
            text-align: center;
            color: #999;
            font-weight: 600;
            margin: 20px 0;
            position: relative;
        }

        .form-divider::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 0;
            right: 0;
            height: 1px;
            background: #e0e0e0;
            z-index: 1;
        }

        .form-divider::after {
            content: 'OR fill manually below:';
            background: white;
            padding: 0 15px;
            position: relative;
            z-index: 2;
        }

        #googleMapsUrl {
            margin-bottom: 0;
        }

        .url-input-row {
            display: flex;
            gap: 10px;
            align-items: flex-end;
        }

        .url-input-row .form-group {
            flex: 1;
            margin-bottom: 0;
        }

        /* Admin Panel Backdrop */
        .admin-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 1500;
            display: none;
        }

        .admin-backdrop.show {
            display: block;
        }

        /* Professional Mobile Place Details Modal */
        .image-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.75);
            z-index: 3000;
            display: none;
            align-items: flex-end;
            padding: 0;
            backdrop-filter: blur(4px);
        }

        .image-modal.show {
            display: flex;
        }

        .image-modal-content {
            position: relative;
            width: 100%;
            height: 95vh;
            background: white;
            border-radius: 20px 20px 0 0;
            overflow: hidden;
            box-shadow: 0 -10px 30px rgba(0,0,0,0.3);
            animation: slideUp 0.3s ease-out;
            display: flex;
            flex-direction: column;
        }

        @keyframes slideUp {
            from {
                transform: translateY(100%);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .image-modal-header {
            background: linear-gradient(135deg, #1976D2 0%, #42a5f5 100%);
            color: white;
            padding: 24px 20px 20px 20px;
            position: relative;
            box-shadow: 0 2px 20px rgba(25, 118, 210, 0.3);
        }
        
        .image-modal-header h2 {
            font-size: 1.4rem;
            font-weight: 700;
            margin: 0;
            line-height: 1.3;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        }

        .image-modal-header::before {
            content: '';
            position: absolute;
            top: 8px;
            left: 50%;
            transform: translateX(-50%);
            width: 40px;
            height: 4px;
            background: rgba(255,255,255,0.3);
            border-radius: 2px;
        }

        .image-modal-title {
            margin: 8px 0 0 0;
            font-size: 1.4rem;
            font-weight: 700;
            line-height: 1.3;
            padding-right: 50px;
        }

        .image-modal-back {
            position: absolute;
            top: 16px;
            left: 16px;
            background: rgba(0,0,0,0.7);
            border: none;
            color: white;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            padding: 10px 16px;
            border-radius: 25px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            backdrop-filter: blur(10px);
            z-index: 1000;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            min-height: 44px;
            -webkit-tap-highlight-color: transparent;
        }

        .image-modal-back:hover, .image-modal-back:active {
            background: rgba(0,0,0,0.8);
            transform: scale(1.05);
        }

        .image-modal-close {
            position: absolute;
            top: 16px;
            right: 16px;
            background: rgba(0,0,0,0.7);
            border: none;
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 8px;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            backdrop-filter: blur(10px);
            z-index: 1000;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .image-modal-close:hover {
            background: rgba(255,255,255,0.25);
            transform: scale(1.1);
        }

        .image-modal-body {
            padding: 0;
            flex: 1;
            overflow-y: auto;
            scroll-behavior: smooth;
            display: flex;
            flex-direction: column;
            padding-bottom: 100px; /* Reserve space for action buttons */
        }

        /* Desktop styles for larger screens */
        @media (min-width: 768px) {
            .image-modal {
                align-items: center;
                justify-content: center;
                padding: 20px;
            }

            .image-modal-content {
                width: auto;
                max-width: 600px;
                max-height: 85vh;
                border-radius: 16px;
                animation: scaleIn 0.3s ease-out;
            }

            @keyframes scaleIn {
                from {
                    transform: scale(0.9);
                    opacity: 0;
                }
                to {
                    transform: scale(1);
                    opacity: 1;
                }
            }

            .image-modal-header::before {
                display: none;
            }

            .image-modal-title {
                padding-right: 60px;
                padding-left: 100px;
                font-size: 1.3rem;
                text-align: center;
            }

            .image-modal-back {
                padding: 8px 14px;
                font-size: 0.9rem;
                top: 12px;
                left: 12px;
                min-height: 40px;
            }

            .image-modal-close {
                width: 48px;
                height: 48px;
                font-size: 1.8rem;
                top: 12px;
                right: 12px;
                background: rgba(0,0,0,0.8);
            }
        }

        /* Edit Place Modal Styles */
        .edit-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.75);
            z-index: 3000;
            display: none;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .edit-modal.show {
            display: flex;
        }

        .edit-modal-content {
            position: relative;
            width: 100%;
            max-width: 600px;
            max-height: 90vh;
            background: white;
            border-radius: 16px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            animation: scaleIn 0.3s ease-out;
        }

        .edit-modal-header {
            background: linear-gradient(135deg, #9C27B0 0%, #BA68C8 100%);
            color: white;
            padding: 20px;
            position: relative;
        }

        .edit-modal-title {
            margin: 0;
            font-size: 1.4rem;
            font-weight: 700;
            padding-right: 50px;
        }

        .edit-modal-close {
            position: absolute;
            top: 15px;
            right: 15px;
            background: rgba(0,0,0,0.7);
            border: none;
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 8px;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .edit-modal-close:hover {
            background: rgba(255,255,255,0.25);
            transform: scale(1.1);
        }

        .edit-modal-body {
            padding: 24px;
            max-height: calc(90vh - 140px);
            overflow-y: auto;
        }

        .edit-form-section {
            margin-bottom: 20px;
        }

        .edit-form-section label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #333;
        }

        .current-name-display {
            background: #f5f5f5;
            padding: 12px;
            border-radius: 8px;
            border-left: 4px solid #9C27B0;
            font-weight: 500;
            color: #555;
        }

        .edit-input {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 1rem;
            transition: border-color 0.3s ease;
            margin-bottom: 10px;
        }

        .edit-input:focus {
            outline: none;
            border-color: #9C27B0;
            box-shadow: 0 0 0 3px rgba(156, 39, 176, 0.1);
        }

        .auto-parse-btn {
            background: linear-gradient(135deg, #FF9800 0%, #FFC107 100%);
            color: white;
            border: none;
            padding: 10px 16px;
            border-radius: 8px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
            box-shadow: 0 2px 8px rgba(255, 152, 0, 0.3);
        }

        .auto-parse-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(255, 152, 0, 0.4);
        }

        .dish-examples {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 8px;
        }

        .dish-example {
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.3s ease;
            color: #495057;
        }

        .dish-example:hover {
            background: #9C27B0;
            color: white;
            border-color: #9C27B0;
            transform: translateY(-1px);
        }

        .edit-modal-actions {
            display: flex;
            gap: 12px;
            margin-top: 24px;
        }

        .cancel-edit-btn, .save-edit-btn {
            flex: 1;
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .cancel-edit-btn {
            background: #f5f5f5;
            color: #666;
        }

        .cancel-edit-btn:hover {
            background: #eeeeee;
            transform: translateY(-1px);
        }

        .save-edit-btn {
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
            color: white;
            box-shadow: 0 2px 8px rgba(76, 175, 80, 0.3);
        }

        .save-edit-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(76, 175, 80, 0.4);
        }

        .save-edit-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* New Edit Modal Form Elements */
        .edit-textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 1rem;
            font-family: inherit;
            transition: border-color 0.3s ease;
            resize: vertical;
            min-height: 60px;
        }

        .edit-textarea:focus {
            outline: none;
            border-color: #9C27B0;
            box-shadow: 0 0 0 3px rgba(156, 39, 176, 0.1);
        }

        .hours-input-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .hours-quick-options {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 10px;
        }

        .hours-quick-btn {
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.3s ease;
            color: #495057;
            font-weight: 500;
        }

        .hours-quick-btn:hover {
            background: #9C27B0;
            color: white;
            border-color: #9C27B0;
            transform: translateY(-1px);
        }

        /* Mobile responsiveness for edit modal */
        @media (max-width: 768px) {
            .edit-modal-content {
                max-width: calc(100vw - 40px);
                max-height: calc(100vh - 40px);
                margin: 20px;
            }
            
            .edit-modal-body {
                padding: 20px;
                max-height: calc(100vh - 180px);
            }
            
            .hours-quick-options {
                flex-direction: column;
            }
            
            .hours-quick-btn {
                width: 100%;
                justify-content: center;
            }
        }

        /* Professional Mobile Content Layout */
        .place-details-full {
            padding: 20px 24px;
            flex-shrink: 0;
            background: linear-gradient(135deg, #fafbff 0%, #f8fafc 100%);
        }

        .place-hero-section {
            margin-bottom: 20px;
        }

        .place-main-image {
            width: 100%;
            height: 220px;
            border-radius: 16px;
            object-fit: cover;
            box-shadow: 0 8px 32px rgba(0,0,0,0.12);
            margin-bottom: 20px;
            border: 2px solid #fff;
        }

        .place-info-full {
            width: 100%;
        }

        .place-name-full {
            font-size: 1.6rem;
            font-weight: 800;
            color: #1a202c;
            margin-bottom: 12px;
            line-height: 1.3;
            letter-spacing: -0.02em;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .place-address-full {
            color: #4a5568;
            margin-bottom: 20px;
            font-size: 1.05rem;
            line-height: 1.5;
            display: flex;
            align-items: flex-start;
            gap: 10px;
            background: white;
            padding: 16px;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
            border: 1px solid #e2e8f0;
        }

        .place-address-full::before {
            content: '📍';
            flex-shrink: 0;
            margin-top: 1px;
        }

        .place-stats-full {
            display: flex;
            gap: 12px;
            margin-bottom: 24px;
            flex-wrap: wrap;
            background: white;
            padding: 16px;
            border-radius: 16px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.08);
            border: 1px solid #e2e8f0;
        }

        .place-stat {
            display: flex;
            align-items: center;
            gap: 8px;
            background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
            padding: 12px 16px;
            border-radius: 12px;
            font-weight: 600;
            font-size: 0.9rem;
            border: 1px solid #e2e8f0;
            box-shadow: 0 2px 8px rgba(0,0,0,0.04);
            transition: all 0.2s ease;
        }
        
        .place-stat:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        .place-stat.rating {
            background: linear-gradient(135deg, #fef7cd 0%, #fde047 100%);
            color: #a16207;
            border-color: #fde047;
        }

        .place-stat.distance {
            background: linear-gradient(135deg, #dbeafe 0%, #93c5fd 100%);
            color: #1e40af;
            border-color: #93c5fd;
        }

        .place-stat.category {
            background: linear-gradient(135deg, #d1fae5 0%, #6ee7b7 100%);
            color: #065f46;
            border-color: #6ee7b7;
        }

        .place-description-full {
            color: #4b5563;
            line-height: 1.5;
            margin-bottom: 16px;
            font-size: 0.95rem;
            padding: 12px;
            background: #f9fafb;
            border-radius: 8px;
            border-left: 4px solid #1976D2;
        }

        /* Opening Hours Styles */
        .opening-hours-section {
            margin-bottom: 16px;
            background: #fff9f0;
            border-radius: 12px;
            padding: 16px;
            border: 1px solid #fed7aa;
            box-shadow: 0 2px 8px rgba(251, 146, 60, 0.1);
        }

        .opening-hours-title {
            font-size: 1.1rem;
            font-weight: 700;
            color: #ea580c;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .opening-hours-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .hours-day {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: white;
            border-radius: 8px;
            border: 1px solid #fed7aa;
            font-size: 0.9rem;
            transition: all 0.2s ease;
        }

        .hours-day:hover {
            background: #fef3e2;
            border-color: #fb923c;
        }

        .hours-day.today {
            background: linear-gradient(135deg, #ea580c 0%, #dc2626 100%);
            color: white;
            font-weight: 600;
            border-color: #ea580c;
            box-shadow: 0 2px 8px rgba(234, 88, 12, 0.3);
        }

        .day-name {
            font-weight: 600;
        }

        .day-hours {
            font-family: monospace;
            font-size: 0.85rem;
        }

        .opening-hours-simple {
            background: white;
            padding: 12px;
            border-radius: 8px;
            border: 1px solid #fed7aa;
            font-size: 0.95rem;
            color: #7c2d12;
            text-align: center;
            font-weight: 500;
        }

        .opening-hours-unavailable {
            background: #fef2f2;
            border: 1px solid #fecaca;
            border-radius: 8px;
            padding: 12px;
            text-align: center;
        }

        .opening-hours-unavailable span {
            display: block;
            color: #dc2626;
            font-weight: 600;
            font-size: 0.9rem;
            margin-bottom: 4px;
        }

        .opening-hours-unavailable small {
            color: #7f1d1d;
            font-size: 0.8rem;
        }

        /* Enhanced Place Information Sections */
        .place-types-section,
        .place-contact-section,
        .place-business-section,
        .place-metadata-section {
            margin-bottom: 16px;
            background: white;
            border-radius: 12px;
            padding: 16px;
            border: 1px solid #e5e7eb;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
        }

        .place-types-title,
        .place-contact-title,
        .place-business-title,
        .place-metadata-title {
            font-size: 1rem;
            font-weight: 700;
            color: #374151;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .place-types-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .place-type-tag {
            background: linear-gradient(135deg, #f3f4f6 0%, #e5e7eb 100%);
            color: #4b5563;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 500;
            border: 1px solid #d1d5db;
            text-transform: capitalize;
        }

        .place-phone,
        .place-website,
        .place-price,
        .place-status,
        .place-added-by,
        .place-added-date,
        .place-featured {
            margin-bottom: 8px;
            font-size: 0.95rem;
            color: #4b5563;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .place-phone a,
        .place-website a {
            color: #1976D2;
            text-decoration: none;
            font-weight: 600;
        }

        .place-phone a:hover,
        .place-website a:hover {
            text-decoration: underline;
        }

        .place-featured {
            background: linear-gradient(135deg, #fef7cd 0%, #fde047 100%);
            color: #a16207;
            padding: 8px 12px;
            border-radius: 8px;
            border: 1px solid #fde047;
            font-weight: 600;
        }

        .place-stat.reviews {
            background: linear-gradient(135deg, #ecfdf5 0%, #86efac 100%);
            color: #166534;
            border-color: #86efac;
        }

        /* Enhanced edit modal fields */
        .edit-form-section.full-width {
            grid-column: 1 / -1;
        }

        .edit-info-display {
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 16px;
        }

        .edit-info-title {
            font-size: 0.9rem;
            font-weight: 600;
            color: #475569;
            margin-bottom: 8px;
        }

        .edit-info-item {
            font-size: 0.85rem;
            color: #64748b;
            margin-bottom: 4px;
        }

        /* Gemini Search Section Styles */
        .gemini-search-section {
            background: white;
            padding: 20px;
            border-bottom: 1px solid #e0e0e0;
            margin-bottom: 0;
        }

        .search-input-header {
            text-align: center;
            margin-bottom: 20px;
        }

        .search-input-header h3 {
            margin: 0 0 5px 0;
            color: #9C27B0;
            font-size: 1.3rem;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .search-input-header p {
            margin: 0;
            color: #666;
            font-size: 0.95rem;
        }

        .search-input-container {
            display: flex;
            gap: 15px;
            align-items: end;
            margin-bottom: 15px;
        }

        .search-input {
            flex: 1;
            padding: 12px 16px;
            border: 2px solid #e0e0e0;
            border-radius: 25px;
            font-size: 1rem;
            transition: all 0.3s ease;
            background: #f8f9fa;
        }

        .search-input:focus {
            outline: none;
            border-color: #9C27B0;
            background: white;
            box-shadow: 0 0 0 3px rgba(156, 39, 176, 0.1);
        }

        .btn-gemini-search {
            background: linear-gradient(135deg, #9C27B0 0%, #673AB7 100%);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 25px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            white-space: nowrap;
            box-shadow: 0 2px 8px rgba(156, 39, 176, 0.3);
            min-height: 44px;
        }

        .btn-gemini-search:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(156, 39, 176, 0.4);
        }

        .btn-gemini-search:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .search-suggestions {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
        }

        .search-suggestion {
            background: linear-gradient(135deg, #f3e5f5 0%, #e1bee7 100%);
            color: #4a148c;
            border: 1px solid #ce93d8;
            padding: 6px 12px;
            border-radius: 15px;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: 500;
        }

        .search-suggestion:hover {
            background: linear-gradient(135deg, #9C27B0 0%, #673AB7 100%);
            color: white;
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(156, 39, 176, 0.3);
        }

        /* Search Results Table Section Styles */
        .search-results-section {
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(156, 39, 176, 0.15);
            margin-bottom: 20px;
            border: 2px solid #9C27B0;
            overflow: hidden;
        }

        .search-results-header {
            background: linear-gradient(135deg, #9C27B0 0%, #673AB7 100%);
            color: white;
            padding: 16px 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 12px;
        }

        .search-results-header h4 {
            margin: 0;
            font-size: 1.2rem;
            font-weight: 700;
        }

        .search-results-count {
            background: rgba(255, 255, 255, 0.2);
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 600;
        }

        .btn-view-toggle {
            background: rgba(255, 255, 255, 0.9);
            color: #9C27B0;
            border: none;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-view-toggle:hover {
            background: white;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .search-results-content {
            padding: 0;
        }

        .search-query-info {
            background: #f8f0ff;
            padding: 16px 20px;
            border-bottom: 1px solid #e1bee7;
            font-size: 1rem;
            color: #4a148c;
            font-weight: 600;
        }

        .search-query-text {
            color: #9C27B0;
            font-weight: 700;
            background: rgba(156, 39, 176, 0.1);
            padding: 4px 8px;
            border-radius: 6px;
        }

        .search-results-table {
            max-height: 400px;
            overflow-y: auto;
        }

        .search-table-row {
            display: grid;
            grid-template-columns: 80px 1fr auto auto;
            gap: 16px;
            padding: 16px 20px;
            border-bottom: 1px solid #f0f0f0;
            align-items: center;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .search-table-row:hover {
            background: #f8f0ff;
            border-left: 4px solid #9C27B0;
        }

        .search-table-row:last-child {
            border-bottom: none;
        }

        .search-table-image {
            width: 70px;
            height: 70px;
            border-radius: 8px;
            object-fit: cover;
            background: #f0f0f0;
        }

        .search-table-info {
            display: flex;
            flex-direction: column;
            gap: 6px;
            min-width: 0;
        }

        .search-table-name {
            font-size: 1.1rem;
            font-weight: 700;
            color: #333;
            line-height: 1.2;
        }

        .search-table-address {
            font-size: 0.9rem;
            color: #666;
            line-height: 1.3;
        }

        .search-table-hours {
            font-size: 0.8rem;
            color: #4caf50;
            background: rgba(76, 175, 80, 0.1);
            padding: 2px 6px;
            border-radius: 12px;
            display: inline-block;
            font-weight: 500;
        }

        .search-table-stats {
            display: flex;
            flex-direction: column;
            gap: 8px;
            align-items: flex-end;
        }

        .search-table-rating {
            background: linear-gradient(135deg, #fef7cd 0%, #fde047 100%);
            color: #a16207;
            border: 1px solid #fde047;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 600;
        }

        .search-table-distance {
            background: linear-gradient(135deg, #dbeafe 0%, #93c5fd 100%);
            color: #1e40af;
            border: 1px solid #93c5fd;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 600;
        }

        .search-table-actions {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .search-table-btn {
            background: #9C27B0;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.8rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            min-width: 80px;
        }

        .search-table-btn:hover {
            background: #7B1FA2;
            transform: translateY(-1px);
        }

        .search-table-btn.secondary {
            background: #e0e0e0;
            color: #666;
        }

        .search-table-btn.secondary:hover {
            background: #d0d0d0;
        }

        /* Mobile responsiveness for search table */
        @media (max-width: 768px) {
            .search-results-header {
                flex-direction: column;
                align-items: stretch;
                text-align: center;
                gap: 8px;
            }

            .search-table-row {
                grid-template-columns: 60px 1fr;
                grid-template-rows: auto auto;
                gap: 12px;
                padding: 16px;
                min-height: 88px; /* Ensure touch-friendly minimum height */
            }

            .search-table-image {
                width: 60px;
                height: 60px;
                grid-row: 1 / 3;
            }

            .search-table-info {
                grid-column: 2;
                grid-row: 1;
            }

            .search-table-stats,
            .search-table-actions {
                grid-column: 1 / 3;
                grid-row: 2;
                flex-direction: row;
                justify-content: space-between;
                align-items: center;
                margin-top: 8px;
                padding-top: 8px;
                border-top: 1px solid #f0f0f0;
            }

            .search-table-btn {
                min-width: 80px;
                min-height: 44px; /* Touch-friendly minimum height */
                padding: 8px 12px;
                font-size: 0.8rem;
                font-weight: 600;
            }
        }

        /* Enhanced mobile-first design optimizations */
        @media (max-width: 768px) {
            /* Ultra touch-friendly button sizing for phones */
            .btn-action,
            .btn-gemini-search,
            .btn-view-toggle,
            .search-table-btn,
            .hours-quick-btn {
                min-height: 60px !important;
                min-width: 60px !important;
                padding: 18px 24px !important;
                font-size: 1.2rem !important;
                font-weight: 700 !important;
                touch-action: manipulation;
                -webkit-tap-highlight-color: rgba(0, 0, 0, 0.1);
                margin: 8px 0 !important;
            }
            
            /* Edit and action buttons in place items - Reduced size */
            .edit-place-btn,
            .view-details-btn {
                min-height: 36px !important;
                min-width: 80px !important;
                padding: 8px 12px !important;
                font-size: 0.85rem !important;
                margin: 2px !important;
                border-radius: 6px !important;
            }

            /* Better spacing for mobile */
            .place-stats-full {
                gap: 8px;
                margin-bottom: 20px;
            }

            .place-stat {
                padding: 8px 12px;
                font-size: 0.8rem;
                min-height: 32px;
            }

            /* Enhanced typography for mobile readability */
            .place-name-full {
                font-size: 1.3rem;
                line-height: 1.3;
                margin-bottom: 12px;
            }

            .place-address-full {
                font-size: 0.95rem;
                line-height: 1.4;
                margin-bottom: 20px;
            }

            /* Better information section spacing */
            .place-types-section,
            .place-contact-section,
            .place-business-section,
            .place-metadata-section {
                margin-bottom: 20px;
                padding: 16px;
            }

            .place-types-title,
            .place-contact-title,
            .place-business-title,
            .place-metadata-title {
                font-size: 1rem;
                margin-bottom: 16px;
            }

            /* Ultra-enhanced search input for mobile */
            .search-input {
                padding: 20px 24px !important;
                font-size: 1.3rem !important;
                border-radius: 16px !important;
                min-height: 64px !important;
                border: 3px solid #e0e0e0 !important;
                background: white !important;
                box-shadow: 0 4px 16px rgba(0,0,0,0.08) !important;
            }
            
            .search-input:focus {
                border-color: #9C27B0 !important;
                box-shadow: 0 4px 20px rgba(156, 39, 176, 0.2) !important;
            }

            .btn-gemini-search {
                padding: 20px 28px !important;
                font-size: 1.2rem !important;
                border-radius: 16px !important;
                min-height: 64px !important;
                font-weight: 700 !important;
            }
            
            /* Enhanced search section spacing */
            .search-input-container {
                gap: 20px !important;
                margin-bottom: 24px !important;
            }
            
            /* Larger clear search button */
            .clear-search {
                padding: 16px 24px !important;
                font-size: 1.1rem !important;
                min-height: 56px !important;
                border-radius: 16px !important;
                margin: 16px 0 !important;
            }

            /* Ultra compact place list items for mobile */
            .place-item {
                padding: 12px !important;
                padding-bottom: 50px !important; /* Much less space for smaller buttons */
                margin-bottom: 8px !important; /* Tighter spacing between items */
                border-radius: 8px !important;
                min-height: 100px !important; /* More compact height */
                background: white !important;
                box-shadow: 0 1px 6px rgba(0,0,0,0.04) !important; /* Very light shadow */
                border: 1px solid #f0f0f0 !important;
                transition: all 0.3s ease !important;
                display: flex !important;
                flex-direction: column !important;
                position: relative !important;
            }
            
            .place-item:active {
                transform: scale(0.98) !important;
                box-shadow: 0 2px 12px rgba(0,0,0,0.15) !important;
                border-color: #1976D2 !important;
            }

            .place-image,
            .place-image-placeholder {
                width: 100px !important;
                height: 100px !important;
                border-radius: 12px !important;
                margin-right: 16px !important;
            }

            .place-name {
                font-size: 1.1rem !important; /* More compact */
                font-weight: 700 !important;
                margin-bottom: 4px !important; /* Much tighter margin */
                line-height: 1.2 !important; /* Very tight line height */
                color: #1a202c !important;
            }

            .place-address {
                font-size: 0.9rem !important; /* More compact */
                margin-bottom: 4px !important; /* Much tighter margin */
                line-height: 1.3 !important; /* Tighter line height */
                color: #4a5568 !important;
            }
            
            /* Compact opening hours display */
            .place-hours,
            .place-hours-placeholder {
                font-size: 0.8rem !important; /* More compact */
                padding: 4px 8px !important; /* Minimal padding */
                margin-bottom: 4px !important; /* Minimal margin */
                border-radius: 4px !important;
            }

            /* Enhanced loading states */
            .loading {
                padding: 40px 20px;
                text-align: center;
            }

            .loading div {
                font-size: 1.1rem;
                color: #666;
            }

            /* Better modal header for mobile */
            .image-modal-header {
                padding: 24px 20px 20px 20px;
            }

            .image-modal-header h2 {
                font-size: 1.4rem;
                margin: 0;
                font-weight: 700;
            }

            /* Enhanced edit modal for mobile */
            .edit-modal-content {
                max-height: 95vh;
                border-radius: 20px 20px 0 0;
            }

            .edit-modal-body {
                padding: 20px;
            }

            .edit-form-section {
                margin-bottom: 24px;
            }

            .edit-input,
            .edit-textarea {
                padding: 16px;
                font-size: 1rem;
                border-radius: 12px;
                min-height: 44px;
            }

            .edit-textarea {
                min-height: 80px;
            }

            /* Ultra compact place meta information */
            .place-meta {
                gap: 4px !important; /* Minimal gap */
                flex-wrap: wrap !important;
                margin-top: 4px !important; /* Minimal margin */
            }
            
            .place-rating,
            .place-distance,
            .place-category {
                font-size: 0.75rem !important; /* Much smaller font */
                padding: 3px 6px !important; /* Minimal padding */
                border-radius: 4px !important; /* Smaller radius */
                font-weight: 600 !important;
                min-height: 20px !important; /* Much smaller height */
                display: inline-flex !important;
                align-items: center !important;
            }
            
            /* Ultra compact place actions section */
            .place-actions {
                position: static !important;
                width: 100% !important;
                justify-content: center !important;
                flex-wrap: wrap !important;
                padding: 4px 0 !important; /* Minimal padding */
                margin-top: 4px !important; /* Minimal margin */
                gap: 4px !important; /* Minimal gap */
                transform: none !important;
                border-top: 1px solid #f5f5f5 !important;
                background: none !important;
                box-shadow: none !important;
            }
            
            /* Enhanced modal header for mobile */
            .image-modal-header {
                padding: 28px 24px !important;
                min-height: 80px !important;
            }
            
            .image-modal-header h2 {
                font-size: 1.6rem !important;
                line-height: 1.3 !important;
            }
            
            /* Enhanced modal content spacing */
            .place-details-full {
                padding: 28px !important;
            }
            
            .place-main-image {
                height: 240px !important;
                border-radius: 20px !important;
                margin-bottom: 24px !important;
            }
            
            /* Enhanced place stats for mobile */
            .place-stats-full {
                padding: 20px !important;
                gap: 16px !important;
                margin-bottom: 28px !important;
            }
            
            .place-stat {
                padding: 16px 20px !important;
                font-size: 1.05rem !important;
                min-height: 48px !important;
                border-radius: 16px !important;
            }

            /* Better visual feedback for interactions */
            .place-item:active,
            .search-table-row:active {
                transform: scale(0.98);
                transition: transform 0.1s ease;
            }

            .btn-action:active,
            .search-table-btn:active {
                transform: scale(0.95);
                transition: transform 0.1s ease;
            }
        }

        .search-status {
            text-align: center;
            padding: 10px;
            border-radius: 8px;
            margin-top: 10px;
            font-size: 0.9rem;
            display: none;
        }

        .search-status.loading {
            background: #e3f2fd;
            color: #1976d2;
            border: 1px solid #bbdefb;
        }

        .search-status.success {
            background: #e8f5e8;
            color: #2e7d32;
            border: 1px solid #a5d6a7;
        }

        .search-status.error {
            background: #ffebee;
            color: #c62828;
            border: 1px solid #ef9a9a;
        }

        .clear-search {
            background: #ff5722;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.85rem;
            cursor: pointer;
            margin-left: 10px;
            transition: all 0.2s ease;
        }

        .clear-search:hover {
            background: #e64a19;
            transform: translateY(-1px);
        }

        .place-actions {
            display: flex;
            gap: 16px;
            margin-bottom: 20px;
            padding: 20px 24px;
            position: relative;
            z-index: 100;
            background: linear-gradient(135deg, #fff 0%, #f8fafc 100%);
            border-top: 2px solid #e2e8f0;
            margin-top: 16px;
            border-radius: 20px 20px 0 0;
            box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.06);
        }

        .btn-action {
            background: linear-gradient(135deg, #1976D2 0%, #1565C0 100%);
            color: white;
            border: none;
            padding: 16px 28px;
            border-radius: 16px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 10px;
            font-size: 1.05rem;
            box-shadow: 0 6px 20px rgba(25, 118, 210, 0.3);
            flex: 1;
            justify-content: center;
            min-height: 56px;
            letter-spacing: 0.01em;
            position: relative;
            overflow: hidden;
        }
        
        .btn-action::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s ease;
        }
        
        .btn-action:hover::before {
            left: 100%;
        }

        .btn-action:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(25, 118, 210, 0.4);
        }

        /* Desktop adjustments */
        @media (min-width: 768px) {
            .place-details-full {
                display: flex;
                gap: 24px;
                padding: 24px;
            }

            .place-hero-section {
                flex-shrink: 0;
                width: 280px;
                margin-bottom: 0;
            }

            .place-main-image {
                height: 280px;
            }

            .place-info-full {
                flex: 1;
            }

            .place-actions {
                padding: 0;
            }

            .btn-action {
                flex: none;
            }
        }

        /* Professional Photo Gallery */
        .photo-gallery {
            background: #f8fafc;
            margin: 16px -20px 0 -20px;
            padding: 20px 20px 24px 20px;
            border-top: 1px solid #e2e8f0;
            flex: 1;
            overflow: hidden;
        }

        .gallery-title {
            font-size: 1.1rem;
            font-weight: 700;
            color: #1a1a1a;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
        }
        
        .gallery-scroll-hint {
            font-size: 0.8rem;
            color: #6b7280;
            font-weight: 500;
        }

        .gallery-title::before {
            content: '🖼️';
            font-size: 1.1rem;
        }

        .photo-grid {
            display: flex;
            gap: 12px;
            overflow-x: auto;
            padding-bottom: 8px;
            scroll-behavior: smooth;
            -webkit-overflow-scrolling: touch;
        }
        
        .photo-grid::-webkit-scrollbar {
            height: 4px;
        }
        
        .photo-grid::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 2px;
        }
        
        .photo-grid::-webkit-scrollbar-thumb {
            background: #c1c1c1;
            border-radius: 2px;
        }
        
        .photo-grid::-webkit-scrollbar-thumb:hover {
            background: #a8a8a8;
        }

        /* Desktop gallery adjustments */
        @media (min-width: 768px) {
            .photo-gallery {
                margin: 0;
                background: white;
                border-top: 1px solid #e2e8f0;
                border-radius: 0 0 16px 16px;
            }

            .photo-grid {
                display: grid;
                grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
                gap: 18px;
                overflow-x: visible;
                padding-bottom: 0;
            }
            
            .gallery-image-container {
                width: 100%;
            }
        }

        .gallery-image-container {
            position: relative;
            width: 140px;
            height: 120px;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            flex-shrink: 0;
        }

        .gallery-image {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 8px;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .gallery-image:hover {
            transform: scale(1.05);
        }

        .gallery-loading {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #f8f9fa;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
        }

        .loading-spinner {
            width: 24px;
            height: 24px;
            border: 3px solid #e0e0e0;
            border-top: 3px solid #1976D2;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 8px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-text {
            font-size: 12px;
            color: #666;
            text-align: center;
        }

        .gallery-error {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #f5f5f5;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            border: 2px dashed #ddd;
        }

        .error-icon {
            font-size: 20px;
            margin-bottom: 4px;
        }

        .error-text {
            font-size: 10px;
            color: #999;
            text-align: center;
        }

        /* Loading animation */
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .no-photos {
            text-align: center;
            color: #666;
            font-style: italic;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 2px dashed #ddd;
        }

        /* Enhanced place items */
        .place-item {
            position: relative;
        }

        /* Distance conversion display */
        .distance-conversion {
            font-size: 0.75rem;
            color: #888;
            margin-left: 5px;
        }

        /* Action Buttons Container */
        .place-actions {
            position: absolute;
            top: 50%;
            right: 15px;
            transform: translateY(-50%);
            display: flex;
            gap: 8px;
            z-index: 10;
        }

        /* View Details Button */
        .view-details-btn {
            background: linear-gradient(135deg, #1976D2 0%, #42a5f5 100%);
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.8rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(25, 118, 210, 0.3);
            min-height: 44px;
            min-width: 44px;
        }

        .view-details-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(25, 118, 210, 0.4);
        }

        .view-details-btn:active {
            transform: translateY(0px);
            box-shadow: 0 2px 6px rgba(25, 118, 210, 0.3);
        }

        /* Edit Place Button */
        .edit-place-btn {
            background: linear-gradient(135deg, #9C27B0 0%, #BA68C8 100%);
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.8rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(156, 39, 176, 0.3);
            min-height: 44px;
            min-width: 44px;
        }

        .edit-place-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(156, 39, 176, 0.4);
        }

        .edit-place-btn:active {
            transform: translateY(0px);
            box-shadow: 0 2px 6px rgba(156, 39, 176, 0.3);
        }

        /* Mobile responsiveness */
        @media (max-width: 768px) {
            .split-container {
                margin: 10px;
            }
            
            .split-content {
                flex-direction: column;
                height: auto;
            }
            
            .split-panel {
                max-width: 100%;
            }
            
            .list-panel {
                border-right: none;
                border-bottom: 2px solid #e9ecef;
                max-height: 400px;
            }
            
            .map-panel {
                height: 300px;
            }
            
            .map-container-split {
                height: 300px;
            }
            
            .place-item {
                flex-direction: row;
                text-align: left;
            }
            
            .place-image, .place-image-placeholder {
                width: 60px;
                height: 60px;
            }
            
            .place-meta {
                justify-content: flex-start;
            }

            .admin-panel {
                width: 95%;
                max-height: 90vh;
            }

            .form-row {
                flex-direction: column;
                gap: 0;
            }

            .admin-toggle {
                bottom: 10px;
                right: 10px;
            }
        }

        @media (max-width: 480px) {
            /* Extra small phones - ultra touch-friendly */
            body {
                font-size: 18px !important; /* Base font size increase for small phones */
            }
            
            .split-header {
                padding: 20px !important;
            }
            
            .split-header h3 {
                font-size: 1.4rem !important;
                font-weight: 700 !important;
            }
            
            .panel-header {
                padding: 16px 20px !important;
            }
            
            .panel-header h4 {
                font-size: 1.2rem !important;
            }
            
            .places-list {
                padding: 16px !important;
            }
            
            /* Optimized buttons for small phones - balanced size */
            .btn-action,
            .btn-gemini-search {
                min-height: 56px !important;
                padding: 16px 24px !important;
                font-size: 1.1rem !important;
                font-weight: 700 !important;
                border-radius: 12px !important;
                margin: 6px 2px !important;
            }
            
            .edit-place-btn,
            .view-details-btn {
                min-height: 44px !important;
                min-width: 90px !important;
                padding: 12px 16px !important;
                font-size: 0.95rem !important;
                font-weight: 600 !important;
                border-radius: 8px !important;
                margin: 4px 2px !important;
            }
            
            /* Compact place items for small screens */
            .place-item {
                padding: 14px !important; /* More compact padding */
                padding-bottom: 60px !important; /* Less space for smaller buttons */
                min-height: 110px !important; /* More compact height */
                margin-bottom: 10px !important; /* Tighter spacing */
                gap: 8px !important; /* Minimal gap */
                display: flex !important;
                flex-direction: column !important;
                position: relative !important;
            }
            
            .place-image,
            .place-image-placeholder {
                width: 120px !important;
                height: 120px !important;
                margin-right: 20px !important;
                border-radius: 16px !important;
            }
            
            .place-name {
                font-size: 1.15rem !important; /* More compact */
                margin-bottom: 6px !important; /* Minimal margin */
                font-weight: 800 !important;
            }
            
            .place-address {
                font-size: 1rem !important; /* More compact */
                margin-bottom: 6px !important; /* Minimal margin */
                line-height: 1.4 !important; /* Tighter line height */
            }
            
            /* Larger search input for small phones */
            .search-input {
                padding: 24px 28px !important;
                font-size: 1.4rem !important;
                min-height: 72px !important;
                border-radius: 20px !important;
            }
            
            /* Enhanced place hours display */
            .place-hours,
            .place-hours-placeholder {
                font-size: 1.1rem !important;
                padding: 12px 16px !important;
                margin-bottom: 14px !important;
                border-radius: 12px !important;
            }
            
            /* Enhanced tap targets for place meta */
            .place-rating,
            .place-distance,
            .place-category {
                font-size: 1.1rem !important;
                padding: 12px 16px !important;
                min-height: 48px !important;
                border-radius: 16px !important;
                margin: 4px !important;
            }
            
            /* Better modal scaling for small phones */
            .image-modal-content {
                height: 98vh !important;
                border-radius: 24px 24px 0 0 !important;
            }
            
            .place-main-image {
                height: 200px !important;
                border-radius: 24px !important;
            }
            
            /* Better place actions positioning for small phones */
            .place-actions {
                position: static !important;
                width: 100% !important;
                justify-content: center !important;
                flex-wrap: wrap !important;
                padding: 10px 0 !important; /* Reduced padding */
                margin-top: 10px !important; /* Reduced margin */
                gap: 10px !important; /* Reduced gap */
                transform: none !important;
            }
        }
    </style>
</head>
<body>
    <!-- Loading indicator for mobile -->
    <div id="loadingIndicator" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(25, 118, 210, 0.9); color: white; display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 10000; font-family: Arial;">
        <div style="width: 50px; height: 50px; border: 5px solid rgba(255,255,255,0.3); border-top: 5px solid white; border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 20px;"></div>
        <h2 style="margin: 0 0 10px 0;">📍 Loading Nearby Places</h2>
        <p style="margin: 0; text-align: center; padding: 0 20px;">Connecting to Google Maps and finding restaurants, landmarks, coffee shops & culture near you...</p>
    </div>

    <div class="header">
        <h1>📍 Nearby Places</h1>
        <p id="locationDescription">Discover restaurants, landmarks, coffee shops & culture near 118 Hang Bac, Hanoi Old Quarter</p>
    </div>

    <!-- Hotel Location Input Section -->
    <div class="hotel-location-section">
        <div class="location-input-header">
            <h3>🏨 Hotel Location</h3>
            <p>Change your hotel location to find nearby places anywhere</p>
        </div>
        <div class="location-input-container">
            <div class="form-group" style="flex: 1;">
                <label for="hotelMapsUrl">📍 Google Maps URL of your hotel/accommodation</label>
                <input type="url" id="hotelMapsUrl" placeholder="Paste Google Maps link of your hotel location here..." style="width: 100%; padding: 12px; border: 2px solid #e0e0e0; border-radius: 8px; font-size: 1rem;">
            </div>
            <button type="button" id="updateLocationBtn" class="btn-update-location">
                🔄 Update Location
            </button>
        </div>
        
        <!-- GPS Location Option -->
        <div class="gps-option-container" style="margin-top: 15px; text-align: center;">
            <p style="margin-bottom: 10px; color: #666; font-size: 0.9rem;">Or use your current location:</p>
            <button type="button" id="useGpsBtn" class="btn-gps" style="background: linear-gradient(135deg, #FF6B35 0%, #F7931E 100%); color: white; border: none; padding: 12px 24px; border-radius: 8px; font-weight: 600; cursor: pointer; transition: all 0.3s ease; box-shadow: 0 2px 8px rgba(255, 107, 53, 0.3);">
                📍 Use My Location (GPS)
            </button>
            <p style="margin-top: 8px; color: #999; font-size: 0.8rem;">Requires location permission</p>
        </div>
        <div class="current-location-display">
            <span id="currentLocationText">📍 Current: 118 Hang Bac, Hanoi Old Quarter</span>
        </div>
    </div>

    <!-- Gemini AI Search Section -->
    <div class="gemini-search-section">
        <div class="search-input-header">
            <h3>🔮 AI-Powered Search</h3>
            <p>Find specific food or places using Gemini AI (e.g., "bread", "banh canh", "coffee", "bakery")</p>
        </div>
        <div class="search-input-container">
            <input type="text" 
                   id="geminiSearchInput" 
                   class="search-input" 
                   placeholder="Search for specific food, restaurants, or places..."
                   onkeypress="if(event.key==='Enter') geminiSearch()">
            <button type="button" id="geminiSearchBtn" class="btn-gemini-search" onclick="geminiSearch()">
                🤖 Search with AI
            </button>
        </div>
        
        <!-- Popular Search Suggestions -->
        <div class="search-suggestions">
            <span style="font-size: 0.9rem; color: #666; margin-right: 10px;">Popular:</span>
            <div class="search-suggestion" onclick="quickSearch('banh canh')">🍲 Banh Canh</div>
            <div class="search-suggestion" onclick="quickSearch('pho')">🍜 Pho</div>
            <div class="search-suggestion" onclick="quickSearch('coffee')">☕ Coffee</div>
            <div class="search-suggestion" onclick="quickSearch('bread')">🍞 Bread</div>
            <div class="search-suggestion" onclick="quickSearch('banh mi')">🥖 Banh Mi</div>
            <div class="search-suggestion" onclick="quickSearch('bakery')">🧁 Bakery</div>
            <div class="search-suggestion" onclick="quickSearch('bubble tea')">🧋 Bubble Tea</div>
            <div class="search-suggestion" onclick="quickSearch('street food')">🍢 Street Food</div>
            <button class="clear-search" id="clearSearchBtn" onclick="clearSearch()" style="display: none;">✖️ Clear Search</button>
        </div>
        
        <!-- Search Status -->
        <div id="searchStatus" class="search-status"></div>
    </div>

    <div class="controls">
        <div class="control-group">
            <label>Search Radius:</label>
            <select class="radius-select" id="radiusSelect">
                <option value="500">500m - Walking</option>
                <option value="1000">1km - Short walk</option>
                <option value="2000" selected>2km - Bike ride</option>
                <option value="5000">5km - Scooter/taxi</option>
            </select>
        </div>

        <div class="control-group">
            <label>Select Category to Load:</label>
            <p style="font-size: 0.8rem; color: #666; margin: 5px 0;">Click to select one category (single selection for easier viewing)</p>
            <div class="category-filters">
                <div class="category-filter active" data-category="recommend">
                    ⭐ Recommended
                </div>
                <div class="category-filter" data-category="restaurants">
                    🍽️ Restaurants
                </div>
                <div class="category-filter" data-category="landmarks">
                    🏛️ Landmarks
                </div>
                <div class="category-filter" data-category="coffee">
                    ☕ Coffee
                </div>
                <div class="category-filter" data-category="culture">
                    🎭 Culture
                </div>
            </div>
            <div id="selectedCategoriesDisplay" style="margin-top: 10px; font-size: 0.9rem; color: #1976D2; font-weight: bold;">
                No categories selected
            </div>
        </div>

        <div style="display: flex; gap: 10px; flex-wrap: wrap;">
            <button class="load-btn" id="clearPlacesBtn" style="background: #f44336; flex: 0 0 auto; min-width: 120px;">
                🗑️ Clear All
            </button>
        </div>
    </div>

    <div class="info-panel">
        <div class="stats" id="statsContainer">
            <div class="stat">
                <div class="stat-number" id="totalPlaces">0</div>
                <div class="stat-label">Total Places</div>
            </div>
            <div class="stat">
                <div class="stat-number" id="avgRating">0.0</div>
                <div class="stat-label">Avg Rating</div>
            </div>
            <div class="stat">
                <div class="stat-number" id="maxDistance">0</div>
                <div class="stat-label">Max Distance</div>
            </div>
            <div class="stat">
                <div class="stat-number" id="topCategory">-</div>
                <div class="stat-label">Most Places</div>
            </div>
        </div>
    </div>

    <!-- Admin Panel for Adding Recommendations -->
    <div class="admin-panel" id="adminPanel" style="display: none;">
        <div class="admin-header">
            <h3>⭐ Add New Recommendation</h3>
            <button class="close-admin-btn" id="closeAdminBtn">✕</button>
        </div>
        <form id="addRecommendationForm">
            <div class="url-input-row">
                <div class="form-group">
                    <label for="googleMapsUrl">🗺️ Google Maps URL (Easy Option)</label>
                    <input type="url" id="googleMapsUrl" placeholder="Paste Google Maps link here - we'll extract everything automatically!">
                </div>
                <button type="button" id="extractFromUrlBtn" class="btn-extract">Extract Info</button>
            </div>
            <div class="generated-url-display" id="generatedUrlDisplay" style="display: none;">
                <div class="form-group">
                    <label>🔗 Generated Google Maps URL:</label>
                    <div class="url-display-box" id="urlDisplayBox">
                        <a href="#" target="_blank" id="generatedUrlLink">Click to view on Google Maps</a>
                    </div>
                </div>
            </div>
            
            <div class="form-divider">OR paste structured content below:</div>
            
            <div class="structured-content-section">
                <div class="form-group">
                    <label for="structuredContent">📝 Structured Content (Auto-Parse)</label>
                    <textarea id="structuredContent" rows="8" placeholder="🤖 Paste ANY FORMAT - Gemini AI will extract restaurant info!

Examples:
• Simple text: 'Pho 24 restaurant on Hang Bac street, opens 7am-10pm, famous pho bo'
• Review: 'Just ate at Banh Mi Queen, 45 Ma May Street. Amazing sandwiches for 25k VND each!'
• Structured: 'Name: Café Giang, Address: 39 Nguyen Huu Huan, Hours: 6AM-11PM, Specialty: Egg coffee'
• Messy notes: 'went to some noodle place near the lake... think it was called bun cha huong lien??? good food cheap prices maybe 50k for meal'

The AI will automatically extract: Place Name, Address, Hours, Prices, Menu Items, etc."></textarea>
                </div>
                <div class="structured-content-actions">
                    <button type="button" id="parseContentBtn" class="btn-parse">Parse Content</button>
                    <button type="button" id="quickAddBtn" class="btn-quick-add" style="display: none;">Quick Add Recommendation</button>
                </div>
                <div class="parsed-content-preview" id="parsedContentPreview" style="display: none;"></div>
            </div>
            
            <div class="form-divider">OR fill manually below:</div>
            
            <div class="form-row">
                <div class="form-group">
                    <label for="recName">Place Name *</label>
                    <input type="text" id="recName" required placeholder="e.g., Temple of Literature">
                </div>
                <div class="form-group">
                    <label for="recRating">Rating (0-5)</label>
                    <input type="number" id="recRating" min="0" max="5" step="0.1" placeholder="4.5">
                </div>
            </div>
            <div class="form-group">
                <label for="recAddress">Address *</label>
                <input type="text" id="recAddress" required placeholder="e.g., 58 Quoc Tu Giam, Hanoi">
            </div>
            <div class="form-row">
                <div class="form-group">
                    <label for="recLatitude">Latitude *</label>
                    <input type="number" id="recLatitude" step="any" required placeholder="21.0285">
                </div>
                <div class="form-group">
                    <label for="recLongitude">Longitude *</label>
                    <input type="number" id="recLongitude" step="any" required placeholder="105.8355">
                </div>
            </div>
            <div class="form-group">
                <label for="recDescription">Description</label>
                <textarea id="recDescription" rows="3" placeholder="Brief description of this place..."></textarea>
            </div>
            <div class="form-group">
                <label for="recImages">📸 Restaurant & Food Photos</label>
                <div class="image-upload-area" id="imageUploadArea">
                    <div class="image-drop-zone" id="imageDropZone">
                        <div class="drop-zone-content">
                            <span class="drop-zone-icon">📷</span>
                            <p><strong>📋 PASTE RESTAURANT PHOTOS HERE (Ctrl+V)</strong></p>
                            <p>or drag & drop files or click to upload</p>
                            <p class="drop-zone-hint">Supports JPG, PNG, GIF • Max 5MB per image</p>
                            <p class="drop-zone-hint">🍽️ For restaurant interior, food dishes, ambiance photos</p>
                        </div>
                        <input type="file" id="imageFileInput" accept="image/*" multiple style="display: none;">
                    </div>
                    <div class="image-preview-container" id="imagePreviewContainer"></div>
                </div>
            </div>
            
            <div class="form-group">
                <label for="addressExtraction">📍 Address Extraction from Image</label>
                <div class="address-extraction-section">
                    <div class="address-drop-zone" id="addressDropZone">
                        <div class="drop-zone-content">
                            <span class="drop-zone-icon">🔍</span>
                            <p><strong>📋 PASTE ADDRESS IMAGE HERE (Ctrl+V)</strong></p>
                            <p>or drag & drop address image or click to upload</p>
                            <p class="drop-zone-hint">Supports JPG, PNG, GIF • Max 5MB per image</p>
                            <p class="drop-zone-hint">📍 For menu with address, business card, signage, etc.</p>
                        </div>
                        <input type="file" id="addressFileInput" accept="image/*" style="display: none;">
                    </div>
                    <div class="address-preview-container" id="addressPreviewContainer"></div>
                    <div class="extracted-address-display" id="extractedAddressDisplay" style="display: none;">
                        <h4>📍 Extracted Address:</h4>
                        <div class="extracted-address-text" id="extractedAddressText"></div>
                        <button type="button" class="btn-use-address" id="useExtractedAddress">Use This Address</button>
                    </div>
                </div>
            </div>
            <div class="form-row">
                <div class="form-group">
                    <label for="recWebsite">Website URL</label>
                    <input type="url" id="recWebsite" placeholder="https://example.com">
                </div>
                <div class="form-group">
                    <label>
                        <input type="checkbox" id="recFeatured"> Featured Recommendation
                    </label>
                </div>
            </div>
            <div class="form-actions">
                <div class="export-import-actions">
                    <button type="button" class="btn-export" id="exportRecommendation">📤 Export Data</button>
                    <button type="button" class="btn-import" id="importRecommendation">📥 Import Data</button>
                    <input type="file" id="importFileInput" accept=".json" style="display: none;">
                </div>
                <div class="primary-actions">
                    <button type="button" class="btn-secondary" id="cancelAddBtn">Cancel</button>
                    <button type="submit" class="btn-primary">Add Recommendation</button>
                </div>
            </div>
        </form>
    </div>

    <!-- Show Admin Panel Button -->
    <div class="admin-toggle">
        <button class="btn-admin" id="showAdminBtn">⭐ Add Recommendation</button>
    </div>

    <!-- Admin Panel Backdrop -->
    <div class="admin-backdrop" id="adminBackdrop"></div>

    <!-- Image Modal for Place Details -->
    <div class="image-modal" id="imageModal">
        <div class="image-modal-content">
            <div class="image-modal-header">
                <button class="image-modal-back" id="backImageModal">← Back</button>
                <h3 class="image-modal-title" id="modalPlaceName">Place Details</h3>
                <button class="image-modal-close" id="closeImageModal">✕</button>
            </div>
            <div class="image-modal-body" id="modalPlaceDetails">
                <!-- Content will be populated by JavaScript -->
            </div>
        </div>
    </div>

    <!-- Edit Place Modal -->
    <div class="edit-modal" id="editPlaceModal">
        <div class="edit-modal-content">
            <div class="edit-modal-header">
                <h3 class="edit-modal-title">✏️ Edit Place Information</h3>
                <button class="edit-modal-close" id="closeEditModal">✕</button>
            </div>
            <div class="edit-modal-body">
                <!-- Current Place Information Display -->
                <div class="edit-info-display" id="editInfoDisplay">
                    <div class="edit-info-title">📋 Current Place Information</div>
                    <div class="edit-info-content" id="editInfoContent">
                        <!-- Content will be populated by JavaScript -->
                    </div>
                </div>
                
                <!-- Place Name Section -->
                <div class="edit-form-section">
                    <label for="editPlaceName">📍 Place Name:</label>
                    <input type="text" id="editPlaceName" class="edit-input" placeholder="Enter place name...">
                    <button class="auto-parse-btn" id="autoParseBtn" title="Extract dish name using AI">
                        🤖 Auto-Parse with Gemini
                    </button>
                </div>
                
                <!-- Address Section -->
                <div class="edit-form-section">
                    <label for="editPlaceAddress">🏠 Address:</label>
                    <textarea id="editPlaceAddress" class="edit-textarea" placeholder="Enter full address..." rows="2"></textarea>
                </div>
                
                <!-- Opening Hours Section -->
                <div class="edit-form-section">
                    <label for="editOpeningHours">🕒 Opening Hours:</label>
                    <div class="hours-input-container">
                        <div class="hours-quick-options">
                            <button type="button" class="hours-quick-btn" onclick="setQuickHours('24/7')">24/7</button>
                            <button type="button" class="hours-quick-btn" onclick="setQuickHours('9-21')">9 AM - 9 PM</button>
                            <button type="button" class="hours-quick-btn" onclick="setQuickHours('6-22')">6 AM - 10 PM</button>
                            <button type="button" class="hours-quick-btn" onclick="setQuickHours('8-18')">8 AM - 6 PM</button>
                        </div>
                        <textarea id="editOpeningHours" class="edit-textarea" placeholder="e.g. Mon-Sun: 8:00 AM - 9:00 PM or enter custom hours..." rows="3"></textarea>
                    </div>
                </div>
                
                <!-- Quick Examples Section -->
                <div class="edit-form-section">
                    <label>Examples of Vietnamese dishes:</label>
                    <div class="dish-examples">
                        <span class="dish-example" onclick="document.getElementById('editPlaceName').value = this.textContent">Bún Bò Huế</span>
                        <span class="dish-example" onclick="document.getElementById('editPlaceName').value = this.textContent">Phở Gà</span>
                        <span class="dish-example" onclick="document.getElementById('editPlaceName').value = this.textContent">Bánh Canh</span>
                        <span class="dish-example" onclick="document.getElementById('editPlaceName').value = this.textContent">Cơm Tấm</span>
                        <span class="dish-example" onclick="document.getElementById('editPlaceName').value = this.textContent">Gà Luộc Ớt</span>
                    </div>
                </div>
                
                <div class="edit-modal-actions">
                    <button class="cancel-edit-btn" id="cancelEditBtn">Cancel</button>
                    <button class="save-edit-btn" id="saveEditBtn">Save All Changes</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Combined Split-Screen Interface -->
    <div class="split-container">
        <div class="split-header">
            <h3>🎯 Recommendations Overview</h3>
            <p>📋 Details on the left • 🗺️ Map locations on the right</p>
        </div>
        
        <div class="split-content">
            <!-- Left Side: List View with Details -->
            <div class="split-panel list-panel">
                <div class="panel-header">
                    <h4>📋 Place Details</h4>
                    <span class="place-count" id="placeCount">0 places</span>
                </div>
                <div class="loading" id="loadingList">
                    <div style="text-align: center;">
                        <div style="font-size: 1.5rem; margin-bottom: 10px;">🔍</div>
                        <div>Loading places...</div>
                    </div>
                </div>
                
                <!-- Dedicated Search Results Table Section -->
                <div class="search-results-section" id="searchResultsSection" style="display: none;">
                    <div class="search-results-header">
                        <h4>🔮 AI Search Results</h4>
                        <span class="search-results-count" id="searchResultsCount">0 results</span>
                        <button class="btn-view-toggle" id="viewToggleBtn" onclick="toggleSearchResultsView()">
                            📋 Switch to List View
                        </button>
                    </div>
                    <div class="search-results-content">
                        <div class="search-query-info" id="searchQueryInfo">
                            Searching for: <span class="search-query-text"></span>
                        </div>
                        <div class="search-results-table" id="searchResultsTable">
                            <!-- Table content will be populated by JavaScript -->
                        </div>
                    </div>
                </div>
                
                <div class="places-list" id="placesList">
                    <div class="no-places-message">
                        Select categories and click "Load" to see recommendations
                    </div>
                </div>
            </div>
            
            <!-- Right Side: Map View -->
            <div class="split-panel map-panel">
                <div class="panel-header">
                    <h4>🗺️ Map Overview</h4>
                    <span class="map-info" id="mapInfo">Visual distance reference</span>
                </div>
                <div class="loading" id="loadingMap">
                    <div style="text-align: center;">
                        <div style="font-size: 1.5rem; margin-bottom: 10px;">🔍</div>
                        <div>Loading places on map...</div>
                    </div>
                </div>
                <div class="map-container-split">
                    <div id="map"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let map;
        let hotelMarker;
        let placeMarkers = [];
        let allPlaces = {};
        let originalPlacesBackup = {}; // Global backup for search restore functionality
        let activeCategories = new Set(['recommend']); // Start with recommend category selected by default to show user's stored restaurants
        let currentInfoWindow = null; // Track currently open info window
        let currentRadius = 2000; // Track current search radius (default to 2km for better coverage)
        let placeMarkerMap = new Map(); // Map place IDs to markers for cross-tab interaction

        // Hotel location
        const HOTEL_LOCATION = {
            lat: 21.034087,
            lng: 105.85114,
            name: "Old Quarter Hotel",
            address: "118 Hang Bac, Hoan Kiem, Hanoi, Vietnam"
        };

        // Category colors
        const CATEGORY_COLORS = {
            recommend: '#FFD700',
            restaurants: '#FF6B35',
            landmarks: '#4CAF50', 
            coffee: '#795548',
            culture: '#9C27B0'
        };

        // Category icons
        const CATEGORY_ICONS = {
            recommend: '⭐',
            restaurants: '🍽️',
            landmarks: '🏛️',
            coffee: '☕',
            culture: '🎭'
        };

        // Initialize map (internal function)
        function initializeGoogleMap() {
            console.log('initMap called');
            if (map) {
                console.log('Map already exists, skipping initialization');
                return;
            }

            // Hide loading indicator
            const loadingIndicator = document.getElementById('loadingIndicator');
            if (loadingIndicator) {
                loadingIndicator.style.display = 'none';
                console.log('✅ Loading indicator hidden');
            }
            
            map = new google.maps.Map(document.getElementById('map'), {
                center: HOTEL_LOCATION,
                zoom: 14, // Slightly wider view to show more context
                styles: [
                    {
                        featureType: "poi",
                        elementType: "labels", 
                        stylers: [{ visibility: "off" }]
                    }
                ],
                mapTypeControl: true,
                mapTypeControlOptions: {
                    style: google.maps.MapTypeControlStyle.HORIZONTAL_BAR,
                    position: google.maps.ControlPosition.TOP_CENTER
                },
                zoomControl: true,
                zoomControlOptions: {
                    position: google.maps.ControlPosition.RIGHT_BOTTOM
                },
                streetViewControl: false,
                fullscreenControl: false
            });

            // Add map click listener to reset selection when clicking on empty areas
            map.addListener('click', (event) => {
                // Only reset if not clicking on a marker
                console.log('Map clicked, resetting selection');
                resetMarkerHighlighting();
                
                // Remove selection arrow
                if (selectionArrow) {
                    selectionArrow.setMap(null);
                    selectionArrow = null;
                }
            });

            // Add hotel marker
            addHotelMarker();

            // Set up event listeners  
            setupEventListeners();
            
            // If there was a pending map update, do it now
            if (window.retryMapUpdate) {
                console.log('Retrying map update now that Google Maps is loaded...');
                window.retryMapUpdate = false;
                updateMapMarkers();
            }
        }

        function addHotelMarker() {
            hotelMarker = new google.maps.Marker({
                position: HOTEL_LOCATION,
                map: map,
                title: HOTEL_LOCATION.name,
                icon: {
                    url: 'data:image/svg+xml;charset=UTF-8,' + encodeURIComponent(`
                        <svg width="60" height="75" viewBox="0 0 60 75" xmlns="http://www.w3.org/2000/svg">
                            <defs>
                                <filter id="hotel-shadow" x="-50%" y="-50%" width="200%" height="200%">
                                    <feGaussianBlur in="SourceAlpha" stdDeviation="3"/>
                                    <feOffset dx="0" dy="3" result="offset"/>
                                    <feComponentTransfer>
                                        <feFuncA type="linear" slope="0.4"/>
                                    </feComponentTransfer>
                                    <feMerge> 
                                        <feMergeNode/>
                                        <feMergeNode in="SourceGraphic"/>
                                    </feMerge>
                                </filter>
                            </defs>
                            <!-- Main hotel icon -->
                            <circle cx="30" cy="30" r="26" fill="#FF1744" stroke="white" stroke-width="5" filter="url(#hotel-shadow)"/>
                            <circle cx="30" cy="30" r="18" fill="#D32F2F" stroke="white" stroke-width="2"/>
                            <text x="30" y="38" text-anchor="middle" fill="white" font-size="24" font-weight="bold">🏨</text>
                            <!-- Hotel label moved further down and with background -->
                            <rect x="15" y="60" width="30" height="12" fill="white" stroke="#FF1744" stroke-width="1" rx="6" filter="url(#hotel-shadow)"/>
                            <text x="30" y="68" text-anchor="middle" fill="#FF1744" font-size="7" font-weight="bold">YOUR HOTEL</text>
                        </svg>
                    `),
                    scaledSize: new google.maps.Size(60, 75),
                    anchor: new google.maps.Point(30, 30)
                }
            });

            const hotelInfoWindow = new google.maps.InfoWindow({
                content: `
                    <div class="marker-info">
                        <h3>🏨 ${HOTEL_LOCATION.name}</h3>
                        <p><strong>Your Hotel Location</strong></p>
                        <p>📍 ${HOTEL_LOCATION.address}</p>
                        <p>🎯 All places are shown relative to this location</p>
                    </div>
                `
            });

            hotelMarker.addListener('click', () => {
                // Close any currently open info window
                if (currentInfoWindow) {
                    currentInfoWindow.close();
                }
                // Open this info window and track it
                hotelInfoWindow.open(map, hotelMarker);
                currentInfoWindow = hotelInfoWindow;
            });
        }

        let eventListenersSetup = false;
        
        function setupEventListeners() {
            if (eventListenersSetup) {
                console.log('Event listeners already set up, skipping');
                return;
            }
            
            console.log('Setting up event listeners');
            eventListenersSetup = true;
            
            // Category filter selection (single selection only)
            document.querySelectorAll('.category-filter').forEach(filter => {
                filter.addEventListener('click', () => {
                    const category = filter.dataset.category;
                    console.log('Category clicked:', category);
                    
                    // Single selection: deactivate all categories first
                    document.querySelectorAll('.category-filter').forEach(f => {
                        f.classList.remove('active');
                    });
                    activeCategories.clear();
                    
                    // Activate the clicked category
                    activeCategories.add(category);
                    filter.classList.add('active');
                    console.log('Selected single category:', category);
                    
                    console.log('Active categories:', Array.from(activeCategories));
                    
                    // Update displays
                    // updateLoadButtonText(); // Removed since no load button
                    updateSelectedCategoriesDisplay();
                    
                    // Only update map if we already have data loaded
                    if (Object.keys(allPlaces).length > 0) {
                        updateMapMarkers();
                        updateStats();
                    }
                });
            });

            // Auto-load places on page load
            // loadPlaces functionality will be called automatically

            // Hotel location update button
            document.getElementById('updateLocationBtn').addEventListener('click', updateHotelLocation);
            
            // GPS location button
            document.getElementById('useGpsBtn').addEventListener('click', useGPSLocation);
            
            // Clear places button
            document.getElementById('clearPlacesBtn').addEventListener('click', clearAllPlaces);

            // Radius change
            document.getElementById('radiusSelect').addEventListener('change', () => {
                if (Object.keys(allPlaces).length > 0 && activeCategories.size > 0) {
                    loadPlaces(); // Reload with new radius
                }
            });

            // Admin panel
            setupAdminPanel();
            
            // Image modal
            setupImageModal();
        }
        
        function setupImageModal() {
            const modal = document.getElementById('imageModal');
            const closeBtn = document.getElementById('closeImageModal');
            const backBtn = document.getElementById('backImageModal');
            
            // Close modal when clicking/touching close button (improved mobile support)
            closeBtn.addEventListener('click', hideImageModal);
            closeBtn.addEventListener('touchend', (e) => {
                e.preventDefault();
                hideImageModal();
            });
            
            // Back button functionality (same as close)
            backBtn.addEventListener('click', hideImageModal);
            backBtn.addEventListener('touchend', (e) => {
                e.preventDefault();
                hideImageModal();
            });
            
            // Close modal when clicking outside the content
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    hideImageModal();
                }
            });
            
            // Close modal when touching outside the content (mobile)
            modal.addEventListener('touchend', (e) => {
                if (e.target === modal) {
                    e.preventDefault();
                    hideImageModal();
                }
            });
            
            // Close modal with Escape key
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && modal.classList.contains('show')) {
                    hideImageModal();
                }
            });
        }

        function updatePlacesList() {
            console.log('🔄 updatePlacesList called - delegating to updatePlacesListWithSearch');
            updatePlacesListWithSearch();
        }

        function createPlaceListItem(place, index) {
            const item = document.createElement('div');
            item.className = 'place-item';
            item.dataset.placeId = place.id;
            item.dataset.category = place.category;
            
            // Get category icon and color
            const categoryIcon = CATEGORY_ICONS[place.category] || '📍';
            const categoryColor = CATEGORY_COLORS[place.category] || '#1976D2';
            
            // Convert distance to miles (1 meter = 0.000621371 miles)
            const distanceInMiles = (place.distance * 0.000621371).toFixed(2);
            
            // Generate compact opening hours display for list view
            const compactHours = getCompactOpeningHours(place);
            
            // Create image element with fallback
            let imageElement;
            
            // Default images based on category - using URL encoding instead of btoa to avoid emoji issues
            const defaultImages = {
                recommend: 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(`
                    <svg width="70" height="70" viewBox="0 0 70 70" xmlns="http://www.w3.org/2000/svg">
                        <defs>
                            <linearGradient id="starGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                                <stop offset="0%" style="stop-color:#FFD700;stop-opacity:1" />
                                <stop offset="100%" style="stop-color:#FFA500;stop-opacity:1" />
                            </linearGradient>
                        </defs>
                        <rect width="70" height="70" fill="url(#starGrad)" rx="6"/>
                        <circle cx="35" cy="35" r="12" fill="white"/>
                        <polygon points="35,25 37,31 43,31 38,35 40,41 35,37 30,41 32,35 27,31 33,31" fill="#FFD700"/>
                    </svg>
                `),
                restaurants: 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(`
                    <svg width="70" height="70" viewBox="0 0 70 70" xmlns="http://www.w3.org/2000/svg">
                        <defs>
                            <linearGradient id="foodGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                                <stop offset="0%" style="stop-color:#FF6B35;stop-opacity:1" />
                                <stop offset="100%" style="stop-color:#F7931E;stop-opacity:1" />
                            </linearGradient>
                        </defs>
                        <rect width="70" height="70" fill="url(#foodGrad)" rx="6"/>
                        <circle cx="35" cy="35" r="12" fill="white"/>
                        <circle cx="35" cy="30" r="6" fill="#FF6B35"/>
                        <rect x="32" y="36" width="6" height="8" fill="#FF6B35"/>
                    </svg>
                `),
                landmarks: 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(`
                    <svg width="70" height="70" viewBox="0 0 70 70" xmlns="http://www.w3.org/2000/svg">
                        <defs>
                            <linearGradient id="landmarkGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                                <stop offset="0%" style="stop-color:#4CAF50;stop-opacity:1" />
                                <stop offset="100%" style="stop-color:#66BB6A;stop-opacity:1" />
                            </linearGradient>
                        </defs>
                        <rect width="70" height="70" fill="url(#landmarkGrad)" rx="6"/>
                        <circle cx="35" cy="35" r="12" fill="white"/>
                        <rect x="28" y="40" width="14" height="8" fill="#4CAF50"/>
                        <polygon points="28,40 35,28 42,40" fill="#4CAF50"/>
                    </svg>
                `),
                coffee: 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(`
                    <svg width="70" height="70" viewBox="0 0 70 70" xmlns="http://www.w3.org/2000/svg">
                        <defs>
                            <linearGradient id="coffeeGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                                <stop offset="0%" style="stop-color:#795548;stop-opacity:1" />
                                <stop offset="100%" style="stop-color:#A1887F;stop-opacity:1" />
                            </linearGradient>
                        </defs>
                        <rect width="70" height="70" fill="url(#coffeeGrad)" rx="6"/>
                        <circle cx="35" cy="35" r="12" fill="white"/>
                        <ellipse cx="35" cy="35" rx="8" ry="10" fill="#795548"/>
                        <ellipse cx="35" cy="32" rx="6" ry="3" fill="#A1887F"/>
                    </svg>
                `),
                culture: 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(`
                    <svg width="70" height="70" viewBox="0 0 70 70" xmlns="http://www.w3.org/2000/svg">
                        <defs>
                            <linearGradient id="cultureGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                                <stop offset="0%" style="stop-color:#9C27B0;stop-opacity:1" />
                                <stop offset="100%" style="stop-color:#BA68C8;stop-opacity:1" />
                            </linearGradient>
                        </defs>
                        <rect width="70" height="70" fill="url(#cultureGrad)" rx="6"/>
                        <circle cx="35" cy="35" r="12" fill="white"/>
                        <path d="M28,35 Q35,25 42,35 Q35,45 28,35" fill="#9C27B0"/>
                    </svg>
                `)
            };
            
            // Check for uploaded images first (custom images take priority)
            if (place.images && place.images.length > 0) {
                // Use uploaded image (base64 data URL)
                const uploadedImage = place.images[0];
                console.log(`📸 Place ${place.name} has uploaded image`);
                
                imageElement = `<img class="place-image" src="${uploadedImage.dataUrl}" alt="${place.name}" style="display: block;">`;
            } else if (place.photos && place.photos.length > 0) {
                // Validate photo reference
                const photo = place.photos[0];
                const hasValidPhoto = photo && photo.name && photo.name.trim().length > 0 && 
                                    !photo.name.includes('undefined') && !photo.name.includes('null');
                
                if (hasValidPhoto) {
                    console.log(`✅ Place ${place.name} has valid photo:`, photo.name.substring(0, 50) + '...');
                    
                    // Encode the photo name properly to handle special characters
                    const encodedPhotoName = encodeURIComponent(photo.name);
                    const photoUrl = `/api/place-photo/${encodedPhotoName}?maxHeightPx=140&maxWidthPx=140`;
                    const fallbackImage = defaultImages[place.category] || defaultImages.recommend;
                    
                    imageElement = `
                        <img class="place-image" 
                             src="${fallbackImage}" 
                             data-real-src="${photoUrl}"
                             alt="${place.name}" 
                             loading="lazy" 
                             onload="console.log('✅ Image loaded for ${place.name}'); this.style.display='block';"
                             onerror="console.log('❌ Photo failed for ${place.name}, using fallback'); this.src='${fallbackImage}'; this.style.display='block';">`;
                    
                    // Try to load the real photo after a short delay
                    setTimeout(() => {
                        const img = document.querySelector(`img[data-real-src="${photoUrl}"]`);
                        if (img && img.dataset.realSrc) {
                            const testImg = new Image();
                            testImg.onload = () => {
                                console.log(`🖼️ Real photo verified for ${place.name}, switching...`);
                                img.src = photoUrl;
                            };
                            testImg.onerror = () => {
                                console.log(`❌ Real photo failed for ${place.name}, keeping fallback`);
                                // Keep fallback image
                            };
                            testImg.src = photoUrl;
                        }
                    }, 500);
                } else {
                    console.log(`❌ Place ${place.name} has invalid photo data, using category image`);
                    const fallbackImage = defaultImages[place.category] || defaultImages.recommend;
                    imageElement = `<img class="place-image" src="${fallbackImage}" alt="${place.name}" style="display: block;">`;
                }
            } else {
                console.log(`ℹ️ Place ${place.name} has no photos, using category image for: ${place.category}`);
                const fallbackImage = defaultImages[place.category] || defaultImages.recommend;
                imageElement = `<img class="place-image" src="${fallbackImage}" alt="${place.name}" style="display: block;">`;
            }
            
            console.log(`Final imageElement HTML for ${place.name}:`, imageElement);
            
            // Test to ensure the image container exists
            console.log(`Setting innerHTML for place item ${place.name}`);
            
            // Add delete button only for recommendations
            const deleteButtonHtml = place.category === 'recommend' ? `
                <button class="delete-recommendation-btn" onclick="deleteRecommendation('${place.id}', event)" title="Delete this recommendation">
                    🗑️
                </button>
            ` : '';

            item.innerHTML = `
                ${imageElement}
                <div class="place-details">
                    <div class="place-name">${place.name}</div>
                    <div class="place-address">📍 ${place.address}</div>
                    ${getOpeningHoursDisplay(place)}
                    <div class="place-meta">
                        ${place.rating > 0 ? `<span class="place-rating">⭐ ${place.rating.toFixed(1)} (${place.userRatingCount})</span>` : ''}
                        <span class="place-distance">🚶 ${place.distance}m<span class="distance-conversion">(${distanceInMiles} mi)</span></span>
                        <span class="place-category" style="background-color: ${categoryColor}20; color: ${categoryColor};">
                            ${categoryIcon} ${place.category}
                        </span>
                    </div>
                </div>
                <div class="place-actions">
                    <button class="edit-place-btn" onclick="event.stopPropagation(); showEditPlaceModal('${place.id}')" title="Edit place information">
                        ✏️ Edit
                    </button>
                    <button class="view-details-btn" onclick="event.stopPropagation(); showPlaceDetails(${JSON.stringify(place).replace(/"/g, '&quot;')})" title="View detailed information">
                        👁️ Details
                    </button>
                </div>
                ${deleteButtonHtml}
            `;
            
            // Debug: Check if the image was actually added to the DOM
            setTimeout(() => {
                const addedImage = item.querySelector('.place-image');
                if (addedImage) {
                    console.log(`✅ Image element found for ${place.name}:`, addedImage.src);
                    console.log(`Image dimensions:`, addedImage.offsetWidth, 'x', addedImage.offsetHeight);
                    console.log(`Image style:`, addedImage.style.cssText);
                } else {
                    console.error(`❌ No image element found for ${place.name}!`);
                    console.log(`Item HTML:`, item.innerHTML);
                }
            }, 100);
            
            // Add click/touch handler for smart zoom (no details modal)
            const handlePlaceSelect = (e) => {
                // Prevent event if clicking on delete button, view details button, or edit button
                if (e.target.closest('.delete-recommendation-btn') || e.target.closest('.view-details-btn') || e.target.closest('.edit-place-btn')) {
                    return;
                }
                console.log(`🔍 Place clicked: ${place.name} (ID: ${place.id})`);
                console.log(`🎯 Triggering zoom for place at distance: ${place.distance}m`);
                // Only trigger smart zoom, not details modal
                highlightPlaceOnMap(place.id);
            };
            
            item.addEventListener('click', handlePlaceSelect);
            item.addEventListener('touchend', (e) => {
                e.preventDefault();
                handlePlaceSelect(e);
            });
            
            return item;
        }

        async function fetchManualRecommendations() {
            try {
                console.log('🔍 Fetching manual recommendations from API...');
                console.log('🌍 Hotel location:', HOTEL_LOCATION);
                
                const response = await fetch(`/api/recommendations?latitude=${HOTEL_LOCATION.lat}&longitude=${HOTEL_LOCATION.lng}`);
                
                if (!response.ok) {
                    throw new Error(`Failed to fetch recommendations: ${response.status}`);
                }
                
                const data = await response.json();
                console.log('📊 Manual recommendations response:', data);
                console.log('📈 Total recommendations from API:', data.recommendations?.length || 0);
                
                if (data.success && data.recommendations) {
                    // Store recommendations in allPlaces under 'recommend' category
                    if (!allPlaces.recommend) {
                        allPlaces.recommend = [];
                        console.log('📂 Created new recommend category in allPlaces');
                    }
                    
                    const beforeCount = allPlaces.recommend.length;
                    
                    // Merge with existing recommendations (avoid duplicates)
                    const existingIds = new Set(allPlaces.recommend.map(place => place.id));
                    const newRecommendations = data.recommendations.filter(rec => !existingIds.has(rec.id));
                    
                    console.log('🔄 Filtering: existing =', existingIds.size, 'new =', newRecommendations.length);
                    
                    allPlaces.recommend.push(...newRecommendations);
                    
                    // Sort by distance
                    allPlaces.recommend.sort((a, b) => a.distance - b.distance);
                    
                    console.log(`✅ Added ${newRecommendations.length} new manual recommendations`);
                    console.log(`📊 Total recommendations: ${beforeCount} → ${allPlaces.recommend.length}`);
                    console.log('📍 All recommendations:', allPlaces.recommend.map(r => ({ id: r.id, name: r.name, distance: r.distance })));
                    console.log(`🎯 Current radius: ${currentRadius}m`);
                    
                    // Check if any recommendations are beyond current radius
                    const beyondRadius = allPlaces.recommend.filter(r => r.distance > currentRadius);
                    if (beyondRadius.length > 0) {
                        console.log(`⚠️ ${beyondRadius.length} recommendations are beyond current radius (${currentRadius}m):`, 
                                   beyondRadius.map(r => ({ name: r.name, distance: r.distance })));
                    }
                } else {
                    console.warn('⚠️ No recommendations received from API');
                }
            } catch (error) {
                console.error('❌ Error fetching manual recommendations:', error);
                // Don't show alert for recommendations - it's not critical
            }
        }

        function setupAdminPanel() {
            console.log('Setting up admin panel...');
            
            const showAdminBtn = document.getElementById('showAdminBtn');
            const adminPanel = document.getElementById('adminPanel');
            const adminBackdrop = document.getElementById('adminBackdrop');
            const closeAdminBtn = document.getElementById('closeAdminBtn');
            const cancelAddBtn = document.getElementById('cancelAddBtn');
            const addRecommendationForm = document.getElementById('addRecommendationForm');
            
            // Show admin panel
            showAdminBtn.addEventListener('click', () => {
                adminPanel.style.display = 'block';
                adminBackdrop.classList.add('show');
                document.body.style.overflow = 'hidden';
            });
            
            // Hide admin panel
            function hideAdminPanel() {
                adminPanel.style.display = 'none';
                adminBackdrop.classList.remove('show');
                document.body.style.overflow = 'auto';
                addRecommendationForm.reset();
                clearImagePreviews();
            }
            
            closeAdminBtn.addEventListener('click', hideAdminPanel);
            cancelAddBtn.addEventListener('click', hideAdminPanel);
            adminBackdrop.addEventListener('click', hideAdminPanel);
            
            // Handle form submission
            addRecommendationForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                await addNewRecommendation();
            });
            
            // Handle Google Maps URL extraction
            document.getElementById('extractFromUrlBtn').addEventListener('click', extractFromGoogleMapsUrl);
        }

        async function extractFromGoogleMapsUrl() {
            const urlInput = document.getElementById('googleMapsUrl');
            const url = urlInput.value.trim();
            
            if (!url) {
                alert('Please paste a Google Maps URL first');
                return;
            }
            
            console.log('Extracting from URL:', url);
            
            // Disable button during processing
            const extractBtn = document.getElementById('extractFromUrlBtn');
            extractBtn.disabled = true;
            extractBtn.textContent = 'Processing...';
            
            try {
                let workingUrl = url;
                
                // If it's a shortened URL, resolve it first
                if (url.includes('goo.gl') || url.includes('maps.app.goo.gl')) {
                    console.log('Detected shortened URL, resolving...');
                    
                    const resolveResponse = await fetch('/api/resolve-maps-url', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ url: url })
                    });
                    
                    if (resolveResponse.ok) {
                        const resolveData = await resolveResponse.json();
                        if (resolveData.success) {
                            workingUrl = resolveData.resolvedUrl;
                            console.log('Resolved to:', workingUrl);
                        } else {
                            throw new Error('Could not resolve shortened URL');
                        }
                    } else {
                        throw new Error('Failed to resolve shortened URL');
                    }
                }
                
                // Now extract from the resolved URL
                await extractCoordinatesFromUrl(workingUrl);
                
            } catch (error) {
                console.error('Error processing URL:', error);
                alert('❌ Error processing URL: ' + error.message);
            } finally {
                // Re-enable button
                extractBtn.disabled = false;
                extractBtn.textContent = 'Extract Info';
            }
        }

        async function extractCoordinatesFromUrl(url) {
            console.log('Extracting coordinates from:', url);
            
            // Parse different Google Maps URL formats
            let coordinates = null;
            let placeName = '';
            
            // Format 1: https://maps.google.com/maps?q=21.0285,105.8355
            // Format 2: https://www.google.com/maps/@21.0285,105.8355,15z
            // Format 3: https://www.google.com/maps/place/Temple+of+Literature/@21.0285,105.8355,17z
            // Format 4: https://www.google.com/maps/place/Temple+of+Literature/data=...!3d21.0285!4d105.8355
            
            // Try to extract coordinates from various URL patterns
            const patterns = [
                // @lat,lng,zoom pattern
                /@(-?\d+\.?\d*),(-?\d+\.?\d*),/,
                // q=lat,lng pattern  
                /[?&]q=(-?\d+\.?\d*),(-?\d+\.?\d*)/,
                // /maps/@lat,lng pattern
                /\/maps\/@(-?\d+\.?\d*),(-?\d+\.?\d*)/,
                // place coordinates
                /place\/[^\/]+\/@(-?\d+\.?\d*),(-?\d+\.?\d*)/,
                // data format !3d(lat)!4d(lng)
                /!3d(-?\d+\.?\d*)!4d(-?\d+\.?\d*)/
            ];
            
            for (const pattern of patterns) {
                const match = url.match(pattern);
                if (match) {
                    coordinates = {
                        latitude: parseFloat(match[1]),
                        longitude: parseFloat(match[2])
                    };
                    console.log('Found coordinates:', coordinates);
                    break;
                }
            }
            
            // Extract place name from URL
            const placeMatch = url.match(/\/place\/([^\/]+)/);
            if (placeMatch) {
                placeName = decodeURIComponent(placeMatch[1].replace(/\+/g, ' '));
                console.log('Found place name:', placeName);
            }
            
            if (coordinates) {
                // Validate coordinates
                if (coordinates.latitude >= -90 && coordinates.latitude <= 90 && 
                    coordinates.longitude >= -180 && coordinates.longitude <= 180) {
                    
                    // Auto-fill the form
                    document.getElementById('recLatitude').value = coordinates.latitude;
                    document.getElementById('recLongitude').value = coordinates.longitude;
                    
                    if (placeName) {
                        document.getElementById('recName').value = placeName;
                    }
                    
                    // Try to get more info using Google Geocoding API
                    geocodeCoordinates(coordinates.latitude, coordinates.longitude);
                    
                    alert('✅ Coordinates extracted successfully! Check the form fields.');
                    
                    // Clear the URL field
                    document.getElementById('googleMapsUrl').value = '';
                    
                } else {
                    throw new Error('Invalid coordinates found');
                }
            } else {
                throw new Error('Could not extract coordinates from this URL. Please try:\n\n1. Share from Google Maps app\n2. Copy the URL from maps.google.com\n3. Make sure the URL contains location coordinates');
            }
        }

        async function geocodeCoordinates(lat, lng) {
            try {
                console.log(`Geocoding coordinates: ${lat}, ${lng}`);
                
                const response = await fetch('/api/geocode-coordinates', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        latitude: lat,
                        longitude: lng
                    })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    if (data.success && data.address) {
                        document.getElementById('recAddress').value = data.address;
                        console.log('Auto-filled address:', data.address);
                    }
                }
            } catch (error) {
                console.warn('Could not auto-fill address:', error);
                // Not critical - user can fill manually
            }
        }

        let isSubmitting = false; // Global flag to prevent duplicate submissions
        
        // Image compression utility for faster uploads
        function compressImage(dataUrl, quality = 0.7) {
            return new Promise((resolve) => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const img = new Image();
                
                img.onload = function() {
                    // Calculate new dimensions (max 800px width/height)
                    let { width, height } = this;
                    const maxSize = 800;
                    
                    if (width > maxSize || height > maxSize) {
                        if (width > height) {
                            height = (height * maxSize) / width;
                            width = maxSize;
                        } else {
                            width = (width * maxSize) / height;
                            height = maxSize;
                        }
                    }
                    
                    canvas.width = width;
                    canvas.height = height;
                    
                    // Draw and compress
                    ctx.drawImage(this, 0, 0, width, height);
                    const compressedDataUrl = canvas.toDataURL('image/jpeg', quality);
                    resolve(compressedDataUrl);
                };
                
                img.src = dataUrl;
            });
        }
        
        async function addNewRecommendation() {
            // Prevent duplicate submissions
            if (isSubmitting) {
                console.log('⚠️ Submission already in progress, ignoring duplicate request');
                return;
            }
            
            const form = document.getElementById('addRecommendationForm');
            const submitBtn = form.querySelector('button[type="submit"]');
            const formData = new FormData(form);
            
            // Set submission state with visual feedback
            isSubmitting = true;
            submitBtn.disabled = true;
            submitBtn.innerHTML = '<span style="display: inline-block; animation: spin 1s linear infinite;">⏳</span> Adding...';
            
            // Add spinner animation if not already defined
            if (!document.querySelector('#spinner-style')) {
                const style = document.createElement('style');
                style.id = 'spinner-style';
                style.textContent = `
                    @keyframes spin {
                        0% { transform: rotate(0deg); }
                        100% { transform: rotate(360deg); }
                    }
                `;
                document.head.appendChild(style);
            }
            
            try {
                // Optimize images for faster upload
                const optimizedImages = [];
                if (uploadedImages.length > 0) {
                    submitBtn.innerHTML = '<span style="display: inline-block; animation: spin 1s linear infinite;">⏳</span> Optimizing images...';
                    
                    for (let i = 0; i < uploadedImages.length; i++) { // Keep all uploaded images
                        const img = uploadedImages[i];
                        try {
                            // Compress image if too large
                            let dataUrl = img.dataUrl;
                            if (dataUrl.length > 500000) { // 500KB limit
                                console.log(`Compressing large image: ${img.name}`);
                                dataUrl = await compressImage(dataUrl, 0.7); // 70% quality
                            }
                            optimizedImages.push({
                                id: img.id,
                                name: img.name,
                                dataUrl: dataUrl
                            });
                            console.log(`✅ Processed image ${i + 1}/${uploadedImages.length}: ${img.name}`);
                        } catch (error) {
                            console.error('Error optimizing image:', img.name, error);
                            // Use original image if compression fails
                            optimizedImages.push({
                                id: img.id,
                                name: img.name,
                                dataUrl: img.dataUrl
                            });
                            console.log(`⚠️ Used original image ${i + 1}/${uploadedImages.length}: ${img.name}`);
                        }
                    }
                }
                
                submitBtn.innerHTML = '<span style="display: inline-block; animation: spin 1s linear infinite;">⏳</span> Creating recommendation...';
                
                const recommendation = {
                    name: document.getElementById('recName').value.trim(),
                    address: document.getElementById('recAddress').value.trim(),
                    latitude: parseFloat(document.getElementById('recLatitude').value),
                    longitude: parseFloat(document.getElementById('recLongitude').value),
                    rating: parseFloat(document.getElementById('recRating').value) || 0,
                    description: document.getElementById('recDescription').value.trim(),
                    websiteUri: document.getElementById('recWebsite').value.trim(),
                    featured: document.getElementById('recFeatured').checked,
                    images: optimizedImages
                };
                
                // Validation
                if (!recommendation.name || !recommendation.address || !recommendation.latitude || !recommendation.longitude) {
                    alert('Please fill in all required fields (Name, Address, Latitude, Longitude)');
                    return;
                }
                
                if (isNaN(recommendation.latitude) || isNaN(recommendation.longitude)) {
                    alert('Please enter valid coordinates');
                    return;
                }
                
                console.log('Adding new recommendation:', recommendation);
                console.log(`📸 Total images being sent: ${optimizedImages.length}`);
                
                const response = await fetch('/api/recommendations', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(recommendation)
                });
                
                const result = await response.json();
                
                if (response.ok && result.success) {
                    alert(`✅ Successfully added: ${recommendation.name}`);
                    
                    // Add to local data and refresh display
                    if (!allPlaces.recommend) {
                        allPlaces.recommend = [];
                    }
                    
                    // Calculate distance from hotel
                    const distance = Math.round(calculateDistance(
                        HOTEL_LOCATION.lat, HOTEL_LOCATION.lng,
                        recommendation.latitude, recommendation.longitude
                    ));
                    
                    const newRec = {
                        ...result.recommendation,
                        distance: distance
                    };
                    
                    allPlaces.recommend.push(newRec);
                    allPlaces.recommend.sort((a, b) => a.distance - b.distance);
                    
                    // Update displays
                    updateMapMarkers();
                    updateStats();
                    updatePlacesList();
                    
                    // Hide admin panel
                    document.getElementById('adminPanel').style.display = 'none';
                    document.getElementById('adminBackdrop').classList.remove('show');
                    document.body.style.overflow = 'auto';
                    form.reset();
                    clearImagePreviews();
                    
                    console.log(`Added recommendation: ${newRec.name} at ${distance}m from hotel`);
                } else {
                    alert(`❌ Failed to add recommendation: ${result.error || 'Unknown error'}`);
                }
            } catch (error) {
                console.error('Error adding recommendation:', error);
                alert('❌ Network error. Please try again.');
            } finally {
                // Reset submission state
                isSubmitting = false;
                submitBtn.disabled = false;
                submitBtn.innerHTML = 'Add Recommendation';
            }
        }

        // Utility function to calculate distance (if not already defined)
        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 6371e3; // Earth's radius in meters
            const φ1 = lat1 * Math.PI / 180;
            const φ2 = lat2 * Math.PI / 180;
            const Δφ = (lat2 - lat1) * Math.PI / 180;
            const Δλ = (lon2 - lon1) * Math.PI / 180;

            const a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +
                Math.cos(φ1) * Math.cos(φ2) *
                Math.sin(Δλ / 2) * Math.sin(Δλ / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

            return R * c; // Distance in meters
        }

        function highlightPlaceOnMap(placeId) {
            console.log(`🎯 Smart zoom to place: ${placeId}`);
            
            // Find the marker for this place
            const marker = placeMarkerMap.get(placeId);
            if (!marker) {
                console.warn(`Marker not found for place ID: ${placeId}`);
                return;
            }

            // Find the place data for distance info (check both search results and normal places)
            let selectedPlace = null;
            
            // First check if we're in search mode
            if (currentSearchFilter && currentSearchFilter.filteredPlaces) {
                console.log('🔍 Searching in filtered places for ID:', placeId);
                Object.values(currentSearchFilter.filteredPlaces).forEach(categoryPlaces => {
                    if (categoryPlaces && Array.isArray(categoryPlaces)) {
                        const found = categoryPlaces.find(place => place.id === placeId);
                        if (found) {
                            selectedPlace = found;
                            console.log('✅ Found place in search results:', selectedPlace.name);
                        }
                    }
                });
            }
            
            // If not found in search results, check normal places
            if (!selectedPlace) {
                console.log('🔍 Searching in normal places for ID:', placeId);
                Object.values(allPlaces).forEach(categoryPlaces => {
                    if (categoryPlaces && Array.isArray(categoryPlaces)) {
                        const found = categoryPlaces.find(place => place.id === placeId);
                        if (found) {
                            selectedPlace = found;
                            console.log('✅ Found place in normal places:', selectedPlace.name);
                        }
                    }
                });
            }
            
            // Close any currently open info window - NO POPUPS for overview
            if (currentInfoWindow) {
                currentInfoWindow.close();
                currentInfoWindow = null;
            }

            // Smart zoom to show hotel-to-place relationship
            zoomToShowHotelAndPlace(marker.getPosition(), selectedPlace);
            
            // Clear any previous selection highlighting
            resetAllMarkerHighlights();
            
            // Highlight the selected location with a large visible red dot (more prominent)
            const highlightIcon = {
                url: 'data:image/svg+xml;charset=UTF-8,' + encodeURIComponent(`
                    <svg width="50" height="50" viewBox="0 0 50 50" xmlns="http://www.w3.org/2000/svg">
                        <!-- Large outer pulsing ring -->
                        <circle cx="25" cy="25" r="20" fill="none" stroke="#EA4335" stroke-width="3" opacity="0.5">
                            <animate attributeName="r" values="20;30;20" dur="2s" repeatCount="indefinite"/>
                            <animate attributeName="opacity" values="0.5;0.1;0.5" dur="2s" repeatCount="indefinite"/>
                        </circle>
                        <!-- Medium pulsing ring -->
                        <circle cx="25" cy="25" r="15" fill="none" stroke="#EA4335" stroke-width="2" opacity="0.7">
                            <animate attributeName="r" values="15;22;15" dur="1.5s" repeatCount="indefinite"/>
                            <animate attributeName="opacity" values="0.7;0.2;0.7" dur="1.5s" repeatCount="indefinite"/>
                        </circle>
                        <!-- Large selected location dot (red) -->
                        <circle cx="25" cy="25" r="12" fill="#EA4335" stroke="white" stroke-width="2"/>
                        <circle cx="25" cy="25" r="6" fill="white"/>
                        <circle cx="25" cy="25" r="3" fill="#EA4335"/>
                    </svg>
                `),
                scaledSize: new google.maps.Size(50, 50),
                anchor: new google.maps.Point(25, 25),
                zIndex: 1000
            };
            
            marker.setIcon(highlightIcon);
            
            // Store the selected marker for later cleanup
            window.selectedLocationMarker = marker;
        }

        function resetAllMarkerHighlights() {
            // Reset all place markers to their original icons
            placeMarkerMap.forEach((marker, placeId) => {
                // Find original place data to recreate the correct icon
                let originalPlace = null;
                let originalCategory = null;
                
                Object.entries(allPlaces).forEach(([category, places]) => {
                    const place = places.find(p => p.id === placeId);
                    if (place) {
                        originalPlace = place;
                        originalCategory = category;
                    }
                });
                
                if (originalPlace && originalCategory) {
                    // Recreate original marker icon using existing logic
                    const color = CATEGORY_COLORS[originalCategory];
                    const icon = CATEGORY_ICONS[originalCategory];
                    
                    const originalIcon = {
                        url: 'data:image/svg+xml;charset=UTF-8,' + encodeURIComponent(`
                            <svg width="40" height="50" viewBox="0 0 40 50" xmlns="http://www.w3.org/2000/svg">
                                <defs>
                                    <filter id="marker-shadow-${originalCategory}" x="-50%" y="-50%" width="200%" height="200%">
                                        <feGaussianBlur in="SourceAlpha" stdDeviation="2"/>
                                        <feOffset dx="0" dy="2" result="offset"/>
                                        <feFlood flood-color="#000000" flood-opacity="0.3"/>
                                        <feComposite in2="offset" operator="in"/>
                                        <feMerge>
                                            <feMergeNode/>
                                            <feMergeNode in="SourceGraphic"/>
                                        </feMerge>
                                    </filter>
                                </defs>
                                <!-- Drop pin shape -->
                                <path d="M20 5 C12 5, 6 11, 6 19 C6 27, 20 45, 20 45 C20 45, 34 27, 34 19 C34 11, 28 5, 20 5 Z" 
                                      fill="${color}" 
                                      stroke="white" 
                                      stroke-width="3" 
                                      filter="url(#marker-shadow-${originalCategory})"/>
                                <!-- Inner circle -->
                                <circle cx="20" cy="19" r="10" fill="white"/>
                                <!-- Category icon -->
                                <text x="20" y="25" text-anchor="middle" fill="${color}" font-size="16" font-weight="bold">${icon}</text>
                            </svg>
                        `),
                        scaledSize: new google.maps.Size(40, 50),
                        anchor: new google.maps.Point(20, 45)
                    };
                    
                    marker.setIcon(originalIcon);
                    marker.setZIndex(500); // Normal z-index
                }
            });
        }

        function highlightPlaceInList(placeId) {
            console.log(`Highlighting place in list: ${placeId}`);
            
            // Remove any existing highlights
            document.querySelectorAll('.place-item.highlighted').forEach(item => {
                item.classList.remove('highlighted');
            });
            
            // Find and highlight the place item
            const placeItem = document.querySelector(`[data-place-id="${placeId}"]`);
            if (placeItem) {
                placeItem.classList.add('highlighted');
                
                // Scroll to the highlighted item if it's not visible
                placeItem.scrollIntoView({
                    behavior: 'smooth',
                    block: 'center'
                });
                
                // Remove highlight after 3 seconds
                setTimeout(() => {
                    placeItem.classList.remove('highlighted');
                }, 3000);
            } else {
                console.warn(`Place item not found for ID: ${placeId}`);
            }
        }

        // Professional smart zoom function to show hotel-to-place relationship
        function zoomToShowHotelAndPlace(placePosition, selectedPlace) {
            console.log('🔍 zoomToShowHotelAndPlace CALLED!');
            console.log('📍 Place position:', placePosition.lat(), placePosition.lng());
            console.log('🏨 Hotel marker exists:', !!hotelMarker);
            console.log('🗺️ Map exists:', !!map);
            console.log('📏 Distance:', selectedPlace?.distance);
            
            if (!map || !hotelMarker) {
                console.warn('❌ Map or hotel marker not available - ABORTING ZOOM');
                return;
            }

            const hotelPosition = hotelMarker.getPosition();
            const distance = selectedPlace ? selectedPlace.distance : null;

            // Create expanded bounds to force wider view
            const bounds = new google.maps.LatLngBounds();
            
            // Calculate the center point between hotel and place
            const centerLat = (hotelPosition.lat() + placePosition.lat()) / 2;
            const centerLng = (hotelPosition.lng() + placePosition.lng()) / 2;
            
            // Calculate distance between points to determine expansion
            const latDiff = Math.abs(hotelPosition.lat() - placePosition.lat());
            const lngDiff = Math.abs(hotelPosition.lng() - placePosition.lng());
            
            // Clean overview showing both locations like Google Maps
            // Ensure both points are visible with some padding
            const minLatDiff = 0.003; // Minimum coverage to ensure both dots visible
            const minLngDiff = 0.003; // Minimum coverage to ensure both dots visible
            
            // Simple expansion to show both locations clearly
            const expandedLatDiff = Math.max(latDiff * 1.8, minLatDiff); // 1.8x expansion 
            const expandedLngDiff = Math.max(lngDiff * 1.8, minLngDiff); // 1.8x expansion
            
            console.log(`📐 Original lat/lng diff: ${latDiff.toFixed(6)}, ${lngDiff.toFixed(6)}`);
            console.log(`📏 FORCED expanded lat/lng diff: ${expandedLatDiff.toFixed(6)}, ${expandedLngDiff.toFixed(6)}`);
            console.log(`🎯 Map will show area from (${(centerLat - expandedLatDiff).toFixed(6)}, ${(centerLng - expandedLngDiff).toFixed(6)}) to (${(centerLat + expandedLatDiff).toFixed(6)}, ${(centerLng + expandedLngDiff).toFixed(6)})`);
            
            // Create bounds with guaranteed large area
            bounds.extend(new google.maps.LatLng(
                centerLat - expandedLatDiff,
                centerLng - expandedLngDiff
            ));
            bounds.extend(new google.maps.LatLng(
                centerLat + expandedLatDiff,
                centerLng + expandedLngDiff
            ));
            
            // Also include the original points to ensure they're visible
            bounds.extend(hotelPosition);
            bounds.extend(placePosition);

            // Apply bounds with minimal padding for clean overview
            console.log('🗺️ Applying fitBounds for clean two-location overview...');
            map.fitBounds(bounds, { top: 50, bottom: 50, left: 50, right: 50 });
            
            // Google Maps style zoom level management
            setTimeout(() => {
                const currentZoom = map.getZoom();
                let targetZoom = currentZoom;
                
                // Adjust zoom based on distance for Google Maps style overview
                if (distance) {
                    if (distance < 300) {
                        targetZoom = Math.min(currentZoom, 16); // Close - detailed street view
                    } else if (distance < 1000) {
                        targetZoom = Math.min(currentZoom, 15); // Medium - neighborhood view
                    } else if (distance < 2000) {
                        targetZoom = Math.min(currentZoom, 14); // Far - district view
                    } else {
                        targetZoom = Math.min(currentZoom, 13); // Very far - city view
                    }
                } else {
                    targetZoom = Math.min(currentZoom, 15); // Default overview
                }
                
                console.log(`🔍 Distance: ${distance}m, Current zoom: ${currentZoom}, Target zoom: ${targetZoom}`);
                
                if (currentZoom !== targetZoom) {
                    console.log(`🎯 Adjusting zoom from ${currentZoom} to ${targetZoom} for optimal overview`);
                    map.setZoom(targetZoom);
                }
                
                // Verify both markers are visible
                setTimeout(() => {
                    const mapBounds = map.getBounds();
                    const hotelVisible = mapBounds.contains(hotelPosition);
                    const placeVisible = mapBounds.contains(placePosition);
                    console.log(`👀 Final check - Hotel visible: ${hotelVisible}, Place visible: ${placeVisible}`);
                }, 100);
            }, 200);

            // NO distance visualization - just clean dots like Google Maps

            // Log zoom details for user understanding
            setTimeout(() => {
                const zoom = map.getZoom();
                const center = map.getCenter();
                console.log(`📍 Zoom complete: Level ${zoom.toFixed(1)} | Distance: ${distance}m | Center: ${center.lat().toFixed(6)}, ${center.lng().toFixed(6)}`);
                
                if (selectedPlace) {
                    console.log(`🚶 Walking distance: ~${Math.ceil(distance / 80)} minutes | 🗺️ ${(distance * 0.000621371).toFixed(2)} miles`);
                }
            }, 1000);
        }

        // Visual distance indicator between hotel and place
        function showDistanceVisualization(hotelPos, placePos, distance) {
            // Remove existing line if any
            if (window.distanceLine) {
                window.distanceLine.setMap(null);
            }

            // Create a subtle dashed line showing the connection
            window.distanceLine = new google.maps.Polyline({
                path: [hotelPos, placePos],
                geodesic: true,
                strokeColor: '#2196F3',
                strokeOpacity: 0.6,
                strokeWeight: 3,
                icons: [{
                    icon: {
                        path: 'M 0,-1 0,1',
                        strokeOpacity: 1,
                        scale: 2
                    },
                    offset: '0',
                    repeat: '12px'
                }],
                map: map
            });

            // Remove the line after 8 seconds
            setTimeout(() => {
                if (window.distanceLine) {
                    window.distanceLine.setMap(null);
                    window.distanceLine = null;
                }
            }, 8000);

            // Add distance label at midpoint
            if (distance > 200) {
                // Calculate midpoint (with fallback if geometry library not loaded)
                let midpoint;
                try {
                    midpoint = google.maps.geometry.spherical.interpolate(hotelPos, placePos, 0.5);
                } catch (error) {
                    // Fallback: simple average of coordinates
                    midpoint = new google.maps.LatLng(
                        (hotelPos.lat() + placePos.lat()) / 2,
                        (hotelPos.lng() + placePos.lng()) / 2
                    );
                }
                
                const walkingTime = Math.ceil(distance / 80); // ~80m per minute walking
                const distanceText = distance < 1000 ? `${distance}m` : `${(distance/1000).toFixed(1)}km`;
                
                const distanceLabel = new google.maps.InfoWindow({
                    content: `
                        <div style="text-align: center; padding: 8px; font-family: -apple-system, BlinkMacSystemFont, sans-serif;">
                            <div style="font-weight: bold; color: #2196F3; font-size: 14px;">🚶 ${distanceText}</div>
                            <div style="font-size: 12px; color: #666; margin-top: 2px;">~${walkingTime} min walk</div>
                        </div>
                    `,
                    position: midpoint,
                    disableAutoPan: true
                });

                distanceLabel.open(map);
                
                // Remove label after 6 seconds
                setTimeout(() => {
                    distanceLabel.close();
                }, 6000);
            }
        }

        // Debounce mechanism to prevent rapid API calls
        let lastLoadTime = 0;
        const LOAD_COOLDOWN = 3000; // 3 seconds between loads

        async function loadPlaces() {
            console.log('Auto-loading places! Current activeCategories:', Array.from(activeCategories), 'Size:', activeCategories.size);
            
            // Prevent rapid successive calls
            const now = Date.now();
            if (now - lastLoadTime < LOAD_COOLDOWN) {
                console.log('⏳ Load request too frequent, waiting for cooldown...');
                return;
            }
            lastLoadTime = now;
            
            // Auto-select recommend category if no categories are selected
            if (activeCategories.size === 0) {
                console.log('No categories selected, auto-selecting recommend category');
                activeCategories.add('recommend');
                
                // Update UI to show recommend category as selected
                document.querySelectorAll('.category-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                const recommendBtn = document.querySelector('.category-btn[data-category="recommend"]');
                if (recommendBtn) {
                    recommendBtn.classList.add('active');
                }
                updateSelectedCategoriesDisplay();
            }
            
            console.log('Categories selected, proceeding with load...');

            const radius = parseInt(document.getElementById('radiusSelect').value);
            const previousRadius = currentRadius;
            currentRadius = radius;
            
            console.log(`Radius change: ${previousRadius}m → ${radius}m`);
            
            const loadingMap = document.getElementById('loadingMap');
            const loadingList = document.getElementById('loadingList');
            
            // Show loading indicators on both tabs
            if (loadingMap) loadingMap.classList.add('show');
            if (loadingList) loadingList.classList.add('show');

            try {
                // Handle radius changes intelligently
                if (radius < previousRadius && Object.keys(allPlaces).length > 0) {
                    console.log('Smaller radius: filtering existing places without API call');
                    // For smaller radius, just filter existing places (no API call needed)
                    // BUT preserve manual recommendations regardless of distance
                    Object.keys(allPlaces).forEach(category => {
                        if (allPlaces[category]) {
                            if (category === 'recommend') {
                                // Keep all manual recommendations regardless of distance
                                console.log(`Preserving all ${allPlaces[category].length} manual recommendations (no distance filtering)`);
                            } else {
                                // Apply distance filtering to other categories
                                const beforeFilter = allPlaces[category].length;
                                allPlaces[category] = allPlaces[category].filter(place => place.distance <= radius);
                                console.log(`${category}: ${beforeFilter} → ${allPlaces[category].length} places (distance filtered)`);
                            }
                        }
                    });
                    
                    console.log('Places filtered for smaller radius:', allPlaces);
                    updateMapMarkers();
                    updateStats();
                    adjustMapBounds();
                } else {
                    console.log('Larger radius or first load: fetching from API');
                    
                    // Check if we need to fetch manual recommendations
                    if (activeCategories.has('recommend')) {
                        console.log('Fetching manual recommendations...');
                        await fetchManualRecommendations();
                    }
                    
                    // For larger radius or first load, fetch from API
                    const response = await fetch('/api/search-nearby', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            latitude: HOTEL_LOCATION.lat,
                            longitude: HOTEL_LOCATION.lng,
                            radius: radius
                        })
                    });

                    console.log('Response status:', response.status);

                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({}));
                        console.error('API Error Response:', errorData);
                        throw new Error(errorData.message || `Server error: ${response.status}`);
                    }

                    const data = await response.json();
                    console.log('API response:', data);
                    
                    // Enhanced error handling with debug info
                    if (data.debug) {
                        console.log('🔍 Debug info from server:', data.debug);
                        if (data.debug.totalPlacesFound === 0) {
                            console.warn('⚠️ Server returned 0 places despite successful API call');
                            console.warn('🔑 API Key present on server:', data.debug.apiKeyPresent);
                        }
                    }
                    
                    if (data.success && data.results) {
                        console.log('Merging new places with existing');
                        // Merge new places with existing ones
                        Object.entries(data.results).forEach(([category, newPlaces]) => {
                            if (!allPlaces[category]) {
                                allPlaces[category] = [];
                            }
                            
                            // Combine existing and new places
                            const existingPlaces = allPlaces[category];
                            const combinedPlaces = [...existingPlaces, ...newPlaces];
                            
                            // Remove duplicates based on place ID and keep closest ones
                            const uniquePlaces = new Map();
                            combinedPlaces.forEach(place => {
                                const existing = uniquePlaces.get(place.id);
                                if (!existing || place.distance < existing.distance) {
                                    uniquePlaces.set(place.id, place);
                                }
                            });
                            
                            // Sort by distance and keep reasonable number of places
                            allPlaces[category] = Array.from(uniquePlaces.values())
                                .sort((a, b) => a.distance - b.distance)
                                .slice(0, 50); // Keep max 50 places per category for better coverage
                        });
                        
                        console.log('Places merged and updated:', allPlaces);
                        updateMapMarkers();
                        updateStats();
                        adjustMapBounds();
                    } else {
                        console.error('API returned no results:', data);
                        
                        // Enhanced no results message with debug info
                        let errorMessage = 'No places found. ';
                        if (data.debug && !data.debug.apiKeyPresent) {
                            errorMessage += 'API configuration issue detected. ';
                        } else if (data.debug && data.debug.totalPlacesFound === 0) {
                            errorMessage += 'Google Places API returned empty results. ';
                        }
                        errorMessage += 'Try expanding your search radius or selecting different categories.';
                        
                        // Check if API returned error or empty results
                        if (data.error) {
                            console.error('API Error:', data.error);
                            alert(`API Error: ${data.error}\n\nPlease check:\n- Google Maps API key is valid\n- Places API (New) is enabled\n- Billing is set up in Google Cloud\n- API quotas not exceeded`);
                            return;
                        }
                        
                        alert(errorMessage);
                    }
                }

            } catch (error) {
                console.error('Error loading places:', error);
                
                // Enhanced error message based on error type
                let errorMessage = 'Failed to load places. ';
                if (error.message.includes('API key')) {
                    errorMessage += 'API configuration issue. Please check server logs.';
                } else if (error.message.includes('network') || error.message.includes('fetch')) {
                    errorMessage += 'Network connection issue. Please check your internet connection.';
                } else if (error.message.includes('Server error: 403')) {
                    errorMessage += 'API permissions issue. Check Google Cloud Console.';
                } else if (error.message.includes('Server error: 429')) {
                    errorMessage += 'API quota exceeded. Please try again later.';
                } else {
                    errorMessage += 'Please try again or contact support if the issue persists.';
                }
                
                alert(errorMessage);
            } finally {                
                // Hide loading indicators on both tabs
                if (loadingMap) loadingMap.classList.remove('show');
                if (loadingList) loadingList.classList.remove('show');
            }
        }

        function updateMapMarkers() {
            // Check if Google Maps is available and map is initialized
            if (typeof google === 'undefined' || !map) {
                console.log('Google Maps not ready yet, skipping marker update');
                // Just update the places list for now
                updatePlacesList();
                return;
            }

            // Clear existing markers
            placeMarkers.forEach(marker => marker.setMap(null));
            placeMarkers = [];
            placeMarkerMap.clear();
            
            // Reset any selection when updating markers
            resetMarkerHighlighting();
            if (selectionArrow) {
                selectionArrow.setMap(null);
                selectionArrow = null;
            }

            // Add markers for active categories (search results or normal)
            if (currentSearchFilter) {
                // Use filtered search results
                activeCategories.forEach(category => {
                    if (currentSearchFilter.filteredPlaces[category]) {
                        currentSearchFilter.filteredPlaces[category].forEach(place => {
                            addPlaceMarker(place, category);
                        });
                    }
                });
            } else {
                // Use normal places
                Object.entries(allPlaces).forEach(([category, places]) => {
                    if (!activeCategories.has(category)) return;

                    places.forEach(place => {
                        addPlaceMarker(place, category);
                    });
                });
            }
            
            // Always update places list in split-screen view
            updatePlacesList();
        }

        function addPlaceMarker(place, category) {
            // Safety check for place data
            if (!place || !place.location || typeof place.location.latitude !== 'number' || typeof place.location.longitude !== 'number') {
                console.error('❌ Invalid place data for marker:', place);
                return null;
            }
            
            const color = CATEGORY_COLORS[category];
            const icon = CATEGORY_ICONS[category];

            const marker = new google.maps.Marker({
                position: {
                    lat: place.location.latitude,
                    lng: place.location.longitude
                },
                map: map,
                title: place.name,
                icon: {
                    url: 'data:image/svg+xml;charset=UTF-8,' + encodeURIComponent(`
                        <svg width="40" height="50" viewBox="0 0 40 50" xmlns="http://www.w3.org/2000/svg">
                            <defs>
                                <filter id="marker-shadow-${category}" x="-50%" y="-50%" width="200%" height="200%">
                                    <feGaussianBlur in="SourceAlpha" stdDeviation="2"/>
                                    <feOffset dx="0" dy="2" result="offset"/>
                                    <feFlood flood-color="#000000" flood-opacity="0.3"/>
                                    <feComposite in2="offset" operator="in"/>
                                    <feMerge>
                                        <feMergeNode/>
                                        <feMergeNode in="SourceGraphic"/>
                                    </feMerge>
                                </filter>
                            </defs>
                            <!-- Drop pin shape -->
                            <path d="M20 5 C12 5, 6 11, 6 19 C6 27, 20 45, 20 45 C20 45, 34 27, 34 19 C34 11, 28 5, 20 5 Z" 
                                  fill="${color}" 
                                  stroke="white" 
                                  stroke-width="3" 
                                  filter="url(#marker-shadow-${category})"/>
                            <!-- Inner circle -->
                            <circle cx="20" cy="19" r="10" fill="white"/>
                            <!-- Category icon -->
                            <text x="20" y="25" text-anchor="middle" fill="${color}" font-size="16" font-weight="bold">${icon}</text>
                        </svg>
                    `),
                    scaledSize: new google.maps.Size(40, 50),
                    anchor: new google.maps.Point(20, 45)
                }
            });

            const infoWindow = new google.maps.InfoWindow({
                content: `
                    <div class="marker-info" style="max-width: 180px; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;">
                        <h3 style="margin: 0 0 6px 0; font-size: 0.95rem; color: #333; line-height: 1.2;">${icon} ${place.name}</h3>
                        <p style="margin: 2px 0; color: #1976D2; font-weight: bold; font-size: 0.8rem;">🚶 ${place.distance}m away</p>
                        ${place.rating > 0 ? `<p style="margin: 2px 0; color: #ff9800; font-weight: bold; font-size: 0.8rem;">⭐ ${place.rating.toFixed(1)}</p>` : ''}
                        <button onclick="openDirections(${place.location.latitude}, ${place.location.longitude}, '${place.name}')" 
                                style="background: #1976D2; color: white; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 0.8rem; font-weight: bold; margin-top: 6px; width: 100%;">
                            🗺️ Directions
                        </button>
                    </div>
                `
            });

            marker.addListener('click', () => {
                // Highlight this place on map (adds selection marker and effects)
                highlightPlaceOnMap(place.id);
                
                // Highlight corresponding place in list view
                highlightPlaceInList(place.id);
                
                // Show place details in modal
                showPlaceDetails(Object.assign(place, { category }));
            });

            // Store the info window reference on the marker for cross-tab interaction
            marker.infoWindow = infoWindow;
            
            // Store marker in the map for cross-tab interaction
            placeMarkerMap.set(place.id, marker);
            
            placeMarkers.push(marker);
        }

        function updateStats() {
            // Only count places from active categories
            const activePlacesList = [];
            
            Object.entries(allPlaces).forEach(([category, places]) => {
                if (activeCategories.has(category)) {
                    activePlacesList.push(...places);
                }
            });
            
            const totalPlaces = activePlacesList.length;
            
            const avgRating = totalPlaces > 0 
                ? (activePlacesList.reduce((sum, place) => sum + (place.rating || 0), 0) / totalPlaces).toFixed(1)
                : '0.0';
                
            const maxDistance = totalPlaces > 0 
                ? Math.max(...activePlacesList.map(place => place.distance))
                : 0;
                
            const categoryCounts = Object.entries(allPlaces)
                .filter(([cat]) => activeCategories.has(cat))
                .map(([cat, places]) => ({
                    category: cat,
                    count: places.length
                }))
                .sort((a, b) => b.count - a.count);
            
            const topCategory = categoryCounts[0]?.category || '-';

            document.getElementById('totalPlaces').textContent = totalPlaces;
            document.getElementById('avgRating').textContent = avgRating;
            document.getElementById('maxDistance').textContent = maxDistance + 'm';
            document.getElementById('topCategory').textContent = CATEGORY_ICONS[topCategory] || '-';
        }

        function clearAllPlaces() {
            console.log('Clearing all places');
            
            // Clear all markers from map
            placeMarkers.forEach(marker => marker.setMap(null));
            placeMarkers = [];
            placeMarkerMap.clear();
            
            // Clear places data
            allPlaces = {};
            
            // Close any open info window
            if (currentInfoWindow) {
                currentInfoWindow.close();
                currentInfoWindow = null;
            }
            
            // Update stats and displays
            updateStats();
            
            // Update places list
            updatePlacesList();
            
            console.log('All places cleared');
        }

        function updateLoadButtonText() {
            const loadBtn = document.getElementById('loadPlacesBtn');
            if (!loadBtn) {
                console.log('Load button not found yet');
                return;
            }
            
            const selectedCount = activeCategories.size;
            console.log('Updating button text, selected count:', selectedCount);
            
            if (selectedCount === 0) {
                loadBtn.textContent = '🗺️ Select Categories First';
                loadBtn.style.background = '#ccc';
                loadBtn.style.cursor = 'not-allowed';
                console.log('Button updated: No categories');
            } else {
                const categories = Array.from(activeCategories).map(cat => CATEGORY_ICONS[cat]).join('');
                loadBtn.textContent = `🗺️ Load ${categories} (${selectedCount} categories)`;
                loadBtn.style.background = 'linear-gradient(135deg, #4caf50 0%, #66bb6a 100%)';
                loadBtn.style.cursor = 'pointer';
                console.log('Button updated:', loadBtn.textContent, 'Background:', loadBtn.style.background);
            }
        }

        function updateSelectedCategoriesDisplay() {
            const display = document.getElementById('selectedCategoriesDisplay');
            if (!display) return;
            
            if (activeCategories.size === 0) {
                display.textContent = 'No categories selected';
                display.style.color = '#666';
            } else {
                const categoryNames = Array.from(activeCategories).map(cat => {
                    const icon = CATEGORY_ICONS[cat];
                    const name = cat.charAt(0).toUpperCase() + cat.slice(1);
                    return `${icon} ${name}`;
                }).join(', ');
                display.textContent = `Selected: ${categoryNames}`;
                display.style.color = '#1976D2';
            }
        }

        function adjustMapBounds() {
            if (placeMarkers.length === 0) {
                // If no markers, show wider area around hotel
                map.setCenter(HOTEL_LOCATION);
                map.setZoom(13);
                return;
            }

            const bounds = new google.maps.LatLngBounds();
            
            // Always include hotel location
            bounds.extend(HOTEL_LOCATION);
            
            // Add all place markers
            placeMarkers.forEach(marker => {
                bounds.extend(marker.getPosition());
            });

            // Add some padding to show context around the area
            const padding = {
                top: 50,
                right: 50,
                bottom: 50,
                left: 50
            };

            map.fitBounds(bounds, padding);
            
            // Ensure minimum and maximum zoom levels for better overview
            const listener = google.maps.event.addListener(map, "idle", () => {
                const currentZoom = map.getZoom();
                if (currentZoom > 16) {
                    map.setZoom(16); // Don't zoom in too much
                } else if (currentZoom < 12) {
                    map.setZoom(12); // Don't zoom out too much
                }
                google.maps.event.removeListener(listener);
            });
        }

        // Global variable to store current selection arrow
        let selectionArrow = null;
        
        // Cross-tab interaction functions - REMOVED DUPLICATE FUNCTION
        // The real highlightPlaceOnMap function is above (line 3298) and calls our overview zoom
        
        // Global variable to track currently selected place
        let currentlySelectedPlaceId = null;
        
        function dimOtherMarkers(selectedPlaceId) {
            console.log('Dimming other markers, highlighting:', selectedPlaceId);
            currentlySelectedPlaceId = selectedPlaceId;
            
            // Iterate through all markers
            placeMarkerMap.forEach((marker, placeId) => {
                const originalIcon = marker.getIcon();
                
                if (placeId === selectedPlaceId) {
                    // Highlight selected marker - make it more prominent
                    const highlightedIcon = {
                        ...originalIcon,
                        scaledSize: new google.maps.Size(50, 62), // Slightly larger
                        anchor: new google.maps.Point(25, 56)
                    };
                    marker.setIcon(highlightedIcon);
                    marker.setZIndex(2000); // Bring to front
                } else {
                    // Dim other markers - make them semi-transparent
                    const dimmedIcon = {
                        ...originalIcon,
                        url: originalIcon.url.replace(/opacity="1"/g, 'opacity="0.4"')
                                          .replace(/opacity: 1/g, 'opacity: 0.4')
                                          .replace(/fill-opacity="1"/g, 'fill-opacity="0.4"')
                                          .replace(/<svg/, '<svg style="opacity: 0.4"'),
                        scaledSize: new google.maps.Size(32, 40), // Slightly smaller
                        anchor: new google.maps.Point(16, 36)
                    };
                    marker.setIcon(dimmedIcon);
                    marker.setZIndex(100); // Send to back
                }
            });
        }
        
        function resetMarkerHighlighting() {
            console.log('Resetting all marker highlighting');
            currentlySelectedPlaceId = null;
            
            // Reset all markers to normal appearance
            placeMarkerMap.forEach((marker, placeId) => {
                // Find the original place data to recreate the correct icon
                let originalCategory = null;
                let originalPlace = null;
                
                Object.entries(allPlaces).forEach(([category, places]) => {
                    const place = places.find(p => p.id === placeId);
                    if (place) {
                        originalCategory = category;
                        originalPlace = place;
                    }
                });
                
                if (originalCategory && originalPlace) {
                    // Recreate the original icon
                    const color = CATEGORY_COLORS[originalCategory];
                    const icon = CATEGORY_ICONS[originalCategory];
                    
                    const originalIcon = {
                        url: 'data:image/svg+xml;charset=UTF-8,' + encodeURIComponent(`
                            <svg width="40" height="50" viewBox="0 0 40 50" xmlns="http://www.w3.org/2000/svg">
                                <defs>
                                    <filter id="marker-shadow-${originalCategory}" x="-50%" y="-50%" width="200%" height="200%">
                                        <feGaussianBlur in="SourceAlpha" stdDeviation="2"/>
                                        <feOffset dx="0" dy="2" result="offset"/>
                                        <feFlood flood-color="#000000" flood-opacity="0.3"/>
                                        <feComposite in2="offset" operator="in"/>
                                        <feMerge>
                                            <feMergeNode/>
                                            <feMergeNode in="SourceGraphic"/>
                                        </feMerge>
                                    </filter>
                                </defs>
                                <path d="M20 5 C12 5, 6 11, 6 19 C6 27, 20 45, 20 45 C20 45, 34 27, 34 19 C34 11, 28 5, 20 5 Z" 
                                      fill="${color}" 
                                      stroke="white" 
                                      stroke-width="3" 
                                      filter="url(#marker-shadow-${originalCategory})"/>
                                <circle cx="20" cy="19" r="10" fill="white"/>
                                <text x="20" y="25" text-anchor="middle" fill="${color}" font-size="16" font-weight="bold">${icon}</text>
                            </svg>
                        `),
                        scaledSize: new google.maps.Size(40, 50),
                        anchor: new google.maps.Point(20, 45)
                    };
                    
                    marker.setIcon(originalIcon);
                    marker.setZIndex(500); // Normal z-index
                }
            });
        }
        
        function highlightPlaceInList(placeId) {
            console.log('Highlighting place in list:', placeId);
            
            // Remove previous highlights
            document.querySelectorAll('.place-item.highlighted').forEach(item => {
                item.classList.remove('highlighted');
            });
            
            // Find and highlight the corresponding list item
            const listItem = document.querySelector(`.place-item[data-place-id="${placeId}"]`);
            if (listItem) {
                listItem.classList.add('highlighted');
                
                // Scroll the list to show this item
                listItem.scrollIntoView({
                    behavior: 'smooth',
                    block: 'center',
                    inline: 'nearest'
                });
                
                // Remove highlight after 3 seconds
                setTimeout(() => {
                    listItem.classList.remove('highlighted');
                }, 3000);
            } else {
                console.log('No list item found for place:', placeId);
            }
        }

        // Opening Hours Utility Functions
        function getCompactOpeningHours(place) {
            let hoursText = '';
            
            // Try to get opening hours from various sources
            let openingHours = place.openingHours || place.currentOpeningHours || place.regularOpeningHours;
            
            if (openingHours) {
                if (typeof openingHours === 'string') {
                    hoursText = openingHours;
                } else if (openingHours.weekdayDescriptions && openingHours.weekdayDescriptions.length > 0) {
                    // Get today's hours if available
                    const today = new Date().getDay(); // 0 = Sunday, 1 = Monday, etc.
                    const todayHours = openingHours.weekdayDescriptions[today];
                    
                    if (todayHours) {
                        // Extract just the time part from "Monday: 9:00 AM – 9:00 PM"
                        const timeMatch = todayHours.match(/:\s*(.+)$/);
                        hoursText = timeMatch ? timeMatch[1] : todayHours;
                    } else {
                        // Fallback to first available hours
                        const firstHours = openingHours.weekdayDescriptions[0];
                        const timeMatch = firstHours.match(/:\s*(.+)$/);
                        hoursText = timeMatch ? timeMatch[1] : firstHours.substring(0, 30) + '...';
                    }
                } else if (Array.isArray(openingHours)) {
                    hoursText = openingHours[0] || '';
                }
            }
            
            // If no hours found, return empty string (will be handled in display)
            if (!hoursText.trim()) {
                return '';
            }
            
            // Truncate if too long for list view
            if (hoursText.length > 25) {
                hoursText = hoursText.substring(0, 22) + '...';
            }
            
            return hoursText;
        }
        
        // Enhanced function to show opening hours or fallback message
        function getOpeningHoursDisplay(place) {
            const compactHours = getCompactOpeningHours(place);
            
            if (compactHours) {
                return `<div class="place-hours">🕒 ${compactHours}</div>`;
            } else if (place.category === 'recommend') {
                // For user recommendations, show a more gentle message
                return `<div class="place-hours-placeholder">🕒 Hours not available</div>`;
            } else {
                // For Google Places, suggest checking their website
                return `<div class="place-hours-placeholder">🕒 See details for hours</div>`;
            }
        }

        // Professional Place Details Modal Functions
        function generateOpeningHoursHtml(place) {
            // Check if place has opening hours data
            if (!place.currentOpeningHours && !place.regularOpeningHours && !place.openingHours) {
                return `
                    <div class="opening-hours-section">
                        <div class="opening-hours-title">🕒 Opening Hours</div>
                        <div class="opening-hours-unavailable">
                            <span>⚠️ Opening hours not available</span>
                            <small>Please call or visit their website for current hours</small>
                        </div>
                    </div>
                `;
            }

            // Try to get opening hours from different possible fields
            let openingHours = place.currentOpeningHours || place.regularOpeningHours || place.openingHours;
            
            // If opening hours is an object with weekdayDescriptions, use that
            if (openingHours && openingHours.weekdayDescriptions) {
                const today = new Date().getDay(); // 0 = Sunday, 1 = Monday, etc.
                const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
                
                let hoursHtml = '';
                openingHours.weekdayDescriptions.forEach((dayHours, index) => {
                    const isToday = index === today;
                    const dayClass = isToday ? 'today' : '';
                    const todayIndicator = isToday ? ' 📍' : '';
                    
                    hoursHtml += `
                        <div class="hours-day ${dayClass}">
                            <span class="day-name">${days[index]}${todayIndicator}</span>
                            <span class="day-hours">${dayHours}</span>
                        </div>
                    `;
                });

                return `
                    <div class="opening-hours-section">
                        <div class="opening-hours-title">🕒 Opening Hours</div>
                        <div class="opening-hours-list">
                            ${hoursHtml}
                        </div>
                    </div>
                `;
            }
            
            // If opening hours is a simple array of strings
            if (Array.isArray(openingHours)) {
                const hoursHtml = openingHours.map(hours => `
                    <div class="hours-day">
                        <span class="day-hours">${hours}</span>
                    </div>
                `).join('');

                return `
                    <div class="opening-hours-section">
                        <div class="opening-hours-title">🕒 Opening Hours</div>
                        <div class="opening-hours-list">
                            ${hoursHtml}
                        </div>
                    </div>
                `;
            }

            // If it's just a string
            if (typeof openingHours === 'string') {
                return `
                    <div class="opening-hours-section">
                        <div class="opening-hours-title">🕒 Opening Hours</div>
                        <div class="opening-hours-simple">
                            ${openingHours}
                        </div>
                    </div>
                `;
            }

            // Fallback if no recognizable format
            return `
                <div class="opening-hours-section">
                    <div class="opening-hours-title">🕒 Opening Hours</div>
                    <div class="opening-hours-unavailable">
                        <span>⚠️ Opening hours format not recognized</span>
                        <small>Please call or visit their website for current hours</small>
                    </div>
                </div>
            `;
        }

        function showPlaceDetails(place) {
            console.log('Showing place details for:', place.name);
            
            const modal = document.getElementById('imageModal');
            const modalTitle = document.getElementById('modalPlaceName');
            const modalBody = document.getElementById('modalPlaceDetails');
            
            // Convert distance to miles
            const distanceInMiles = (place.distance * 0.000621371).toFixed(2);
            
            // Get category details
            const categoryIcon = CATEGORY_ICONS[place.category] || '📍';
            const categoryColor = CATEGORY_COLORS[place.category] || '#1976D2';
            
            // Set modal title with professional formatting
            modalTitle.innerHTML = `${categoryIcon} ${place.name}`;
            
            // Define default images for modal (same as in createPlaceListItem)
            const defaultImages = {
                recommend: 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(`
                    <svg width="200" height="200" viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg">
                        <defs>
                            <linearGradient id="starGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                                <stop offset="0%" style="stop-color:#FFD700;stop-opacity:1" />
                                <stop offset="100%" style="stop-color:#FFA500;stop-opacity:1" />
                            </linearGradient>
                        </defs>
                        <rect width="200" height="200" fill="url(#starGrad)" rx="15"/>
                        <circle cx="100" cy="100" r="40" fill="white"/>
                        <polygon points="100,70 110,90 130,90 115,105 120,125 100,115 80,125 85,105 70,90 90,90" fill="#FFD700"/>
                    </svg>
                `),
                restaurants: 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(`
                    <svg width="200" height="200" viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg">
                        <rect width="200" height="200" fill="#FF6B35" rx="15"/>
                        <circle cx="100" cy="100" r="40" fill="white"/>
                        <circle cx="100" cy="85" r="20" fill="#FF6B35"/>
                        <rect x="85" y="105" width="30" height="25" fill="#FF6B35"/>
                    </svg>
                `),
                landmarks: 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(`
                    <svg width="200" height="200" viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg">
                        <rect width="200" height="200" fill="#4CAF50" rx="15"/>
                        <circle cx="100" cy="100" r="40" fill="white"/>
                        <rect x="70" y="115" width="60" height="25" fill="#4CAF50"/>
                        <polygon points="70,115 100,75 130,115" fill="#4CAF50"/>
                    </svg>
                `),
                coffee: 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(`
                    <svg width="200" height="200" viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg">
                        <rect width="200" height="200" fill="#795548" rx="15"/>
                        <circle cx="100" cy="100" r="40" fill="white"/>
                        <ellipse cx="100" cy="100" rx="25" ry="30" fill="#795548"/>
                        <ellipse cx="100" cy="85" rx="20" ry="10" fill="#A1887F"/>
                    </svg>
                `),
                culture: 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(`
                    <svg width="200" height="200" viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg">
                        <rect width="200" height="200" fill="#9C27B0" rx="15"/>
                        <circle cx="100" cy="100" r="40" fill="white"/>
                        <path d="M75,100 Q100,70 125,100 Q100,130 75,100" fill="#9C27B0"/>
                    </svg>
                `)
            };
            
            // Get main image - prioritize uploaded images
            let mainImageHtml = '';
            if (place.images && place.images.length > 0) {
                // Use uploaded image as main image
                const uploadedImage = place.images[0];
                mainImageHtml = `<img class="place-main-image" src="${uploadedImage.dataUrl}" alt="${place.name}" style="display: block;">`;
            } else if (place.photos && place.photos.length > 0) {
                const photo = place.photos[0];
                const hasValidPhoto = photo && photo.name && photo.name.trim().length > 0 && 
                                    !photo.name.includes('undefined') && !photo.name.includes('null');
                
                if (hasValidPhoto) {
                    const encodedPhotoName = encodeURIComponent(photo.name);
                    const mainPhotoUrl = `/api/place-photo/${encodedPhotoName}?maxHeightPx=400&maxWidthPx=400`;
                    const fallbackImage = defaultImages[place.category] || defaultImages.recommend;
                    
                    mainImageHtml = `<img class="place-main-image" src="${fallbackImage}" data-real-src="${mainPhotoUrl}" alt="${place.name}" onload="this.style.display='block';" onerror="this.style.display='block';">`;
                    
                    // Try to load real photo
                    setTimeout(() => {
                        const testImg = new Image();
                        testImg.onload = () => {
                            const modalImg = document.querySelector('.place-main-image[data-real-src="' + mainPhotoUrl + '"]');
                            if (modalImg) modalImg.src = mainPhotoUrl;
                        };
                        testImg.onerror = () => {
                            console.log('Modal photo failed, keeping fallback');
                        };
                        testImg.src = mainPhotoUrl;
                    }, 300);
                } else {
                    const fallbackImage = defaultImages[place.category] || defaultImages.recommend;
                    mainImageHtml = `<img class="place-main-image" src="${fallbackImage}" alt="${place.name}">`;
                }
            } else {
                // Use category default image
                const fallbackImage = defaultImages[place.category] || defaultImages.recommend;
                mainImageHtml = `<img class="place-main-image" src="${fallbackImage}" alt="${place.name}">`;
            }
            
            // Build photo gallery - include uploaded images
            let galleryHtml = '';
            let allGalleryImages = [];
            
            // Add uploaded images first (starting from index 1 if we used first image as main)
            if (place.images && place.images.length > 0) {
                const startIndex = 1; // Skip first image as it's used as main
                const uploadedGalleryImages = place.images.slice(startIndex).map((uploadedImage, index) => {
                    const timestamp = Date.now();
                    const imageId = `gallery-uploaded-${timestamp}-${index}`;
                    return `
                        <div class="gallery-image-container" id="container-${imageId}">
                            <img class="gallery-image" 
                                 id="${imageId}"
                                 src="${uploadedImage.dataUrl}" 
                                 alt="${place.name}" 
                                 onclick="openFullImage('${uploadedImage.dataUrl}', '${place.name}')" 
                                 style="cursor: pointer; display: block;">
                        </div>
                    `;
                });
                allGalleryImages.push(...uploadedGalleryImages);
            }
            
            // Add Google Places photos
            if (place.photos && place.photos.length > 0) {
                const startIndex = (place.images && place.images.length > 0) ? 0 : 1; // If we have uploaded images, include all photos in gallery
                const photoGalleryImages = place.photos.slice(startIndex, 9).map((photo, index) => {
                    if (photo && photo.name && photo.name.trim().length > 0 && 
                        !photo.name.includes('undefined') && !photo.name.includes('null')) {
                        const encodedPhotoName = encodeURIComponent(photo.name);
                        const photoUrl = `/api/place-photo/${encodedPhotoName}?maxHeightPx=250&maxWidthPx=250`;
                        const fallbackImage = defaultImages[place.category] || defaultImages.recommend;
                        const timestamp = Date.now();
                        const imageId = `gallery-img-${timestamp}-${index}`;
                        const loadingId = `loading-${timestamp}-${index}`;
                        const errorId = `error-${timestamp}-${index}`;
                        return `
                            <div class="gallery-image-container" id="container-${imageId}">
                                <div class="gallery-loading" id="${loadingId}">
                                    <div class="loading-spinner"></div>
                                    <div class="loading-text">Loading...</div>
                                </div>
                                <img class="gallery-image" 
                                     id="${imageId}"
                                     src="${fallbackImage}" 
                                     data-real-src="${photoUrl}" 
                                     data-loading-id="${loadingId}"
                                     data-error-id="${errorId}"
                                     alt="${place.name}" 
                                     onclick="openFullImage('${photoUrl}', '${place.name}')" 
                                     style="cursor: pointer; display: none;">
                                <div class="gallery-error" id="${errorId}" style="display: none;">
                                    <div class="error-icon">❌</div>
                                    <div class="error-text">Failed to load</div>
                                </div>
                            </div>
                        `;
                    }
                    return '';
                }).filter(img => img.length > 0);
                allGalleryImages.push(...photoGalleryImages);
            }
            
            const galleryImagesHtml = allGalleryImages.join('');
            
            // Generate gallery HTML
            if (allGalleryImages.length > 0) {
                const totalImages = (place.images ? place.images.length - 1 : 0) + (place.photos ? place.photos.length - (place.images && place.images.length > 0 ? 0 : 1) : 0);
                galleryHtml = `
                    <div class="photo-gallery">
                        <div class="gallery-title">
                            <span>📸 More Photos (${totalImages})</span>
                            <span class="gallery-scroll-hint">👆 Swipe to see all →</span>
                        </div>
                        <div class="photo-grid">
                            ${galleryImagesHtml}
                        </div>
                    </div>
                `;
            } else {
                galleryHtml = `
                    <div class="photo-gallery">
                        <div class="no-photos">
                            📷 No additional photos available for this location
                        </div>
                    </div>
                `;
            }
            
            // Create professional mobile modal content
            modalBody.innerHTML = `
                <div class="place-details-full">
                    <div class="place-hero-section">
                        ${mainImageHtml}
                    </div>
                    <div class="place-info-full">
                        <div class="place-name-full">${place.name}</div>
                        <div class="place-address-full">${place.address}</div>
                        
                        <!-- Enhanced Stats Section -->
                        <div class="place-stats-full">
                            ${place.rating > 0 ? `<div class="place-stat rating">⭐ ${place.rating.toFixed(1)}</div>` : ''}
                            ${place.userRatingCount > 0 ? `<div class="place-stat reviews">📝 ${place.userRatingCount} reviews</div>` : ''}
                            <div class="place-stat distance">🚶 ${place.distance}m</div>
                            <div class="place-stat distance">🌍 ${distanceInMiles} mi</div>
                            <div class="place-stat category">${categoryIcon} ${place.category.charAt(0).toUpperCase() + place.category.slice(1)}</div>
                        </div>
                        
                        <!-- Google Place Types Tags -->
                        ${place.types && place.types.length > 0 ? `
                            <div class="place-types-section">
                                <div class="place-types-title">🏷️ Place Types</div>
                                <div class="place-types-tags">
                                    ${place.types.map(type => `<span class="place-type-tag">${type.replace(/_/g, ' ')}</span>`).join('')}
                                </div>
                            </div>
                        ` : ''}
                        
                        <!-- Contact Information -->
                        ${place.nationalPhoneNumber || place.internationalPhoneNumber ? `
                            <div class="place-contact-section">
                                <div class="place-contact-title">📞 Contact Information</div>
                                ${place.nationalPhoneNumber ? `<div class="place-phone">📱 <a href="tel:${place.nationalPhoneNumber}">${place.nationalPhoneNumber}</a></div>` : ''}
                                ${place.internationalPhoneNumber && !place.nationalPhoneNumber ? `<div class="place-phone">📱 <a href="tel:${place.internationalPhoneNumber}">${place.internationalPhoneNumber}</a></div>` : ''}
                                ${place.websiteUri ? `<div class="place-website">🌐 <a href="${place.websiteUri}" target="_blank">Visit Website</a></div>` : ''}
                            </div>
                        ` : ''}
                        
                        <!-- Business Information -->
                        ${place.priceLevel || place.businessStatus ? `
                            <div class="place-business-section">
                                <div class="place-business-title">💼 Business Information</div>
                                ${place.priceLevel !== undefined && place.priceLevel > 0 ? `<div class="place-price">💰 ${'$'.repeat(place.priceLevel)} (${'Inexpensive,Moderate,Expensive,Very Expensive'.split(',')[place.priceLevel - 1]})</div>` : ''}
                                ${place.businessStatus ? `<div class="place-status">🏪 Status: ${place.businessStatus.replace(/_/g, ' ')}</div>` : ''}
                            </div>
                        ` : ''}
                        
                        <!-- Recommendation Metadata -->
                        ${place.addedBy || place.addedDate || place.featured ? `
                            <div class="place-metadata-section">
                                <div class="place-metadata-title">ℹ️ Additional Information</div>
                                ${place.addedBy ? `<div class="place-added-by">👤 Added by: ${place.addedBy.replace(/_/g, ' ')}</div>` : ''}
                                ${place.addedDate ? `<div class="place-added-date">📅 Added: ${new Date(place.addedDate).toLocaleDateString()}</div>` : ''}
                                ${place.featured ? `<div class="place-featured">⭐ Featured Location</div>` : ''}
                            </div>
                        ` : ''}
                        
                        ${generateOpeningHoursHtml(place)}
                        ${place.description ? `<div class="place-description-full">💭 ${place.description}</div>` : `<div class="place-description-full">📱 Tap the buttons below to get directions or visit their website for more information about this ${place.category}.</div>`}
                    </div>
                </div>
                <div class="place-actions">
                    <button class="btn-action" onclick="openDirections(${place.location.latitude}, ${place.location.longitude}, '${encodeURIComponent(place.name)}')">
                        🗺️ Get Directions
                    </button>
                    ${place.websiteUri ? `<a href="${place.websiteUri}" target="_blank" class="btn-action">🌐 Website</a>` : `<button class="btn-action" onclick="sharePlace('${encodeURIComponent(place.name)}', ${place.location.latitude}, ${place.location.longitude})">📤 Share</button>`}
                </div>
                ${galleryHtml}
            `;
            
            // Show modal
            modal.classList.add('show');
            document.body.style.overflow = 'hidden';
            
            // Load gallery images with proper error handling
            setTimeout(() => {
                loadGalleryImages(place);
            }, 100);
        }
        
        // Professional gallery loading system
        class GalleryLoader {
            constructor() {
                this.loadingQueue = [];
                this.isLoading = false;
                this.loadedImages = new Set();
                this.failedImages = new Set();
                this.loadDelay = 200; // Optimized delay
            }

            async loadGalleryImages(place) {
                console.log('🖼️ Professional gallery loading for:', place.name);
                
                const galleryImages = document.querySelectorAll('.gallery-image[data-real-src]');
                if (galleryImages.length === 0) {
                    console.log('No gallery images to load');
                    return;
                }

                // Reset state for new gallery
                this.loadedImages.clear();
                this.failedImages.clear();
                this.loadingQueue = Array.from(galleryImages);

                console.log(`📸 Loading ${galleryImages.length} gallery images`);

                // Start loading with optimized parallel loading
                await this.loadImagesInBatches();
            }

            async loadImagesInBatches() {
                // Load first 3 images immediately in parallel for quick preview
                const immediateLoad = this.loadingQueue.slice(0, 3);
                const remainingImages = this.loadingQueue.slice(3);

                // Load first batch in parallel
                if (immediateLoad.length > 0) {
                    console.log(`🚀 Loading first ${immediateLoad.length} images in parallel`);
                    await Promise.allSettled(immediateLoad.map((img, index) => 
                        this.loadSingleImage(img, index + 1, 0)
                    ));
                }

                // Load remaining images with controlled delays
                for (let i = 0; i < remainingImages.length; i++) {
                    await new Promise(resolve => {
                        setTimeout(async () => {
                            await this.loadSingleImage(remainingImages[i], i + 4, this.loadDelay * i);
                            resolve();
                        }, this.loadDelay * (i + 1));
                    });
                }

                console.log(`✅ Gallery loading complete. Loaded: ${this.loadedImages.size}, Failed: ${this.failedImages.size}`);
            }

            async loadSingleImage(img, imageNumber, delay = 0) {
                const realSrc = img.getAttribute('data-real-src');
                const loadingEl = document.getElementById(img.getAttribute('data-loading-id'));
                const errorEl = document.getElementById(img.getAttribute('data-error-id'));

                if (!realSrc) return;

                try {
                    const success = await this.loadImageWithFallback(img, realSrc, loadingEl, errorEl, imageNumber);
                    if (success) {
                        this.loadedImages.add(imageNumber);
                    } else {
                        this.failedImages.add(imageNumber);
                    }
                } catch (error) {
                    console.error(`Error loading image ${imageNumber}:`, error);
                    this.failedImages.add(imageNumber);
                    this.showError(img, loadingEl, errorEl);
                }
            }

            loadImageWithFallback(img, realSrc, loadingEl, errorEl, imageNumber) {
                return new Promise((resolve) => {
                    const testImg = new Image();
                    testImg.crossOrigin = 'anonymous';
                    
                    const timeout = setTimeout(() => {
                        console.log(`⏰ Image ${imageNumber} timed out`);
                        this.showError(img, loadingEl, errorEl);
                        resolve(false);
                    }, 15000); // 15 second timeout

                    testImg.onload = () => {
                        clearTimeout(timeout);
                        console.log(`✅ Image ${imageNumber} loaded successfully`);
                        this.showImage(img, realSrc, loadingEl);
                        resolve(true);
                    };

                    testImg.onerror = () => {
                        clearTimeout(timeout);
                        console.log(`❌ Image ${imageNumber} failed to load`);
                        this.showError(img, loadingEl, errorEl);
                        resolve(false);
                    };

                    testImg.src = realSrc;
                });
            }

            showImage(img, src, loadingEl) {
                if (loadingEl) loadingEl.style.display = 'none';
                img.src = src;
                img.style.display = 'block';
                img.style.opacity = '0';
                img.style.transition = 'opacity 0.3s ease';
                
                // Smooth fade-in effect
                setTimeout(() => {
                    img.style.opacity = '1';
                }, 50);
            }

            showError(img, loadingEl, errorEl) {
                if (loadingEl) loadingEl.style.display = 'none';
                if (errorEl) {
                    errorEl.style.display = 'flex';
                    // Add retry functionality to error state
                    errorEl.style.cursor = 'pointer';
                    errorEl.onclick = () => {
                        errorEl.style.display = 'none';
                        if (loadingEl) loadingEl.style.display = 'flex';
                        const realSrc = img.getAttribute('data-real-src');
                        if (realSrc) {
                            setTimeout(() => {
                                this.loadSingleImage(img, Date.now(), 0);
                            }, 500);
                        }
                    };
                }
                // Show fallback image
                img.style.display = 'block';
            }
        }

        // Initialize the professional gallery loader
        const galleryLoader = new GalleryLoader();

        function loadGalleryImages(place) {
            galleryLoader.loadGalleryImages(place);
        }

        // Enhanced error display styles for better UX
        function enhanceGalleryErrorDisplay() {
            const style = document.createElement('style');
            style.textContent = `
                .gallery-error {
                    background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%) !important;
                    border: 2px dashed #dee2e6 !important;
                    transition: all 0.3s ease !important;
                    cursor: pointer !important;
                }
                
                .gallery-error:hover {
                    background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%) !important;
                    border-color: #2196f3 !important;
                    transform: scale(1.02) !important;
                }
                
                .gallery-error .error-icon {
                    font-size: 20px !important;
                    margin-bottom: 6px !important;
                }
                
                .gallery-error .error-text {
                    font-size: 10px !important;
                    color: #666 !important;
                    text-align: center !important;
                    font-weight: 500 !important;
                    line-height: 1.2 !important;
                }
                
                .gallery-error::after {
                    content: "👆 Tap to retry" !important;
                    display: block !important;
                    font-size: 9px !important;
                    color: #2196f3 !important;
                    margin-top: 4px !important;
                    font-weight: 600 !important;
                }
                
                .gallery-loading .loading-text {
                    font-size: 11px !important;
                    color: #666 !important;
                    font-weight: 500 !important;
                }
                
                .gallery-image {
                    transition: opacity 0.3s ease, transform 0.2s ease !important;
                }
                
                .gallery-image:hover {
                    transform: scale(1.05) !important;
                    box-shadow: 0 4px 12px rgba(0,0,0,0.15) !important;
                }
                
                .photo-gallery {
                    background: #f8fafc !important;
                }
                
                .gallery-title {
                    font-weight: 700 !important;
                    color: #1a1a1a !important;
                }
                
                .gallery-scroll-hint {
                    animation: pulse 2s infinite !important;
                }
                
                @keyframes pulse {
                    0%, 100% { opacity: 0.6; }
                    50% { opacity: 1; }
                }
            `;
            document.head.appendChild(style);
        }
        
        // Initialize enhanced gallery display
        enhanceGalleryErrorDisplay();
        
        function loadImageSequentially(galleryImages, currentIndex) {
            if (currentIndex >= galleryImages.length) {
                console.log('✅ All gallery images processed');
                return;
            }
            
            const img = galleryImages[currentIndex];
            const loadingId = img.getAttribute('data-loading-id');
            const errorId = img.getAttribute('data-error-id');
            const loadingEl = document.getElementById(loadingId);
            const errorEl = document.getElementById(errorId);
            const realSrc = img.getAttribute('data-real-src');
            
            if (!realSrc) {
                console.log(`Skipping image ${currentIndex + 1} - no source`);
                // Move to next image immediately
                setTimeout(() => loadImageSequentially(galleryImages, currentIndex + 1), 100);
                return;
            }
            
            console.log(`Loading gallery image ${currentIndex + 1}/${galleryImages.length}:`, realSrc);
            
            // Try loading with retry logic
            loadImageWithRetry(img, realSrc, loadingEl, errorEl, currentIndex + 1, 0, (success) => {
                // Adjust delay based on success/failure
                if (!success) {
                    recentFailures++;
                    if (recentFailures >= 2) {
                        // Increase delay if we're getting rate limited
                        currentLoadingDelay = Math.min(currentLoadingDelay * 1.5, 1000);
                        console.log(`⚠️ Increased loading delay to ${currentLoadingDelay}ms due to failures`);
                    }
                } else {
                    // Decrease delay on success
                    if (recentFailures > 0) recentFailures--;
                    if (recentFailures === 0 && currentLoadingDelay > 300) {
                        currentLoadingDelay = Math.max(currentLoadingDelay * 0.8, 300);
                        console.log(`✅ Decreased loading delay to ${currentLoadingDelay}ms`);
                    }
                }
                
                // Move to next image with adaptive delay
                setTimeout(() => loadImageSequentially(galleryImages, currentIndex + 1), currentLoadingDelay);
            });
        }
        
        function loadImageWithRetry(img, realSrc, loadingEl, errorEl, imageNumber, retryCount, onComplete) {
            const maxRetries = 2;
            
            // Create a test image to check if it loads
            const testImg = new Image();
            
            testImg.onload = () => {
                console.log(`✅ Gallery image ${imageNumber} loaded successfully`);
                // Hide loading indicator
                if (loadingEl) {
                    loadingEl.style.display = 'none';
                }
                // Show actual image
                img.src = realSrc;
                img.style.display = 'block';
                onComplete(true); // Success
            };
            
            testImg.onerror = () => {
                console.log(`❌ Gallery image ${imageNumber} failed to load (attempt ${retryCount + 1})`);
                
                if (retryCount < maxRetries) {
                    // Faster retry delays: 500ms, 1s
                    const delay = (retryCount + 1) * 500; // 500ms, 1000ms
                    console.log(`Retrying image ${imageNumber} in ${delay}ms...`);
                    setTimeout(() => {
                        loadImageWithRetry(img, realSrc, loadingEl, errorEl, imageNumber, retryCount + 1, onComplete);
                    }, delay);
                } else {
                    // Final failure - show error state
                    console.log(`Final failure for image ${imageNumber} after ${maxRetries} retries`);
                    if (loadingEl) {
                        loadingEl.style.display = 'none';
                    }
                    if (errorEl) {
                        errorEl.style.display = 'flex';
                    }
                    onComplete(false); // Failure
                }
            };
            
            // Start loading
            testImg.src = realSrc;
        }
        
        function openFullImage(imageUrl, placeName) {
            const fullImageWindow = window.open('', '_blank');
            fullImageWindow.document.write(`
                <html>
                    <head>
                        <title>${placeName} - Photo</title>
                        <style>
                            body { margin: 0; background: #000; display: flex; justify-content: center; align-items: center; min-height: 100vh; }
                            img { max-width: 95%; max-height: 95%; object-fit: contain; border-radius: 8px; }
                        </style>
                    </head>
                    <body>
                        <img src="${imageUrl}" alt="${placeName}">
                    </body>
                </html>
            `);
        }

        function sharePlace(placeName, latitude, longitude) {
            const shareText = `Check out ${placeName}! 📍`;
            const shareUrl = `https://maps.google.com/maps?q=${latitude},${longitude}`;
            
            if (navigator.share) {
                // Use native share API on mobile
                navigator.share({
                    title: placeName,
                    text: shareText,
                    url: shareUrl
                }).catch(err => console.log('Error sharing:', err));
            } else {
                // Fallback: copy to clipboard
                const fullText = `${shareText}\n${shareUrl}`;
                navigator.clipboard.writeText(fullText).then(() => {
                    alert('📋 Location copied to clipboard!');
                }).catch(() => {
                    // Final fallback: open in new window
                    window.open(shareUrl, '_blank');
                });
            }
        }

        // Hotel Location Update Functions
        function extractCoordinatesFromGoogleMapsUrl(url) {
            console.log('Extracting coordinates from URL:', url);
            
            // Remove any whitespace
            url = url.trim();
            
            // Different Google Maps URL patterns
            const patterns = [
                // Standard coordinates: @lat,lng,zoom
                /@(-?\d+\.?\d*),(-?\d+\.?\d*),?\d*z?/,
                // Query coordinates: q=lat,lng
                /q=(-?\d+\.?\d*),(-?\d+\.?\d*)/,
                // Place coordinates: !3d-lat!4d-lng
                /!3d(-?\d+\.?\d*)!4d(-?\d+\.?\d*)/,
                // Another format: ll=lat,lng
                /ll=(-?\d+\.?\d*),(-?\d+\.?\d*)/,
                // Data coordinates: data=lat,lng
                /data=.*?(-?\d+\.?\d*),(-?\d+\.?\d*)/
            ];
            
            for (const pattern of patterns) {
                const match = url.match(pattern);
                if (match) {
                    const lat = parseFloat(match[1]);
                    const lng = parseFloat(match[2]);
                    
                    // Validate coordinates
                    if (lat >= -90 && lat <= 90 && lng >= -180 && lng <= 180) {
                        console.log('Found coordinates:', { lat, lng });
                        return { lat, lng };
                    }
                }
            }
            
            console.log('No valid coordinates found in URL');
            return null;
        }

        // GPS Location Functions
        async function getCurrentLocationGPS() {
            return new Promise((resolve, reject) => {
                if (!navigator.geolocation) {
                    reject(new Error('Geolocation is not supported by this browser'));
                    return;
                }

                const options = {
                    enableHighAccuracy: true,
                    timeout: 10000,
                    maximumAge: 300000 // 5 minutes
                };

                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        resolve({
                            latitude: position.coords.latitude,
                            longitude: position.coords.longitude,
                            accuracy: position.coords.accuracy
                        });
                    },
                    (error) => {
                        let errorMessage = 'Unable to get your location';
                        switch (error.code) {
                            case error.PERMISSION_DENIED:
                                errorMessage = 'Location access denied. Please enable location permissions and try again.';
                                break;
                            case error.POSITION_UNAVAILABLE:
                                errorMessage = 'Location information unavailable. Please check your GPS and try again.';
                                break;
                            case error.TIMEOUT:
                                errorMessage = 'Location request timed out. Please try again.';
                                break;
                        }
                        reject(new Error(errorMessage));
                    },
                    options
                );
            });
        }

        async function useGPSLocation() {
            const gpsBtn = document.getElementById('useGpsBtn');
            const originalText = gpsBtn.innerHTML;
            
            try {
                // Update button to show loading
                gpsBtn.innerHTML = '🔄 Getting location...';
                gpsBtn.disabled = true;
                
                console.log('🌍 Requesting GPS location...');
                const location = await getCurrentLocationGPS();
                
                console.log('✅ GPS location obtained:', location);
                
                // Update the hotel location with GPS coordinates
                HOTEL_LOCATION.lat = location.latitude;
                HOTEL_LOCATION.lng = location.longitude;
                
                // Reverse geocode to get address
                try {
                    const response = await fetch('/api/geocode-coordinates', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            latitude: location.latitude,
                            longitude: location.longitude
                        })
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        HOTEL_LOCATION.address = data.address;
                        HOTEL_LOCATION.name = 'Your GPS Location';
                        document.getElementById('currentLocationText').textContent = `📍 Current: ${data.address}`;
                    } else {
                        const coordsText = `${location.latitude.toFixed(6)}, ${location.longitude.toFixed(6)}`;
                        HOTEL_LOCATION.address = coordsText;
                        HOTEL_LOCATION.name = 'Your GPS Location';
                        document.getElementById('currentLocationText').textContent = `📍 Current: ${coordsText}`;
                    }
                } catch (geocodeError) {
                    console.warn('Reverse geocoding failed:', geocodeError);
                    const coordsText = `${location.latitude.toFixed(6)}, ${location.longitude.toFixed(6)}`;
                    HOTEL_LOCATION.address = coordsText;
                    HOTEL_LOCATION.name = 'Your GPS Location';
                    document.getElementById('currentLocationText').textContent = `📍 Current: ${coordsText}`;
                }
                
                // Clear the URL input since we're using GPS
                document.getElementById('hotelMapsUrl').value = '';
                
                // Update map center if map is initialized
                if (map) {
                    map.setCenter(HOTEL_LOCATION);
                    map.setZoom(15);
                    
                    // Add or update hotel marker
                    if (hotelMarker) {
                        hotelMarker.setPosition(HOTEL_LOCATION);
                    } else {
                        hotelMarker = new google.maps.Marker({
                            position: HOTEL_LOCATION,
                            map: map,
                            title: 'Your Location (GPS)',
                            icon: {
                                url: 'data:image/svg+xml;charset=UTF-8,' + encodeURIComponent(`
                                    <svg width="40" height="50" viewBox="0 0 40 50" xmlns="http://www.w3.org/2000/svg">
                                        <path d="M20 0C8.95 0 0 8.95 0 20c0 11.05 20 30 20 30s20-18.95 20-30C40 8.95 31.05 0 20 0z" fill="#FF6B35"/>
                                        <circle cx="20" cy="20" r="8" fill="white"/>
                                        <text x="20" y="26" text-anchor="middle" fill="#FF6B35" font-size="12" font-weight="bold">📍</text>
                                    </svg>
                                `),
                                scaledSize: new google.maps.Size(40, 50),
                                anchor: new google.maps.Point(20, 50)
                            }
                        });
                    }
                }
                
                // Success feedback
                gpsBtn.innerHTML = '✅ Location Updated!';
                gpsBtn.style.background = 'linear-gradient(135deg, #4CAF50 0%, #45a049 100%)';
                
                // Clear all current places since location changed
                clearAllPlaces();
                
                console.log('🎯 GPS location set successfully!');
                
                // Reset button after 2 seconds
                setTimeout(() => {
                    gpsBtn.innerHTML = originalText;
                    gpsBtn.style.background = 'linear-gradient(135deg, #FF6B35 0%, #F7931E 100%)';
                    gpsBtn.disabled = false;
                }, 2000);
                
            } catch (error) {
                console.error('❌ GPS location error:', error);
                
                // Show error message
                alert(`GPS Error: ${error.message}\n\nPlease:\n1. Enable location permissions in your browser\n2. Make sure GPS is enabled on your device\n3. Try using WiFi for better location accuracy\n4. Use the manual URL input as an alternative`);
                
                // Reset button
                gpsBtn.innerHTML = originalText;
                gpsBtn.disabled = false;
            }
        }

        async function updateHotelLocation() {
            const urlInput = document.getElementById('hotelMapsUrl');
            const updateBtn = document.getElementById('updateLocationBtn');
            const currentLocationText = document.getElementById('currentLocationText');
            const locationDescription = document.getElementById('locationDescription');
            
            const url = urlInput.value.trim();
            
            if (!url) {
                alert('Please paste a Google Maps URL first');
                return;
            }
            
            // Disable button and show loading
            updateBtn.disabled = true;
            updateBtn.textContent = '🔄 Extracting...';
            
            try {
                // Extract coordinates from URL
                const coordinates = extractCoordinatesFromGoogleMapsUrl(url);
                
                if (!coordinates) {
                    throw new Error('Could not extract coordinates from the URL. Please make sure it\'s a valid Google Maps link.');
                }
                
                // Update the global hotel location
                HOTEL_LOCATION.lat = coordinates.lat;
                HOTEL_LOCATION.lng = coordinates.lng;
                
                // Try to get address from coordinates using reverse geocoding
                updateBtn.textContent = '🌐 Getting address...';
                
                try {
                    const response = await fetch('/api/geocode-coordinates', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            latitude: coordinates.lat,
                            longitude: coordinates.lng
                        })
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        HOTEL_LOCATION.address = data.address;
                        HOTEL_LOCATION.name = 'Your Hotel Location';
                        
                        // Update displays
                        currentLocationText.textContent = `📍 Current: ${data.address}`;
                        locationDescription.textContent = `Discover restaurants, landmarks, coffee shops & culture near ${data.address}`;
                    } else {
                        // Use coordinates if reverse geocoding fails
                        const coordsText = `${coordinates.lat.toFixed(4)}, ${coordinates.lng.toFixed(4)}`;
                        HOTEL_LOCATION.address = coordsText;
                        HOTEL_LOCATION.name = 'Your Hotel Location';
                        
                        currentLocationText.textContent = `📍 Current: ${coordsText}`;
                        locationDescription.textContent = `Discover restaurants, landmarks, coffee shops & culture near ${coordsText}`;
                    }
                } catch (geocodeError) {
                    console.log('Reverse geocoding failed, using coordinates:', geocodeError);
                    const coordsText = `${coordinates.lat.toFixed(4)}, ${coordinates.lng.toFixed(4)}`;
                    HOTEL_LOCATION.address = coordsText;
                    HOTEL_LOCATION.name = 'Your Hotel Location';
                    
                    currentLocationText.textContent = `📍 Current: ${coordsText}`;
                    locationDescription.textContent = `Discover restaurants, landmarks, coffee shops & culture near ${coordsText}`;
                }
                
                // Update map if it exists
                if (map && hotelMarker) {
                    map.setCenter(HOTEL_LOCATION);
                    hotelMarker.setPosition(HOTEL_LOCATION);
                    map.setZoom(14);
                }
                
                // Clear existing places so user knows to reload
                clearAllPlaces();
                
                // Clear the input
                urlInput.value = '';
                
                alert('✅ Hotel location updated successfully! Click "Load Places on Map" to find nearby places.');
                
            } catch (error) {
                console.error('Error updating hotel location:', error);
                alert('❌ Error: ' + error.message);
            } finally {
                // Re-enable button
                updateBtn.disabled = false;
                updateBtn.textContent = '🔄 Update Location';
            }
        }
        
        function hideImageModal() {
            const modal = document.getElementById('imageModal');
            modal.classList.remove('show');
            document.body.style.overflow = 'auto';
        }

        function openDirections(lat, lng, placeName) {
            const url = `https://www.google.com/maps/dir/?api=1&destination=${lat},${lng}&destination_place_id=${encodeURIComponent(placeName)}`;
            window.open(url, '_blank');
        }

        // Global initMap function for Google Maps callback
        window.initMap = function() {
            console.log('🗺️ Google Maps API callback triggered');
            initializeMapInternal();
        };

        // Define the actual initialization function
        function initializeMapInternal() {
            console.log('🗺️ Initializing Google Maps...');
            // Call the actual map initialization function
            try {
                initializeGoogleMap();
            } catch (error) {
                console.error('Error initializing map:', error);
            }
        }

        // Initialize when page loads - with better timing and mobile support
        window.addEventListener('load', () => {
            console.log('📱 Page loaded, checking for Google Maps API...');
            
            // Check if Google Maps API is already loaded
            if (typeof google !== 'undefined' && google.maps) {
                console.log('✅ Google Maps API already available');
                initializeMapInternal();
            } else {
                console.log('⏳ Waiting for Google Maps API to load...');
                // Set up a callback for when the API loads
                let attempts = 0;
                const checkForGoogle = setInterval(() => {
                    attempts++;
                    if (typeof google !== 'undefined' && google.maps) {
                        console.log('✅ Google Maps API loaded after', attempts, 'attempts');
                        clearInterval(checkForGoogle);
                        initializeMapInternal();
                    } else if (attempts > 20) {
                        console.error('❌ Google Maps API failed to load after 20 attempts');
                        clearInterval(checkForGoogle);
                        // Show error message to user
                        document.body.innerHTML += '<div style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #ff4444; color: white; padding: 20px; border-radius: 10px; z-index: 10000; text-align: center;"><h3>🚨 Map Loading Error</h3><p>Please refresh the page or check your internet connection.</p></div>';
                    }
                }, 500);
            }
        });

        // Initialize when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            updateLoadButtonText(); // Initialize button text
            updateSelectedCategoriesDisplay(); // Initialize category display
            updatePlacesList(); // Initialize places list
            
            // Auto-load manual recommendations since 'recommend' is selected by default
            if (activeCategories.has('recommend')) {
                console.log('Auto-loading manual recommendations on page load...');
                fetchManualRecommendations().then(() => {
                    updateMapMarkers();
                    updateStats();
                    
                    // If Google Maps isn't ready yet, set up a retry
                    if (typeof google === 'undefined' || !map) {
                        console.log('Map not ready, will retry when Google Maps loads...');
                        // Set up a flag to retry map updates when Google Maps loads
                        window.retryMapUpdate = true;
                    }
                });
            }
            
            // Initialize address extraction functionality
            initAddressExtraction();
            
            // Initialize export/import functionality
            initExportImport();
        });

        // Image upload functionality
        let uploadedImages = [];
        
        // Export/Import functionality
        function initExportImport() {
            const exportBtn = document.getElementById('exportRecommendation');
            const importBtn = document.getElementById('importRecommendation');
            const importFileInput = document.getElementById('importFileInput');

            // Export button click
            exportBtn.addEventListener('click', exportRecommendationData);

            // Import button click
            importBtn.addEventListener('click', () => {
                importFileInput.click();
            });

            // Import file selection
            importFileInput.addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    importRecommendationData(e.target.files[0]);
                }
            });
        }

        function exportRecommendationData() {
            try {
                console.log('📤 Starting data export...');
                
                // Collect all form data
                const formData = {
                    name: document.getElementById('recName').value,
                    address: document.getElementById('recAddress').value,
                    latitude: document.getElementById('recLatitude').value,
                    longitude: document.getElementById('recLongitude').value,
                    rating: document.getElementById('recRating').value,
                    description: document.getElementById('recDescription').value,
                    website: document.getElementById('recWebsite').value,
                    featured: document.getElementById('recFeatured').checked,
                    googleMapsUrl: document.getElementById('googleMapsUrl').value,
                    
                    // Export images data
                    images: uploadedImages.map(img => ({
                        id: img.id,
                        dataUrl: img.dataUrl,
                        type: img.type,
                        name: img.name || 'image.jpg'
                    })),
                    
                    // Export address extraction data if available
                    extractedAddressData: extractedAddressData,
                    
                    // Export structured content if available
                    structuredContent: document.getElementById('structuredContent').value,
                    parsedData: parsedData,
                    
                    // Metadata
                    exportDate: new Date().toISOString(),
                    version: '1.0'
                };
                
                // Create filename with timestamp
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                const filename = `recommendation_export_${timestamp}.json`;
                
                // Create and download file
                const blob = new Blob([JSON.stringify(formData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                console.log('✅ Data exported successfully:', filename);
                
                // Show success notification
                const notification = document.createElement('div');
                notification.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: #17a2b8;
                    color: white;
                    padding: 15px 20px;
                    border-radius: 5px;
                    z-index: 10000;
                    font-size: 14px;
                    box-shadow: 0 2px 10px rgba(0,0,0,0.2);
                `;
                notification.innerHTML = `📤 Data exported successfully!<br><small>${filename}</small>`;
                document.body.appendChild(notification);
                
                setTimeout(() => {
                    notification.remove();
                }, 4000);
                
            } catch (error) {
                console.error('❌ Error exporting data:', error);
                alert('❌ Error exporting data: ' + error.message);
            }
        }

        async function importRecommendationData(file) {
            try {
                console.log('📥 Starting data import...');
                
                if (!file.type.includes('json')) {
                    throw new Error('Please select a JSON file');
                }
                
                const fileContent = await file.text();
                const importData = JSON.parse(fileContent);
                
                console.log('📊 Import data:', importData);
                
                // Validate import data
                if (!importData.version || !importData.exportDate) {
                    throw new Error('Invalid export file format');
                }
                
                // Clear existing form data
                clearFormData();
                
                // Import basic form fields
                if (importData.name) document.getElementById('recName').value = importData.name;
                if (importData.address) document.getElementById('recAddress').value = importData.address;
                if (importData.latitude) document.getElementById('recLatitude').value = importData.latitude;
                if (importData.longitude) document.getElementById('recLongitude').value = importData.longitude;
                if (importData.rating) document.getElementById('recRating').value = importData.rating;
                if (importData.description) document.getElementById('recDescription').value = importData.description;
                if (importData.website) document.getElementById('recWebsite').value = importData.website;
                if (importData.googleMapsUrl) document.getElementById('googleMapsUrl').value = importData.googleMapsUrl;
                if (importData.featured !== undefined) document.getElementById('recFeatured').checked = importData.featured;
                
                // Import images
                if (importData.images && importData.images.length > 0) {
                    console.log('🖼️ Importing images...');
                    uploadedImages = [];
                    
                    for (const imageData of importData.images) {
                        uploadedImages.push({
                            id: imageData.id,
                            dataUrl: imageData.dataUrl,
                            type: imageData.type,
                            name: imageData.name
                        });
                        
                        // Add image preview
                        const previewContainer = document.getElementById('imagePreviewContainer');
                        const previewItem = document.createElement('div');
                        previewItem.className = 'image-preview-item';
                        previewItem.dataset.imageId = imageData.id;
                        
                        previewItem.innerHTML = `
                            <img src="${imageData.dataUrl}" alt="Preview">
                            <button type="button" class="image-preview-remove" onclick="removeImagePreview('${imageData.id}')">×</button>
                        `;
                        
                        previewContainer.appendChild(previewItem);
                    }
                    
                    console.log(`✅ Imported ${importData.images.length} images`);
                }
                
                // Import structured content
                if (importData.structuredContent) {
                    document.getElementById('structuredContent').value = importData.structuredContent;
                }
                
                // Import parsed data
                if (importData.parsedData) {
                    parsedData = importData.parsedData;
                    await displayParsedContent(parsedData);
                }
                
                // Import address extraction data
                if (importData.extractedAddressData) {
                    extractedAddressData = importData.extractedAddressData;
                    displayExtractedAddress(extractedAddressData);
                }
                
                // Show the generated URL if available
                if (importData.googleMapsUrl) {
                    const urlDisplay = document.getElementById('generatedUrlDisplay');
                    const urlLink = document.getElementById('generatedUrlLink');
                    if (urlDisplay && urlLink) {
                        urlLink.href = importData.googleMapsUrl;
                        urlLink.textContent = importData.googleMapsUrl;
                        urlDisplay.style.display = 'block';
                    }
                }
                
                console.log('✅ Data imported successfully');
                
                // Show success notification
                const notification = document.createElement('div');
                notification.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: #28a745;
                    color: white;
                    padding: 15px 20px;
                    border-radius: 5px;
                    z-index: 10000;
                    font-size: 14px;
                    box-shadow: 0 2px 10px rgba(0,0,0,0.2);
                `;
                notification.innerHTML = `📥 Data imported successfully!<br><small>Form populated with ${importData.images ? importData.images.length : 0} images</small>`;
                document.body.appendChild(notification);
                
                setTimeout(() => {
                    notification.remove();
                }, 4000);
                
                // Clear file input
                document.getElementById('importFileInput').value = '';
                
            } catch (error) {
                console.error('❌ Error importing data:', error);
                alert('❌ Error importing data: ' + error.message + '\n\nPlease make sure you selected a valid export file.');
            }
        }

        function clearFormData() {
            // Clear form fields
            document.getElementById('recName').value = '';
            document.getElementById('recAddress').value = '';
            document.getElementById('recLatitude').value = '';
            document.getElementById('recLongitude').value = '';
            document.getElementById('recRating').value = '4.0';
            document.getElementById('recDescription').value = '';
            document.getElementById('recWebsite').value = '';
            document.getElementById('recFeatured').checked = false;
            document.getElementById('googleMapsUrl').value = '';
            document.getElementById('structuredContent').value = '';
            
            // Clear images
            uploadedImages = [];
            document.getElementById('imagePreviewContainer').innerHTML = '';
            
            // Clear address extraction
            extractedAddressData = null;
            document.getElementById('addressPreviewContainer').innerHTML = '';
            document.getElementById('extractedAddressDisplay').style.display = 'none';
            
            // Clear parsed content
            parsedData = null;
            document.getElementById('parsedContentPreview').style.display = 'none';
            document.getElementById('quickAddBtn').style.display = 'none';
            
            // Clear generated URL display
            const urlDisplay = document.getElementById('generatedUrlDisplay');
            if (urlDisplay) {
                urlDisplay.style.display = 'none';
            }
        }
        
        // Address extraction functionality
        let addressImage = null;
        let extractedAddressData = null;
        
        function initAddressExtraction() {
            const addressDropZone = document.getElementById('addressDropZone');
            const addressFileInput = document.getElementById('addressFileInput');
            const addressPreviewContainer = document.getElementById('addressPreviewContainer');
            const useAddressBtn = document.getElementById('useExtractedAddress');

            // Click to upload address image
            addressDropZone.addEventListener('click', () => {
                addressFileInput.click();
            });

            // File input change for address
            addressFileInput.addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    handleAddressImage(e.target.files[0]);
                }
            });

            // Drag and drop for address extraction
            addressDropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                addressDropZone.classList.add('drag-over');
            });

            addressDropZone.addEventListener('dragleave', (e) => {
                e.preventDefault();
                addressDropZone.classList.remove('drag-over');
            });

            addressDropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                addressDropZone.classList.remove('drag-over');
                if (e.dataTransfer.files.length > 0) {
                    handleAddressImage(e.dataTransfer.files[0]);
                }
            });

            // Focus/blur events for address zone
            addressDropZone.addEventListener('focus', () => {
                addressDropZone.classList.add('focused');
            });

            addressDropZone.addEventListener('blur', () => {
                addressDropZone.classList.remove('focused');
            });

            // Make it focusable
            addressDropZone.setAttribute('tabindex', '0');

            // Use extracted address button
            useAddressBtn.addEventListener('click', () => {
                if (extractedAddressData) {
                    populateFormWithAddress(extractedAddressData);
                }
            });

            // Enhanced paste event for address images
            document.addEventListener('paste', (e) => {
                const adminPanel = document.getElementById('adminPanel');
                if (adminPanel.style.display !== 'none') {
                    console.log('📋 Paste event detected in admin panel');
                    
                    // Check if we're focused on address zone or if address section is visible
                    const addressZone = document.getElementById('addressDropZone');
                    const isAddressFocused = document.activeElement === addressZone || 
                                           addressZone.classList.contains('focused');
                    
                    // Also check if we're anywhere in the address extraction section
                    const addressSection = document.querySelector('.address-extraction-section');
                    const isInAddressSection = addressSection && addressSection.contains(document.activeElement);
                    
                    console.log('📍 Address zone focused:', isAddressFocused);
                    console.log('📍 In address section:', isInAddressSection);
                    console.log('📍 Active element:', document.activeElement);
                    console.log('📍 Address zone classes:', addressZone.classList.toString());
                    
                    // Check if we should handle address image paste
                    const addressPreviewContainer = document.getElementById('addressPreviewContainer');
                    const hasAddressImage = addressPreviewContainer && addressPreviewContainer.children.length > 0;
                    
                    // If address zone is focused OR we're in the address section OR no address image exists yet, handle address image paste
                    if (isAddressFocused || isInAddressSection || !hasAddressImage) {
                        const items = e.clipboardData.items;
                        console.log('📋 Clipboard items:', items.length);
                        
                        for (let item of items) {
                            console.log('📋 Item type:', item.type);
                            if (item.type.startsWith('image/')) {
                                const file = item.getAsFile();
                                console.log('📍 Address image file:', file);
                                
                                // Show paste feedback for address zone
                                addressDropZone.classList.add('processing');
                                
                                const pasteNotification = document.createElement('div');
                                pasteNotification.style.cssText = `
                                    position: fixed;
                                    top: 20px;
                                    right: 20px;
                                    background: #ff9800;
                                    color: white;
                                    padding: 10px 15px;
                                    border-radius: 5px;
                                    z-index: 10000;
                                    font-size: 14px;
                                    box-shadow: 0 2px 10px rgba(0,0,0,0.2);
                                `;
                                pasteNotification.innerHTML = '📍 Address image pasted! Processing...';
                                document.body.appendChild(pasteNotification);
                                
                                handleAddressImage(file);
                                
                                setTimeout(() => {
                                    addressDropZone.classList.remove('processing');
                                    pasteNotification.remove();
                                }, 2000);
                                
                                e.preventDefault();
                                return;
                            }
                        }
                    }
                    
                    // If no address focus, check for regular image paste
                    const regularDropZone = document.getElementById('imageDropZone');
                    const isRegularFocused = document.activeElement === regularDropZone || 
                                           regularDropZone.classList.contains('focused');
                    
                    console.log('📷 Regular zone focused:', isRegularFocused);
                    
                    if (isRegularFocused) {
                        const items = e.clipboardData.items;
                        for (let item of items) {
                            if (item.type.startsWith('image/')) {
                                const file = item.getAsFile();
                                console.log('📷 Regular image file:', file);
                                
                                // Show paste feedback for regular zone
                                regularDropZone.classList.add('paste-active');
                                
                                const pasteNotification = document.createElement('div');
                                pasteNotification.style.cssText = `
                                    position: fixed;
                                    top: 20px;
                                    right: 20px;
                                    background: #28a745;
                                    color: white;
                                    padding: 10px 15px;
                                    border-radius: 5px;
                                    z-index: 10000;
                                    font-size: 14px;
                                    box-shadow: 0 2px 10px rgba(0,0,0,0.2);
                                `;
                                pasteNotification.innerHTML = '📋 Image pasted! Processing...';
                                document.body.appendChild(pasteNotification);
                                
                                handleFiles([file]);
                                
                                setTimeout(() => {
                                    regularDropZone.classList.remove('paste-active');
                                    pasteNotification.remove();
                                }, 2000);
                                
                                e.preventDefault();
                                return;
                            }
                        }
                    }
                }
            });
        }

        function handleAddressImage(file) {
            console.log('📍 handleAddressImage called with file:', file);
            
            if (!file.type.startsWith('image/')) {
                console.error('❌ Invalid file type:', file.type);
                alert('Please select an image file');
                return;
            }

            if (file.size > 5 * 1024 * 1024) { // 5MB limit
                console.error('❌ File too large:', file.size);
                alert('Image size must be less than 5MB');
                return;
            }

            console.log('✅ File is valid, reading as data URL...');
            const reader = new FileReader();
            reader.onload = (e) => {
                console.log('✅ File read successfully, displaying preview...');
                displayAddressPreview(e.target.result);
                addressImage = e.target.result;
            };
            reader.onerror = (e) => {
                console.error('❌ Error reading file:', e);
                alert('Error reading file');
            };
            reader.readAsDataURL(file);
        }

        function displayAddressPreview(imageDataUrl) {
            console.log('📍 displayAddressPreview called');
            
            const previewContainer = document.getElementById('addressPreviewContainer');
            if (!previewContainer) {
                console.error('❌ Address preview container not found');
                return;
            }
            
            const imageId = 'addr_' + Date.now() + '_' + Math.random().toString(36).substring(7);
            console.log('📍 Generated image ID:', imageId);
            
            previewContainer.innerHTML = `
                <div class="address-preview-item" data-image-id="${imageId}">
                    <img src="${imageDataUrl}" alt="Address Image">
                    <button type="button" class="address-preview-remove" onclick="removeAddressPreview()">×</button>
                    <button type="button" class="address-extract-btn" onclick="extractAddressFromAddressImage('${imageId}', '${imageDataUrl}')">🔍 Extract Address</button>
                </div>
            `;
            
            console.log('✅ Address preview displayed');
        }

        function removeAddressPreview() {
            const previewContainer = document.getElementById('addressPreviewContainer');
            const extractedDisplay = document.getElementById('extractedAddressDisplay');
            
            previewContainer.innerHTML = '';
            extractedDisplay.style.display = 'none';
            addressImage = null;
            extractedAddressData = null;
        }

        function initImageUpload() {
            const dropZone = document.getElementById('imageDropZone');
            const fileInput = document.getElementById('imageFileInput');
            const previewContainer = document.getElementById('imagePreviewContainer');

            // Click to upload
            dropZone.addEventListener('click', () => {
                fileInput.click();
            });

            // Focus/blur events for paste zone visibility
            dropZone.addEventListener('focus', () => {
                dropZone.classList.add('focused');
            });

            dropZone.addEventListener('blur', () => {
                dropZone.classList.remove('focused');
            });

            // Make it focusable for keyboard navigation and paste hints
            dropZone.setAttribute('tabindex', '0');

            // File input change
            fileInput.addEventListener('change', (e) => {
                handleFiles(e.target.files);
            });

            // Drag and drop
            dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropZone.classList.add('drag-over');
            });

            dropZone.addEventListener('dragleave', (e) => {
                e.preventDefault();
                dropZone.classList.remove('drag-over');
            });

            dropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                dropZone.classList.remove('drag-over');
                handleFiles(e.dataTransfer.files);
            });

            // Enhanced paste event for images with visual feedback
            document.addEventListener('paste', (e) => {
                const adminPanel = document.getElementById('adminPanel');
                if (adminPanel.style.display !== 'none') {
                    const items = e.clipboardData.items;
                    let hasImage = false;
                    
                    for (let item of items) {
                        if (item.type.startsWith('image/')) {
                            hasImage = true;
                            const file = item.getAsFile();
                            
                            // Show visual feedback
                            const dropZone = document.getElementById('imageDropZone');
                            dropZone.classList.add('paste-active');
                            
                            // Show paste feedback
                            const pasteNotification = document.createElement('div');
                            pasteNotification.style.cssText = `
                                position: fixed;
                                top: 20px;
                                right: 20px;
                                background: #28a745;
                                color: white;
                                padding: 10px 15px;
                                border-radius: 5px;
                                z-index: 10000;
                                font-size: 14px;
                                box-shadow: 0 2px 10px rgba(0,0,0,0.2);
                            `;
                            pasteNotification.innerHTML = '📋 Image pasted! Processing...';
                            document.body.appendChild(pasteNotification);
                            
                            handleFiles([file]);
                            
                            // Reset visual feedback
                            setTimeout(() => {
                                dropZone.classList.remove('paste-active');
                                pasteNotification.remove();
                            }, 2000);
                        }
                    }
                    
                    // If no image was pasted, show helpful message
                    if (!hasImage && e.clipboardData.items.length > 0) {
                        const noImageNotification = document.createElement('div');
                        noImageNotification.style.cssText = `
                            position: fixed;
                            top: 20px;
                            right: 20px;
                            background: #ffc107;
                            color: #212529;
                            padding: 10px 15px;
                            border-radius: 5px;
                            z-index: 10000;
                            font-size: 14px;
                            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
                        `;
                        noImageNotification.innerHTML = '⚠️ No image in clipboard. Copy an image first!';
                        document.body.appendChild(noImageNotification);
                        
                        setTimeout(() => {
                            noImageNotification.remove();
                        }, 3000);
                    }
                }
            });
        }

        function handleFiles(files) {
            for (let file of files) {
                if (file.type.startsWith('image/')) {
                    if (file.size > 5 * 1024 * 1024) { // 5MB limit
                        alert('Image size must be less than 5MB');
                        continue;
                    }
                    addImagePreview(file);
                }
            }
        }

        function addImagePreview(file) {
            const reader = new FileReader();
            const imageId = 'img_' + Date.now() + '_' + Math.random().toString(36).substring(7);
            
            reader.onload = (e) => {
                const previewContainer = document.getElementById('imagePreviewContainer');
                const previewItem = document.createElement('div');
                previewItem.className = 'image-preview-item';
                previewItem.dataset.imageId = imageId;
                
                previewItem.innerHTML = `
                    <img src="${e.target.result}" alt="Preview">
                    <button type="button" class="image-preview-remove" onclick="removeImagePreview('${imageId}')">×</button>
                `;
                
                previewContainer.appendChild(previewItem);
                
                // Store image data
                uploadedImages.push({
                    id: imageId,
                    file: file,
                    dataUrl: e.target.result,
                    name: file.name
                });
            };
            
            reader.readAsDataURL(file);
        }

        function removeImagePreview(imageId) {
            // Remove from DOM
            const previewItem = document.querySelector(`[data-image-id="${imageId}"]`);
            if (previewItem) {
                previewItem.remove();
            }
            
            // Remove from uploaded images array
            uploadedImages = uploadedImages.filter(img => img.id !== imageId);
        }

        function clearImagePreviews() {
            uploadedImages = [];
            const previewContainer = document.getElementById('imagePreviewContainer');
            previewContainer.innerHTML = '';
        }

        // Initialize image upload when DOM is ready
        document.addEventListener('DOMContentLoaded', initImageUpload);

        // Delete recommendation functionality
        async function deleteRecommendation(recommendationId, event) {
            // Prevent triggering the place click event
            event.stopPropagation();
            
            // Find the recommendation
            const recommendation = allPlaces.recommend?.find(rec => rec.id === recommendationId);
            if (!recommendation) {
                alert('Recommendation not found');
                return;
            }
            
            // Confirm deletion
            const confirmDelete = confirm(`Are you sure you want to delete "${recommendation.name}"?`);
            if (!confirmDelete) {
                return;
            }
            
            try {
                // Call the delete API
                const response = await fetch(`/api/recommendations/${recommendationId}`, {
                    method: 'DELETE',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                const result = await response.json();
                
                if (response.ok && result.success) {
                    // Remove from local data
                    allPlaces.recommend = allPlaces.recommend.filter(rec => rec.id !== recommendationId);
                    
                    // Update displays
                    updateMapMarkers();
                    updateStats();
                    updatePlacesList();
                    
                    alert(`✅ Successfully deleted: ${recommendation.name}`);
                    console.log(`Deleted recommendation: ${recommendation.name}`);
                } else {
                    alert(`❌ Failed to delete recommendation: ${result.error || 'Unknown error'}`);
                }
            } catch (error) {
                console.error('Error deleting recommendation:', error);
                alert('❌ Network error. Please try again.');
            }
        }

        // Structured content parsing functionality
        let parsedData = null;

        function parseStructuredContent(content) {
            const lines = content.split('\n').filter(line => line.trim());
            const parsed = {};
            
            lines.forEach(line => {
                const parts = line.split(':');
                if (parts.length >= 2) {
                    const key = parts[0].trim().toLowerCase();
                    const value = parts.slice(1).join(':').trim();
                    
                    switch (key) {
                        case 'file':
                            // Extract business name from filename
                            const filename = value.split('/').pop().replace(/\.[^/.]+$/, '');
                            parsed.filename = filename;
                            break;
                        case 'prices':
                            parsed.prices = value;
                            break;
                        case 'addresses':
                        case 'address':
                            parsed.address = value;
                            break;
                        case 'places':
                        case 'place':
                            parsed.places = value;
                            // Extract business name from places
                            const placeParts = value.split(',').map(p => p.trim());
                            parsed.businessName = placeParts.length > 1 ? placeParts[1] : placeParts[0];
                            break;
                        case 'hours':
                            parsed.hours = value;
                            break;
                        case 'food items':
                        case 'items':
                            parsed.foodItems = value;
                            break;
                        case 'sentiment':
                            parsed.sentiment = value;
                            break;
                        case 'summary':
                            parsed.summary = value;
                            break;
                    }
                }
            });
            
            return parsed;
        }

        async function displayParsedContent(parsed) {
            const previewContainer = document.getElementById('parsedContentPreview');
            const quickAddBtn = document.getElementById('quickAddBtn');
            
            let previewHTML = '<h4>🤖 AI Parsed Content:</h4>';
            
            if (parsed.businessName) {
                previewHTML += `<div class="parsed-item"><span class="parsed-label">Place Name:</span> <span class="parsed-value">${parsed.businessName}</span></div>`;
            }
            if (parsed.address) {
                previewHTML += `<div class="parsed-item"><span class="parsed-label">Address:</span> <span class="parsed-value">${parsed.address}</span></div>`;
            }
            if (parsed.category) {
                previewHTML += `<div class="parsed-item"><span class="parsed-label">Category:</span> <span class="parsed-value">${parsed.category}</span></div>`;
            }
            if (parsed.priceRange || parsed.prices) {
                const price = parsed.priceRange || parsed.prices;
                previewHTML += `<div class="parsed-item"><span class="parsed-label">Price Range:</span> <span class="parsed-value">${price}</span></div>`;
            }
            if (parsed.hours) {
                previewHTML += `<div class="parsed-item"><span class="parsed-label">Hours:</span> <span class="parsed-value">${parsed.hours}</span></div>`;
            }
            if (parsed.menuItems || parsed.foodItems) {
                const menu = parsed.menuItems || parsed.foodItems;
                previewHTML += `<div class="parsed-item"><span class="parsed-label">Menu:</span> <span class="parsed-value">${menu}</span></div>`;
            }
            if (parsed.rating) {
                previewHTML += `<div class="parsed-item"><span class="parsed-label">Rating:</span> <span class="parsed-value">${parsed.rating}/5</span></div>`;
            }
            if (parsed.phone) {
                previewHTML += `<div class="parsed-item"><span class="parsed-label">Phone:</span> <span class="parsed-value">${parsed.phone}</span></div>`;
            }
            if (parsed.website) {
                previewHTML += `<div class="parsed-item"><span class="parsed-label">Website:</span> <span class="parsed-value">${parsed.website}</span></div>`;
            }
            if (parsed.description || parsed.summary) {
                const desc = parsed.description || parsed.summary;
                previewHTML += `<div class="parsed-item"><span class="parsed-label">Description:</span> <span class="parsed-value">${desc}</span></div>`;
            }
            
            // Generate and display Google Maps URL
            let googleMapsUrl = '';
            let coordinates = null;
            
            if (parsed.address) {
                try {
                    previewHTML += `<div class="parsed-item"><span class="parsed-label">Status:</span> <span class="parsed-value">🔍 Getting coordinates...</span></div>`;
                    previewContainer.innerHTML = previewHTML;
                    previewContainer.style.display = 'block';
                    
                    // Get coordinates and generate maps URL in one call
                    coordinates = await getCoordinatesFromAddress(parsed.address);
                    
                    if (coordinates) {
                        // Generate Google Maps URL from coordinates (faster)
                        googleMapsUrl = `https://www.google.com/maps/dir/?api=1&destination=${coordinates.latitude},${coordinates.longitude}`;
                        
                        previewHTML = previewHTML.replace('🔍 Getting coordinates...', '✅ Coordinates found!');
                        previewHTML += `<div class="parsed-item"><span class="parsed-label">Coordinates:</span> <span class="parsed-value">${coordinates.latitude}, ${coordinates.longitude}</span></div>`;
                        previewHTML += `<div class="parsed-item"><span class="parsed-label">Maps URL:</span> <span class="parsed-value"><a href="${googleMapsUrl}" target="_blank">${googleMapsUrl}</a></span></div>`;
                        
                        // Also show in the main URL display
                        const urlDisplay = document.getElementById('generatedUrlDisplay');
                        const urlLink = document.getElementById('generatedUrlLink');
                        if (urlDisplay && urlLink) {
                            urlLink.href = googleMapsUrl;
                            urlLink.textContent = googleMapsUrl;
                            urlDisplay.style.display = 'block';
                        }
                    } else {
                        // Fallback: generate URL from address
                        googleMapsUrl = `https://www.google.com/maps/search/?api=1&query=${encodeURIComponent(parsed.address)}`;
                        previewHTML = previewHTML.replace('🔍 Getting coordinates...', '⚠️ Using address search');
                        previewHTML += `<div class="parsed-item"><span class="parsed-label">Maps URL:</span> <span class="parsed-value"><a href="${googleMapsUrl}" target="_blank">${googleMapsUrl}</a></span></div>`;
                    }
                } catch (error) {
                    console.error('Error processing address:', error);
                    previewHTML = previewHTML.replace('🔍 Getting coordinates...', '❌ Could not get coordinates');
                }
            }
            
            // Auto-populate form fields
            await populateFormFromParsedData(parsed, coordinates, googleMapsUrl);
            
            previewContainer.innerHTML = previewHTML;
            previewContainer.style.display = 'block';
            quickAddBtn.style.display = 'inline-block';
        }

        async function getCoordinatesFromAddress(address) {
            try {
                const response = await fetch('/api/geocode-address', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ address: address })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    if (data.success) {
                        return {
                            latitude: data.latitude,
                            longitude: data.longitude
                        };
                    }
                }
            } catch (error) {
                console.error('Error getting coordinates:', error);
            }
            return null;
        }

        async function populateFormFromParsedData(parsed, coordinates, googleMapsUrl) {
            // Populate form fields with parsed data
            if (parsed.businessName) {
                document.getElementById('recName').value = parsed.businessName;
            }
            
            if (parsed.address) {
                document.getElementById('recAddress').value = parsed.address;
            }
            
            if (coordinates) {
                document.getElementById('recLatitude').value = coordinates.latitude;
                document.getElementById('recLongitude').value = coordinates.longitude;
            }
            
            // Set rating if provided by Gemini
            if (parsed.rating) {
                document.getElementById('recRating').value = parsed.rating;
            } else {
                document.getElementById('recRating').value = '4.0';
            }
            
            // Create comprehensive description from Gemini data
            let description = '';
            if (parsed.description) {
                description = parsed.description;
            } else if (parsed.summary) {
                description = parsed.summary;
            } else {
                description = `${parsed.businessName || 'Restaurant'}`;
            }
            
            // Add additional details to description
            const details = [];
            if (parsed.category && parsed.category !== 'restaurant') {
                details.push(`Category: ${parsed.category}`);
            }
            if (parsed.hours) details.push(`Hours: ${parsed.hours}`);
            if (parsed.priceRange || parsed.prices) {
                const price = parsed.priceRange || parsed.prices;
                details.push(`Price Range: ${price}`);
            }
            if (parsed.menuItems || parsed.foodItems) {
                const menu = parsed.menuItems || parsed.foodItems;
                details.push(`Menu: ${menu}`);
            }
            if (parsed.phone) details.push(`Phone: ${parsed.phone}`);
            if (parsed.website) details.push(`Website: ${parsed.website}`);
            
            if (details.length > 0) {
                description += (description ? '\n\n' : '') + details.join('\n');
            }
            
            document.getElementById('recDescription').value = description;
            
            // Populate Google Maps URL field
            if (googleMapsUrl) {
                document.getElementById('googleMapsUrl').value = googleMapsUrl;
            }
        }

        async function generateGoogleMapsUrl(address) {
            if (!address) return '';
            
            try {
                // Use the existing geocoding endpoint to get coordinates
                const response = await fetch('/api/geocode-address', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ address: address })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    if (data.success) {
                        // Generate Google Maps URL with directions (more useful for navigation)
                        return `https://www.google.com/maps/dir/?api=1&destination=${data.latitude},${data.longitude}&destination_place_id=${encodeURIComponent(data.address)}`;
                    }
                }
            } catch (error) {
                console.error('Error generating Google Maps URL:', error);
            }
            
            // Fallback: generate directions URL from address
            return `https://www.google.com/maps/dir/?api=1&destination=${encodeURIComponent(address)}`;
        }

        // Extract address from address image using Gemini AI OCR
        async function extractAddressFromAddressImage(imageId, imageDataUrl) {
            const button = document.querySelector(`[data-image-id="${imageId}"] .address-extract-btn`);
            const originalText = button.textContent;
            
            try {
                button.textContent = '🔍 Extracting...';
                button.disabled = true;
                
                console.log('📸 Extracting address from address image:', imageId);
                
                button.textContent = '🤖 AI Processing...';
                
                // Use Gemini AI for OCR (Server-side OCR)
                const response = await fetch('/api/extract-address', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        imageData: imageDataUrl
                    })
                });
                
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || 'Failed to extract address');
                }
                
                const result = await response.json();
                console.log('📝 Gemini AI result:', result);
                
                if (!result.success || !result.data) {
                    throw new Error('No data extracted from image');
                }
                
                const extractedData = result.data;
                console.log('📍 Extracted data:', extractedData);
                
                // Use business name as fallback if address not found
                const detectedAddress = extractedData.address || extractedData.businessName;
                
                if (!detectedAddress) {
                    throw new Error('No address or business name found in image');
                }
                
                button.textContent = '📍 Generating map...';
                
                // Generate Google Maps URL
                const googleMapsUrl = await generateGoogleMapsUrl(detectedAddress);
                
                // Get coordinates for the address
                let coordinates = null;
                try {
                    coordinates = await getCoordinatesFromAddress(detectedAddress);
                } catch (error) {
                    console.warn('Could not get coordinates for address:', error);
                }
                
                // Store extracted address data with enhanced information
                extractedAddressData = {
                    address: detectedAddress,
                    businessName: extractedData.businessName,
                    phone: extractedData.phone,
                    website: extractedData.website,
                    description: extractedData.description,
                    googleMapsUrl: googleMapsUrl,
                    coordinates: coordinates,
                    extractedText: extractedData.allText
                };
                
                // Display extracted address
                displayExtractedAddress(extractedAddressData);
                
                // Auto-populate form if business name is available
                if (extractedData.businessName) {
                    document.getElementById('recName').value = extractedData.businessName;
                }
                
                button.textContent = '✅ Address extracted!';
                button.style.background = 'rgba(40, 167, 69, 0.9)';
                
                setTimeout(() => {
                    button.textContent = originalText;
                    button.style.background = 'rgba(255, 152, 0, 0.9)';
                    button.disabled = false;
                }, 3000);
                
            } catch (error) {
                console.error('❌ Error extracting address:', error);
                
                button.textContent = '❌ Failed';
                button.style.background = 'rgba(220, 53, 69, 0.9)';
                
                alert(`❌ Could not extract address from image.\n\nError: ${error.message}\n\nPlease try:\n1. Using a clearer image\n2. Ensuring the address is visible and not obscured\n3. Manually entering the address`);
                
                setTimeout(() => {
                    button.textContent = originalText;
                    button.style.background = 'rgba(255, 152, 0, 0.9)';
                    button.disabled = false;
                }, 3000);
            }
        }

        function displayExtractedAddress(addressData) {
            const extractedDisplay = document.getElementById('extractedAddressDisplay');
            const extractedText = document.getElementById('extractedAddressText');
            
            extractedText.innerHTML = `
                ${addressData.businessName ? `<strong>Business Name:</strong> ${addressData.businessName}<br>` : ''}
                <strong>Address:</strong> ${addressData.address}<br>
                ${addressData.phone ? `<strong>Phone:</strong> ${addressData.phone}<br>` : ''}
                ${addressData.website ? `<strong>Website:</strong> ${addressData.website}<br>` : ''}
                <strong>Google Maps URL:</strong> <a href="${addressData.googleMapsUrl}" target="_blank">${addressData.googleMapsUrl}</a><br>
                ${addressData.coordinates ? `<strong>Coordinates:</strong> ${addressData.coordinates.latitude}, ${addressData.coordinates.longitude}<br>` : ''}
                ${addressData.description ? `<br><strong>Description:</strong> ${addressData.description}<br>` : ''}
                <br>
                <strong>Full extracted text:</strong><br>
                ${addressData.extractedText ? addressData.extractedText.replace(/\n/g, '<br>') : 'No text extracted'}
            `;
            
            extractedDisplay.style.display = 'block';
        }

        function populateFormWithAddress(addressData) {
            // Auto-populate the business name field
            if (addressData.businessName) {
                document.getElementById('recName').value = addressData.businessName;
            }
            
            // Auto-populate the address field
            document.getElementById('recAddress').value = addressData.address;
            
            // Auto-populate the Google Maps URL field
            if (addressData.googleMapsUrl) {
                document.getElementById('googleMapsUrl').value = addressData.googleMapsUrl;
                
                // Show the generated URL
                const urlDisplay = document.getElementById('generatedUrlDisplay');
                const urlLink = document.getElementById('generatedUrlLink');
                if (urlDisplay && urlLink) {
                    urlLink.href = addressData.googleMapsUrl;
                    urlLink.textContent = addressData.googleMapsUrl;
                    urlDisplay.style.display = 'block';
                }
            }
            
            // Auto-populate coordinates
            if (addressData.coordinates) {
                document.getElementById('recLatitude').value = addressData.coordinates.latitude;
                document.getElementById('recLongitude').value = addressData.coordinates.longitude;
            }
            
            // Show success message
            const businessInfo = addressData.businessName ? `\nBusiness: ${addressData.businessName}` : '';
            alert(`📍 Address information populated successfully!${businessInfo}\n\nAddress: ${addressData.address}\n\nAll form fields have been filled. You can now submit the recommendation.`);
        }

        // Extract address from image using OCR
        async function extractAddressFromImage(imageId, imageDataUrl) {
            const button = document.querySelector(`[data-image-id="${imageId}"] .image-extract-address`);
            const originalText = button.textContent;
            
            try {
                button.textContent = '🔍 Extracting...';
                button.disabled = true;
                
                console.log('📸 Extracting address from image:', imageId);
                
                // Use Tesseract.js for OCR (Client-side OCR)
                if (typeof Tesseract === 'undefined') {
                    // Load Tesseract.js dynamically
                    const script = document.createElement('script');
                    script.src = 'https://cdn.jsdelivr.net/npm/tesseract.js@2.1.5/dist/tesseract.min.js';
                    document.head.appendChild(script);
                    
                    // Wait for library to load
                    await new Promise((resolve) => {
                        script.onload = resolve;
                    });
                }
                
                button.textContent = '🔍 Reading text...';
                
                // Extract text from image
                const result = await Tesseract.recognize(imageDataUrl, 'eng+vie', {
                    logger: m => console.log('OCR:', m)
                });
                
                const extractedText = result.data.text;
                console.log('📝 Extracted text:', extractedText);
                
                if (!extractedText || extractedText.trim().length === 0) {
                    throw new Error('No text found in image');
                }
                
                button.textContent = '🔍 Finding address...';
                
                // Try to find address patterns in the extracted text
                const addressPatterns = [
                    // Vietnamese address patterns
                    /\d+[\/\-]?\d*\s+[^,\n]+,\s*[^,\n]+/gi,
                    // Street number + street name
                    /\d+\s+[A-Za-z\s]+\s+(Street|St|Road|Rd|Avenue|Ave|Lane|Ln|Boulevard|Blvd|Drive|Dr|Way|Phố|Đường|phố|đường)/gi,
                    // Any line with numbers and common address keywords
                    /.*\d+.*(?:Street|St|Road|Rd|Avenue|Ave|Phố|Đường|phố|đường).*$/gmi,
                    // Generic patterns for addresses
                    /\d+[A-Za-z]?\s+[^,\n]+(?:,\s*[^,\n]+)*/gi
                ];
                
                let detectedAddress = null;
                
                for (const pattern of addressPatterns) {
                    const matches = extractedText.match(pattern);
                    if (matches && matches.length > 0) {
                        // Take the first match and clean it up
                        detectedAddress = matches[0].trim().replace(/\s+/g, ' ');
                        break;
                    }
                }
                
                if (!detectedAddress) {
                    // Fallback: look for any line with numbers (potential address)
                    const lines = extractedText.split('\n').filter(line => line.trim().length > 0);
                    for (const line of lines) {
                        if (/\d+/.test(line) && line.length > 5) {
                            detectedAddress = line.trim();
                            break;
                        }
                    }
                }
                
                if (!detectedAddress) {
                    throw new Error('No address pattern found in extracted text');
                }
                
                console.log('📍 Detected address:', detectedAddress);
                
                button.textContent = '📍 Generating map...';
                
                // Generate Google Maps URL
                const googleMapsUrl = await generateGoogleMapsUrl(detectedAddress);
                
                // Auto-populate the address field
                document.getElementById('recAddress').value = detectedAddress;
                
                // Auto-populate the Google Maps URL field
                if (googleMapsUrl) {
                    document.getElementById('googleMapsUrl').value = googleMapsUrl;
                    
                    // Show the generated URL
                    const urlDisplay = document.getElementById('generatedUrlDisplay');
                    const urlLink = document.getElementById('generatedUrlLink');
                    urlLink.href = googleMapsUrl;
                    urlLink.textContent = googleMapsUrl;
                    urlDisplay.style.display = 'block';
                }
                
                // Try to get coordinates for the address
                try {
                    const coordinates = await getCoordinatesFromAddress(detectedAddress);
                    if (coordinates) {
                        document.getElementById('recLatitude').value = coordinates.latitude;
                        document.getElementById('recLongitude').value = coordinates.longitude;
                    }
                } catch (error) {
                    console.warn('Could not get coordinates for address:', error);
                }
                
                button.textContent = '✅ Address extracted!';
                button.style.background = 'rgba(40, 167, 69, 0.9)';
                
                // Show success message
                alert(`📍 Address extracted successfully!\n\nAddress: ${detectedAddress}\n\nThe address has been automatically filled in the form. You can now submit the recommendation.`);
                
                setTimeout(() => {
                    button.textContent = originalText;
                    button.style.background = 'rgba(0, 123, 255, 0.9)';
                    button.disabled = false;
                }, 3000);
                
            } catch (error) {
                console.error('❌ Error extracting address:', error);
                
                button.textContent = '❌ Failed';
                button.style.background = 'rgba(220, 53, 69, 0.9)';
                
                alert(`❌ Could not extract address from image.\n\nError: ${error.message}\n\nPlease try:\n1. Using a clearer image\n2. Ensuring the address is visible and not obscured\n3. Manually entering the address`);
                
                setTimeout(() => {
                    button.textContent = originalText;
                    button.style.background = 'rgba(0, 123, 255, 0.9)';
                    button.disabled = false;
                }, 3000);
            }
        }

        async function quickAddRecommendation() {
            if (!parsedData) {
                alert('Please parse content first');
                return;
            }
            
            // Prevent duplicate submissions
            if (isSubmitting) {
                console.log('⚠️ Submission already in progress, ignoring quick add request');
                return;
            }
            
            const quickAddBtn = document.getElementById('quickAddBtn');
            isSubmitting = true;
            quickAddBtn.disabled = true;
            quickAddBtn.innerHTML = '<span style="display: inline-block; animation: spin 1s linear infinite;">⏳</span> Adding...';
            
            try {
                // Generate Google Maps URL
                const googleMapsUrl = await generateGoogleMapsUrl(parsedData.address);
                
                // Create description from parsed data
                let description = '';
                if (parsedData.summary) {
                    description = parsedData.summary;
                } else {
                    description = `${parsedData.businessName || 'Restaurant'}`;
                    if (parsedData.hours) description += `. Hours: ${parsedData.hours}`;
                    if (parsedData.prices) description += `. Prices: ${parsedData.prices}`;
                    if (parsedData.foodItems) description += `. Menu: ${parsedData.foodItems}`;
                }
                
                // Try to extract coordinates from the generated URL
                if (googleMapsUrl.includes('query=') && googleMapsUrl.includes(',')) {
                    const coords = googleMapsUrl.split('query=')[1].split(',');
                    if (coords.length >= 2) {
                        const lat = parseFloat(coords[0]);
                        const lng = parseFloat(coords[1]);
                        
                        if (!isNaN(lat) && !isNaN(lng)) {
                            const recommendation = {
                                name: parsedData.businessName || 'Parsed Location',
                                address: parsedData.address || 'Address not provided',
                                latitude: lat,
                                longitude: lng,
                                rating: 0,
                                description: description,
                                websiteUri: '',
                                featured: false,
                                images: uploadedImages.map(img => ({
                                    id: img.id,
                                    name: img.name,
                                    dataUrl: img.dataUrl
                                })),
                                parsedData: {
                                    prices: parsedData.prices || '',
                                    hours: parsedData.hours || '',
                                    foodItems: parsedData.foodItems || '',
                                    googleMapsUrl: googleMapsUrl
                                }
                            };
                            
                            // Submit the recommendation
                            const response = await fetch('/api/recommendations', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json'
                                },
                                body: JSON.stringify(recommendation)
                            });
                            
                            const result = await response.json();
                            
                            if (response.ok && result.success) {
                                alert(`✅ Successfully added: ${recommendation.name}`);
                                
                                // Update the display
                                if (!allPlaces.recommend) {
                                    allPlaces.recommend = [];
                                }
                                
                                const distance = Math.round(calculateDistance(
                                    HOTEL_LOCATION.lat, HOTEL_LOCATION.lng,
                                    recommendation.latitude, recommendation.longitude
                                ));
                                
                                const newRec = {
                                    ...result.recommendation,
                                    distance: distance
                                };
                                
                                allPlaces.recommend.push(newRec);
                                allPlaces.recommend.sort((a, b) => a.distance - b.distance);
                                
                                // Update displays
                                updateMapMarkers();
                                updateStats();
                                updatePlacesList();
                                
                                // Hide admin panel and clear form
                                document.getElementById('adminPanel').style.display = 'none';
                                document.getElementById('adminBackdrop').classList.remove('show');
                                document.body.style.overflow = 'auto';
                                document.getElementById('addRecommendationForm').reset();
                                clearImagePreviews();
                                
                                // Clear parsed content
                                parsedData = null;
                                document.getElementById('parsedContentPreview').style.display = 'none';
                                document.getElementById('quickAddBtn').style.display = 'none';
                                document.getElementById('structuredContent').value = '';
                                
                            } else {
                                alert(`❌ Failed to add recommendation: ${result.error || 'Unknown error'}`);
                            }
                        } else {
                            alert('❌ Could not extract valid coordinates from address');
                        }
                    } else {
                        alert('❌ Could not extract coordinates from address');
                    }
                } else {
                    alert('❌ Could not generate valid Google Maps URL');
                }
                
            } catch (error) {
                console.error('Error in quick add:', error);
                alert('❌ Error adding recommendation: ' + error.message);
            } finally {
                isSubmitting = false;
                quickAddBtn.disabled = false;
                quickAddBtn.innerHTML = 'Quick Add Recommendation';
            }
        }

        // Event listeners for structured content
        document.addEventListener('DOMContentLoaded', function() {
            document.getElementById('parseContentBtn').addEventListener('click', async function() {
                const content = document.getElementById('structuredContent').value.trim();
                if (!content) {
                    alert('Please paste some content first');
                    return;
                }
                
                const parseBtn = this;
                parseBtn.disabled = true;
                parseBtn.textContent = '🤖 AI Parsing...';
                
                try {
                    // Use Gemini AI to parse any format of content
                    const response = await fetch('/api/parse-content', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            content: content
                        })
                    });
                    
                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.error || 'Failed to parse content');
                    }
                    
                    const result = await response.json();
                    console.log('📝 Gemini parsing result:', result);
                    
                    if (!result.success || !result.data) {
                        throw new Error('No data extracted from content');
                    }
                    
                    // Convert Gemini response to our parsedData format
                    parsedData = {
                        businessName: result.data.placeName,
                        address: result.data.address,
                        description: result.data.description,
                        priceRange: result.data.priceRange,
                        hours: result.data.hours,
                        menuItems: result.data.menuItems,
                        rating: result.data.rating,
                        phone: result.data.phone,
                        website: result.data.website,
                        category: result.data.category,
                        keywords: result.data.keywords
                    };
                    
                    await displayParsedContent(parsedData);
                    
                } catch (error) {
                    console.error('Error parsing content:', error);
                    alert('Error parsing content: ' + error.message);
                } finally {
                    parseBtn.disabled = false;
                    parseBtn.textContent = 'Parse Content';
                }
            });
            
            document.getElementById('quickAddBtn').addEventListener('click', quickAddRecommendation);
            
            // Smart auto-loading - only for real user visits, not health checks
            const isHealthCheck = navigator.userAgent.includes('health') || 
                                 document.referrer.includes('health') ||
                                 window.location.pathname.includes('health') ||
                                 navigator.userAgent.includes('bot') ||
                                 navigator.userAgent.includes('crawler');
            
            if (!isHealthCheck) {
                console.log('🚀 Real user visit detected, auto-loading places...');
                
                // Add visual feedback for auto-loading
                const loadingIndicator = document.createElement('div');
                loadingIndicator.id = 'autoLoadingIndicator';
                loadingIndicator.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: #4CAF50;
                    color: white;
                    padding: 10px 15px;
                    border-radius: 5px;
                    z-index: 9999;
                    font-size: 14px;
                    box-shadow: 0 2px 10px rgba(0,0,0,0.2);
                `;
                loadingIndicator.innerHTML = '🔄 Auto-loading recommendations...';
                document.body.appendChild(loadingIndicator);
                
                loadPlaces().then(() => {
                    console.log('✅ Auto-loading completed successfully');
                    loadingIndicator.innerHTML = '✅ Recommendations loaded!';
                    setTimeout(() => {
                        loadingIndicator.remove();
                    }, 2000);
                }).catch(error => {
                    console.error('❌ Auto-loading failed:', error);
                    loadingIndicator.innerHTML = '❌ Loading failed';
                    loadingIndicator.style.background = '#f44336';
                    setTimeout(() => {
                        loadingIndicator.remove();
                    }, 3000);
                });
            } else {
                console.log('🤖 Health check or bot detected, skipping auto-load to prevent rate limits');
            }
        });

        // Global variable to track current search
        let currentSearchFilter = null;

        // Gemini AI Search Functions
        async function geminiSearch() {
            const searchInput = document.getElementById('geminiSearchInput');
            const searchBtn = document.getElementById('geminiSearchBtn');
            const searchStatus = document.getElementById('searchStatus');
            const clearBtn = document.querySelector('.clear-search');
            
            const query = searchInput.value.trim();
            if (!query) {
                alert('Please enter something to search for!');
                return;
            }

            console.log('🔮 Starting Gemini search for:', query);

            // Update UI to show loading
            searchBtn.disabled = true;
            searchBtn.innerHTML = '🔄 Searching...';
            searchStatus.className = 'search-status loading';
            searchStatus.style.display = 'block';
            searchStatus.innerHTML = '🤖 AI is analyzing your search and filtering places...';

            try {
                const response = await fetch('/api/gemini-search', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        query: query,
                        places: allPlaces,
                        location: HOTEL_LOCATION
                    })
                });

                const result = await response.json();
                console.log('🔮 Gemini search result:', result);

                if (result.success) {
                    const totalResults = Object.values(result.filteredPlaces).flat().length;
                    
                    // If Gemini found very few or no results, try fallback search
                    if (totalResults === 0) {
                        console.log('⚠️ Gemini found no results, trying fallback search...');
                        const fallbackResults = performFallbackSearch(query);
                        
                        if (Object.values(fallbackResults).flat().length > 0) {
                            console.log('✅ Fallback search found results');
                            currentSearchFilter = {
                                query: query,
                                filteredPlaces: fallbackResults,
                                categories: Object.keys(fallbackResults).filter(key => fallbackResults[key].length > 0)
                            };
                            applySearchFilter(fallbackResults, query);
                            searchStatus.className = 'search-status success';
                            searchStatus.innerHTML = `✅ Found ${Object.values(fallbackResults).flat().length} places matching "${query}" (local search)`;
                            clearBtn.style.display = 'inline-block';
                            return;
                        }
                    }
                    
                    // Store current search filter
                    currentSearchFilter = {
                        query: query,
                        filteredPlaces: result.filteredPlaces,
                        categories: result.categories || []
                    };

                    // Apply the filter to display
                    applySearchFilter(result.filteredPlaces, query);

                    // Update UI
                    searchStatus.className = 'search-status success';
                    searchStatus.innerHTML = `✅ Found ${totalResults} places matching "${query}"`;
                    clearBtn.style.display = 'inline-block';

                    console.log(`✅ Search complete: ${totalResults} places found`);
                } else {
                    throw new Error(result.error || 'Search failed');
                }
            } catch (error) {
                console.error('❌ Gemini search error:', error);
                
                // Try fallback search when Gemini fails
                console.log('⚠️ Gemini search failed, trying fallback search...');
                try {
                    const fallbackResults = performFallbackSearch(query);
                    const totalFallback = Object.values(fallbackResults).flat().length;
                    
                    if (totalFallback > 0) {
                        console.log('✅ Fallback search found results after Gemini failure');
                        currentSearchFilter = {
                            query: query,
                            filteredPlaces: fallbackResults,
                            categories: Object.keys(fallbackResults).filter(key => fallbackResults[key].length > 0)
                        };
                        applySearchFilter(fallbackResults, query);
                        searchStatus.className = 'search-status success';
                        searchStatus.innerHTML = `✅ Found ${totalFallback} places matching "${query}" (offline search)`;
                        clearBtn.style.display = 'inline-block';
                        return;
                    }
                } catch (fallbackError) {
                    console.error('❌ Fallback search also failed:', fallbackError);
                }
                
                searchStatus.className = 'search-status error';
                searchStatus.innerHTML = `❌ Search failed: ${error.message}. Try different keywords.`;
            } finally {
                // Reset button
                searchBtn.disabled = false;
                searchBtn.innerHTML = '🤖 Search with AI';
            }
        }

        function quickSearch(term) {
            document.getElementById('geminiSearchInput').value = term;
            geminiSearch();
        }

        function clearSearch() {
            console.log('🧹 Clearing search filter');
            console.log('📊 Before clear - currentSearchFilter:', currentSearchFilter);
            console.log('📊 Before clear - allPlaces count:', Object.keys(allPlaces));
            console.log('📊 Before clear - activeCategories:', Array.from(activeCategories));
            
            // Reset search filter
            currentSearchFilter = null;
            
            // Hide search results table
            hideSearchResultsTable();
            
            // Clear input and status
            const searchInput = document.getElementById('geminiSearchInput');
            const searchStatus = document.getElementById('searchStatus');
            const clearBtn = document.getElementById('clearSearchBtn');
            
            if (searchInput) searchInput.value = '';
            if (searchStatus) searchStatus.style.display = 'none';
            if (clearBtn) clearBtn.style.display = 'none';

            // Ensure at least recommend category is active if no categories are selected
            if (activeCategories.size === 0) {
                console.log('⚠️ No active categories after search clear, activating recommend');
                activeCategories.add('recommend');
                
                // Update the UI to show recommend as selected
                const recommendTab = document.querySelector('[data-category="recommend"]');
                if (recommendTab) {
                    recommendTab.classList.add('active');
                    console.log('✅ Activated recommend category in UI');
                }
            }

            // Restore original places data from backup
            console.log('🔄 Restoring original places display from backup...');
            console.log('📊 After clear - activeCategories:', Array.from(activeCategories));
            console.log('📊 Backup available:', Object.keys(originalPlacesBackup).length > 0);
            
            if (Object.keys(originalPlacesBackup).length > 0) {
                // Restore from backup
                allPlaces = JSON.parse(JSON.stringify(originalPlacesBackup)); // Deep copy back
                originalPlacesBackup = {}; // Clear backup to allow fresh backup on next search
                console.log('✅ Restored original places data from backup');
                console.log('📊 Restored allPlaces content:', Object.entries(allPlaces).map(([key, places]) => `${key}: ${places?.length || 0} places`));
            } else {
                console.log('⚠️ No backup available, initializing empty state');
                // Initialize empty state if no backup exists
                allPlaces = {
                    restaurants: [],
                    landmarks: [],
                    coffee: [],
                    culture: [],
                    recommend: []
                };
            }
            
            try {
                updateMapMarkers();
                updateStats();
                updatePlacesList();
                console.log('✅ Search cleared successfully, showing all places');
            } catch (error) {
                console.error('❌ Error during clear search:', error);
                console.log('🔧 Attempting individual function calls...');
                
                // Try each function individually to isolate the issue
                try {
                    console.log('🔧 Trying updateMapMarkers...');
                    updateMapMarkers();
                } catch (e) { console.error('❌ updateMapMarkers failed:', e); }
                
                try {
                    console.log('🔧 Trying updateStats...');
                    updateStats();
                } catch (e) { console.error('❌ updateStats failed:', e); }
                
                try {
                    console.log('🔧 Trying updatePlacesList...');
                    updatePlacesList();
                } catch (e) { console.error('❌ updatePlacesList failed:', e); }
                
                // If restoration fails, try reloading data instead of full page reload
                if (activeCategories.size === 0) {
                    console.log('🔄 Attempting to reload places data...');
                    try {
                        loadPlaces(); // Try reloading data instead of full page
                    } catch (loadError) {
                        console.error('❌ Data reload failed, force reloading page as last resort...');
                        location.reload();
                    }
                }
            }
        }

        // Local fallback search function
        function performFallbackSearch(query) {
            console.log('🔍 Performing local fallback search for:', query);
            const searchTerm = query.toLowerCase().trim();
            const fallbackResults = {
                restaurants: [],
                landmarks: [],
                coffee: [],
                culture: [],
                recommend: []
            };

            // Define keyword mappings for better matching
            const keywordMappings = {
                'bread': ['bread', 'bakery', 'bake', 'pastry', 'breakfast', 'sandwich'],
                'coffee': ['coffee', 'cafe', 'espresso', 'latte', 'cappuccino'],
                'bakery': ['bakery', 'bread', 'cake', 'pastry', 'bake'],
                'tea': ['tea', 'bubble tea', 'milk tea', 'cafe'],
                'beer': ['beer', 'bar', 'pub', 'brewery', 'drink'],
                'pizza': ['pizza', 'italian', 'restaurant'],
                'burger': ['burger', 'american', 'fast food', 'grill'],
                'soup': ['soup', 'pho', 'broth', 'noodle'],
                'noodle': ['noodle', 'pho', 'bun', 'mien'],
                'rice': ['rice', 'com', 'fried rice', 'restaurant'],
                'chicken': ['chicken', 'ga', 'grill', 'fried'],
                'seafood': ['seafood', 'fish', 'shrimp', 'crab', 'ocean']
            };

            // Get search keywords
            let searchKeywords = [searchTerm];
            if (keywordMappings[searchTerm]) {
                searchKeywords = [...searchKeywords, ...keywordMappings[searchTerm]];
            }

            console.log('🎯 Search keywords:', searchKeywords);

            // Search through all categories
            Object.entries(allPlaces).forEach(([category, places]) => {
                if (!places || !Array.isArray(places)) return;

                places.forEach(place => {
                    let isMatch = false;
                    const placeText = `${place.name} ${place.address} ${place.description || ''}`.toLowerCase();

                    // Check if any search keyword matches
                    for (const keyword of searchKeywords) {
                        if (placeText.includes(keyword)) {
                            isMatch = true;
                            break;
                        }
                    }

                    // Also check place types
                    if (!isMatch && place.types && Array.isArray(place.types)) {
                        for (const type of place.types) {
                            for (const keyword of searchKeywords) {
                                if (type.toLowerCase().includes(keyword)) {
                                    isMatch = true;
                                    break;
                                }
                            }
                            if (isMatch) break;
                        }
                    }

                    if (isMatch) {
                        fallbackResults[category].push(place);
                        console.log(`✅ Local match found: ${place.name} in ${category}`);
                    }
                });
            });

            const totalFound = Object.values(fallbackResults).flat().length;
            console.log(`🔍 Local search complete: ${totalFound} places found`);

            return fallbackResults;
        }

        function applySearchFilter(filteredPlaces, query) {
            console.log('🎯 Applying search filter for:', query);
            console.log('📊 Filtered places:', filteredPlaces);

            // Create global backup before modifying allPlaces
            if (Object.keys(originalPlacesBackup).length === 0) {
                originalPlacesBackup = JSON.parse(JSON.stringify(allPlaces)); // Deep copy
                console.log('💾 Created backup of original places data');
            }
            
            // Clear all current places
            Object.keys(allPlaces).forEach(category => {
                allPlaces[category] = [];
            });

            // Add filtered places back
            Object.entries(filteredPlaces).forEach(([category, places]) => {
                if (places && places.length > 0) {
                    allPlaces[category] = places;
                }
            });

            // Show search results table by default
            showSearchResultsTable(query, filteredPlaces);

            // Update display
            updateMapMarkers();
            updateStats();
            updatePlacesList();

            console.log('🎯 Search filter applied successfully');
        }

        // Check if we should show search results instead of regular loading
        function isSearchActive() {
            return currentSearchFilter !== null;
        }

        // Enhanced updatePlacesList to handle search results
        function updatePlacesListWithSearch() {
            console.log('🔄 Updating places list, search active:', !!currentSearchFilter);
            console.log('📊 Current activeCategories:', Array.from(activeCategories));
            console.log('📊 AllPlaces keys:', Object.keys(allPlaces));
            console.log('📊 AllPlaces content:', Object.entries(allPlaces).map(([key, places]) => `${key}: ${places?.length || 0} places`));
            
            const placesList = document.getElementById('placesList');
            
            if (!placesList) {
                console.error('Places list container not found');
                return;
            }
            
            // Clear existing content
            placesList.innerHTML = '';
            
            // Collect all active places (either filtered or normal)
            let activePlaces = [];
            
            if (currentSearchFilter) {
                // Show search results with filtered data
                console.log('📋 Using search filtered places');
                
                // Add search info header
                const searchInfo = document.createElement('div');
                searchInfo.style.cssText = 'background: #e8f5e8; padding: 10px; margin-bottom: 10px; border-radius: 8px; border: 1px solid #a5d6a7; text-align: center; font-size: 0.9rem; color: #2e7d32;';
                searchInfo.innerHTML = `🔮 Showing AI-filtered results for "${currentSearchFilter.query}"`;
                placesList.appendChild(searchInfo);
                
                // Get filtered places for active categories
                activeCategories.forEach(category => {
                    if (currentSearchFilter.filteredPlaces[category] && currentSearchFilter.filteredPlaces[category].length > 0) {
                        currentSearchFilter.filteredPlaces[category].forEach(place => {
                            activePlaces.push({
                                ...place,
                                category: category
                            });
                        });
                    }
                });
            } else {
                // Show normal results
                console.log('📋 Using normal places');
                Object.entries(allPlaces).forEach(([category, places]) => {
                    if (activeCategories.has(category)) {
                        places.forEach(place => {
                            activePlaces.push({
                                ...place,
                                category: category
                            });
                        });
                    }
                });
            }
            
            console.log(`Found ${activePlaces.length} active places to display`);
            
            // Update place count and map info
            const placeCount = document.getElementById('placeCount');
            const mapInfo = document.getElementById('mapInfo');
            
            if (placeCount) {
                placeCount.textContent = `${activePlaces.length} place${activePlaces.length !== 1 ? 's' : ''}`;
            }
            
            if (mapInfo && activePlaces.length > 0) {
                const distances = activePlaces.map(place => place.distance);
                const minDistance = Math.min(...distances);
                const maxDistance = Math.max(...distances);
                mapInfo.textContent = `${minDistance}m - ${maxDistance}m from hotel`;
            } else if (mapInfo) {
                mapInfo.textContent = 'Visual distance reference';
            }
            
            if (activePlaces.length === 0) {
                let message;
                if (currentSearchFilter) {
                    message = 'No places found matching your search.';
                } else {
                    message = activeCategories.size === 0 
                        ? 'Select categories and click "Load" to see recommendations' 
                        : 'No places found. Try expanding your search radius or selecting different categories.';
                }
                
                placesList.innerHTML += `
                    <div class="no-places-message">
                        ${message}
                    </div>
                `;
                return;
            }
            
            // Sort places by distance
            activePlaces.sort((a, b) => a.distance - b.distance);
            
            // Create place items
            activePlaces.forEach((place, index) => {
                const placeItem = createPlaceListItem(place, index);
                placesList.appendChild(placeItem);
            });
        }

        // Edit Place Modal Functions
        let currentEditPlaceId = null;

        function showEditPlaceModal(placeId) {
            console.log('🔧 Opening edit modal for place ID:', placeId);
            
            // Find the place in search results or allPlaces
            let place = null;
            
            // First check if we're in search mode
            if (currentSearchFilter && currentSearchFilter.filteredPlaces) {
                console.log('🔍 Looking for place in search results for editing');
                for (const category in currentSearchFilter.filteredPlaces) {
                    if (currentSearchFilter.filteredPlaces[category]) {
                        const found = currentSearchFilter.filteredPlaces[category].find(p => p.id === placeId);
                        if (found) {
                            place = found;
                            console.log('✅ Found place in search results for editing:', place.name);
                            break;
                        }
                    }
                }
            }
            
            // If not found in search results, check normal places
            if (!place) {
                console.log('🔍 Looking for place in normal places for editing');
                for (const category in allPlaces) {
                    if (allPlaces[category]) {
                        const found = allPlaces[category].find(p => p.id === placeId);
                        if (found) {
                            place = found;
                            console.log('✅ Found place in normal places for editing:', place.name);
                            break;
                        }
                    }
                }
            }
            
            if (!place) {
                console.error('❌ Place not found for editing:', placeId);
                console.log('📊 Debug - Available places:', {
                    searchMode: !!currentSearchFilter,
                    searchPlaces: currentSearchFilter?.filteredPlaces,
                    normalPlaces: Object.keys(allPlaces)
                });
                return;
            }
            
            currentEditPlaceId = placeId;
            
            // Populate information display
            populateEditInfoDisplay(place);
            
            // Populate modal fields with current data
            document.getElementById('editPlaceName').value = place.name || '';
            document.getElementById('editPlaceAddress').value = place.address || '';
            
            // Handle opening hours - convert from various formats to display format
            let hoursText = '';
            if (place.openingHours) {
                if (typeof place.openingHours === 'string') {
                    hoursText = place.openingHours;
                } else if (place.openingHours.weekdayDescriptions) {
                    hoursText = place.openingHours.weekdayDescriptions.join('\n');
                } else if (Array.isArray(place.openingHours)) {
                    hoursText = place.openingHours.join('\n');
                }
            } else if (place.currentOpeningHours?.weekdayDescriptions) {
                hoursText = place.currentOpeningHours.weekdayDescriptions.join('\n');
            } else if (place.regularOpeningHours?.weekdayDescriptions) {
                hoursText = place.regularOpeningHours.weekdayDescriptions.join('\n');
            }
            
            document.getElementById('editOpeningHours').value = hoursText;
            
            // Show modal
            const modal = document.getElementById('editPlaceModal');
            modal.classList.add('show');
            
            // Focus input
            setTimeout(() => {
                document.getElementById('editPlaceName').focus();
            }, 300);
        }

        function populateEditInfoDisplay(place) {
            const editInfoContent = document.getElementById('editInfoContent');
            
            // Create comprehensive information display
            let infoHtml = '';
            
            // Basic information
            infoHtml += `<div class="edit-info-item"><strong>📍 Current Name:</strong> ${place.name}</div>`;
            infoHtml += `<div class="edit-info-item"><strong>🏠 Current Address:</strong> ${place.address}</div>`;
            
            // Rating and reviews
            if (place.rating > 0) {
                infoHtml += `<div class="edit-info-item"><strong>⭐ Rating:</strong> ${place.rating.toFixed(1)}/5`;
                if (place.userRatingCount > 0) {
                    infoHtml += ` (${place.userRatingCount} reviews)`;
                }
                infoHtml += `</div>`;
            }
            
            // Category and distance
            infoHtml += `<div class="edit-info-item"><strong>📂 Category:</strong> ${place.category}</div>`;
            infoHtml += `<div class="edit-info-item"><strong>📏 Distance:</strong> ${place.distance}m (${(place.distance * 0.000621371).toFixed(2)} mi)</div>`;
            
            // Google place types
            if (place.types && place.types.length > 0) {
                infoHtml += `<div class="edit-info-item"><strong>🏷️ Place Types:</strong> ${place.types.join(', ')}</div>`;
            }
            
            // Contact information
            if (place.nationalPhoneNumber || place.internationalPhoneNumber) {
                const phone = place.nationalPhoneNumber || place.internationalPhoneNumber;
                infoHtml += `<div class="edit-info-item"><strong>📞 Phone:</strong> ${phone}</div>`;
            }
            
            if (place.websiteUri) {
                infoHtml += `<div class="edit-info-item"><strong>🌐 Website:</strong> <a href="${place.websiteUri}" target="_blank">${place.websiteUri}</a></div>`;
            }
            
            // Business details
            if (place.priceLevel !== undefined && place.priceLevel > 0) {
                const priceLabels = ['', 'Inexpensive', 'Moderate', 'Expensive', 'Very Expensive'];
                infoHtml += `<div class="edit-info-item"><strong>💰 Price Level:</strong> ${'$'.repeat(place.priceLevel)} (${priceLabels[place.priceLevel]})</div>`;
            }
            
            if (place.businessStatus) {
                infoHtml += `<div class="edit-info-item"><strong>🏪 Business Status:</strong> ${place.businessStatus.replace(/_/g, ' ')}</div>`;
            }
            
            // Metadata for recommendations
            if (place.addedBy) {
                infoHtml += `<div class="edit-info-item"><strong>👤 Added By:</strong> ${place.addedBy.replace(/_/g, ' ')}</div>`;
            }
            
            if (place.addedDate) {
                infoHtml += `<div class="edit-info-item"><strong>📅 Added Date:</strong> ${new Date(place.addedDate).toLocaleDateString()}</div>`;
            }
            
            if (place.featured) {
                infoHtml += `<div class="edit-info-item"><strong>⭐ Status:</strong> Featured Location</div>`;
            }
            
            // Opening hours summary
            const compactHours = getCompactOpeningHours(place);
            if (compactHours) {
                infoHtml += `<div class="edit-info-item"><strong>🕒 Current Hours:</strong> ${compactHours}</div>`;
            }
            
            // Image count
            let imageCount = 0;
            if (place.images && place.images.length > 0) imageCount += place.images.length;
            if (place.photos && place.photos.length > 0) imageCount += place.photos.length;
            if (imageCount > 0) {
                infoHtml += `<div class="edit-info-item"><strong>📸 Images:</strong> ${imageCount} photo${imageCount !== 1 ? 's' : ''} available</div>`;
            }
            
            editInfoContent.innerHTML = infoHtml;
        }

        function closeEditModal() {
            const modal = document.getElementById('editPlaceModal');
            modal.classList.remove('show');
            currentEditPlaceId = null;
        }

        // Quick hours setting function
        function setQuickHours(type) {
            const hoursInput = document.getElementById('editOpeningHours');
            let hoursText = '';
            
            switch(type) {
                case '24/7':
                    hoursText = 'Monday: Open 24 hours\nTuesday: Open 24 hours\nWednesday: Open 24 hours\nThursday: Open 24 hours\nFriday: Open 24 hours\nSaturday: Open 24 hours\nSunday: Open 24 hours';
                    break;
                case '9-21':
                    hoursText = 'Monday: 9:00 AM – 9:00 PM\nTuesday: 9:00 AM – 9:00 PM\nWednesday: 9:00 AM – 9:00 PM\nThursday: 9:00 AM – 9:00 PM\nFriday: 9:00 AM – 9:00 PM\nSaturday: 9:00 AM – 9:00 PM\nSunday: 9:00 AM – 9:00 PM';
                    break;
                case '6-22':
                    hoursText = 'Monday: 6:00 AM – 10:00 PM\nTuesday: 6:00 AM – 10:00 PM\nWednesday: 6:00 AM – 10:00 PM\nThursday: 6:00 AM – 10:00 PM\nFriday: 6:00 AM – 10:00 PM\nSaturday: 6:00 AM – 10:00 PM\nSunday: 6:00 AM – 10:00 PM';
                    break;
                case '8-18':
                    hoursText = 'Monday: 8:00 AM – 6:00 PM\nTuesday: 8:00 AM – 6:00 PM\nWednesday: 8:00 AM – 6:00 PM\nThursday: 8:00 AM – 6:00 PM\nFriday: 8:00 AM – 6:00 PM\nSaturday: 8:00 AM – 6:00 PM\nSunday: 8:00 AM – 6:00 PM';
                    break;
            }
            
            hoursInput.value = hoursText;
            hoursInput.focus();
        }

        async function autoParseWithGemini() {
            const currentNameElement = document.getElementById('currentPlaceName');
            const newNameInput = document.getElementById('editPlaceName');
            const parseBtn = document.getElementById('autoParseBtn');
            
            const currentName = currentNameElement.textContent;
            
            if (!currentName) {
                alert('No place name found to parse');
                return;
            }
            
            // Show loading state
            parseBtn.disabled = true;
            parseBtn.textContent = '🤖 Parsing...';
            
            try {
                console.log('🔮 Sending auto-parse request for:', currentName);
                
                const response = await fetch('/api/gemini-parse-dish', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        placeName: currentName
                    })
                });
                
                const result = await response.json();
                console.log('📋 Gemini parse result:', result);
                
                if (result.success && result.dishName) {
                    newNameInput.value = result.dishName;
                    newNameInput.focus();
                    console.log('✅ Auto-parsed dish name:', result.dishName);
                } else {
                    console.warn('⚠️ No dish name extracted, using fallback');
                    // Try simple extraction as fallback
                    const simpleParsed = extractDishNameFallback(currentName);
                    newNameInput.value = simpleParsed;
                    newNameInput.focus();
                }
                
            } catch (error) {
                console.error('❌ Auto-parse failed:', error);
                // Fallback to simple extraction
                const simpleParsed = extractDishNameFallback(currentName);
                newNameInput.value = simpleParsed;
                newNameInput.focus();
            } finally {
                parseBtn.disabled = false;
                parseBtn.textContent = '🤖 Auto-Parse with Gemini';
            }
        }

        function extractDishNameFallback(placeName) {
            // Simple fallback extraction logic for Vietnamese dishes
            const dishPatterns = [
                /(?:quán|nhà hàng|cửa hàng)\s*([^,\-\(\[\{]+)/i,
                /([^,\-\(\[\{]*(?:phở|bún|bánh|cơm|gỏi|chả|nem|xôi|chè)[^,\-\)\]\}]*)/i,
                /([^,\-\(\[\{]*(?:gà|bò|heo|tôm|cá|thịt)[^,\-\)\]\}]*)/i
            ];
            
            for (const pattern of dishPatterns) {
                const match = placeName.match(pattern);
                if (match && match[1]) {
                    return match[1].trim();
                }
            }
            
            // If no patterns match, return the first part before common separators
            const parts = placeName.split(/[,\-\(\[\{]/);
            return parts[0].trim();
        }

        async function saveEditedPlace() {
            const newName = document.getElementById('editPlaceName').value.trim();
            const newAddress = document.getElementById('editPlaceAddress').value.trim();
            const newHours = document.getElementById('editOpeningHours').value.trim();
            const saveBtn = document.getElementById('saveEditBtn');
            
            if (!newName) {
                alert('Please enter a place name');
                return;
            }
            
            if (!currentEditPlaceId) {
                console.error('❌ No place ID for editing');
                return;
            }
            
            // Show loading state
            saveBtn.disabled = true;
            saveBtn.textContent = 'Saving All Changes...';
            
            try {
                // Find and update the place in allPlaces
                let updated = false;
                for (const category in allPlaces) {
                    const placeIndex = allPlaces[category].findIndex(p => p.id === currentEditPlaceId);
                    if (placeIndex !== -1) {
                        const place = allPlaces[category][placeIndex];
                        const oldName = place.name;
                        const oldAddress = place.address;
                        
                        // Update all fields
                        place.name = newName;
                        place.address = newAddress;
                        
                        // Update opening hours in a structured format
                        if (newHours) {
                            place.openingHours = {
                                weekdayDescriptions: newHours.split('\n').filter(line => line.trim())
                            };
                            place.currentOpeningHours = place.openingHours;
                            place.regularOpeningHours = place.openingHours;
                        } else {
                            place.openingHours = null;
                            place.currentOpeningHours = null;
                            place.regularOpeningHours = null;
                        }
                        
                        console.log(`✅ Updated place in allPlaces:
                            Name: "${oldName}" → "${newName}"
                            Address: "${oldAddress}" → "${newAddress}"
                            Hours: ${newHours ? 'Updated' : 'Cleared'}`);
                        updated = true;
                        break;
                    }
                }
                
                // Also update in search results if we're in search mode
                if (currentSearchFilter && currentSearchFilter.filteredPlaces) {
                    console.log('🔍 Also updating place in search results...');
                    for (const category in currentSearchFilter.filteredPlaces) {
                        if (currentSearchFilter.filteredPlaces[category]) {
                            const placeIndex = currentSearchFilter.filteredPlaces[category].findIndex(p => p.id === currentEditPlaceId);
                            if (placeIndex !== -1) {
                                const place = currentSearchFilter.filteredPlaces[category][placeIndex];
                                const oldName = place.name;
                                
                                // Update all fields in search results too
                                place.name = newName;
                                place.address = newAddress;
                                
                                if (newHours) {
                                    place.openingHours = {
                                        weekdayDescriptions: newHours.split('\n').filter(line => line.trim())
                                    };
                                    place.currentOpeningHours = place.openingHours;
                                    place.regularOpeningHours = place.openingHours;
                                } else {
                                    place.openingHours = null;
                                    place.currentOpeningHours = null;
                                    place.regularOpeningHours = null;
                                }
                                
                                console.log(`✅ Updated place in search results: "${oldName}" → "${newName}"`);
                                updated = true;
                                break;
                            }
                        }
                    }
                }
                
                if (updated) {
                    // Refresh the display
                    updatePlacesList();
                    updateMapMarkers();
                    
                    // Close modal
                    closeEditModal();
                    
                    console.log('🔄 Place information updated successfully in all locations');
                } else {
                    console.error('❌ Failed to find place for updating');
                    console.log('📊 Debug - Current edit place ID:', currentEditPlaceId);
                    console.log('📊 Debug - Available places:', {
                        searchMode: !!currentSearchFilter,
                        allPlaces: Object.keys(allPlaces),
                        searchPlaces: currentSearchFilter?.filteredPlaces ? Object.keys(currentSearchFilter.filteredPlaces) : null
                    });
                    alert('Failed to update place information');
                }
                
            } catch (error) {
                console.error('❌ Error saving edited place:', error);
                alert('Error saving place information');
            } finally {
                saveBtn.disabled = false;
                saveBtn.textContent = 'Save All Changes';
            }
        }

        // Event listeners for edit modal
        document.addEventListener('DOMContentLoaded', function() {
            // Close modal events
            document.getElementById('closeEditModal').addEventListener('click', closeEditModal);
            document.getElementById('cancelEditBtn').addEventListener('click', closeEditModal);
            
            // Auto-parse button
            document.getElementById('autoParseBtn').addEventListener('click', autoParseWithGemini);
            
            // Save button
            document.getElementById('saveEditBtn').addEventListener('click', saveEditedPlace);
            
            // Close modal on outside click
            document.getElementById('editPlaceModal').addEventListener('click', function(e) {
                if (e.target === this) {
                    closeEditModal();
                }
            });
            
            // Enter key to save
            document.getElementById('editPlaceName').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    saveEditedPlace();
                }
            });
        });

        // Search Results Table Functions
        let searchTableViewActive = false;

        function showSearchResultsTable(query, results) {
            console.log('📊 Showing search results table for:', query);
            
            const searchResultsSection = document.getElementById('searchResultsSection');
            const searchQueryText = searchResultsSection.querySelector('.search-query-text');
            const searchResultsCount = document.getElementById('searchResultsCount');
            const searchResultsTable = document.getElementById('searchResultsTable');
            const placesListSection = document.getElementById('placesList');
            
            // Update query display
            searchQueryText.textContent = query;
            
            // Count total results
            let totalResults = 0;
            Object.values(results).forEach(places => {
                if (Array.isArray(places)) totalResults += places.length;
            });
            
            searchResultsCount.textContent = `${totalResults} result${totalResults !== 1 ? 's' : ''}`;
            
            // Build table content
            let tableHtml = '';
            
            Object.entries(results).forEach(([category, places]) => {
                if (!Array.isArray(places) || places.length === 0) return;
                
                // Add category header
                const categoryIcon = CATEGORY_ICONS[category] || '📍';
                const categoryName = category.charAt(0).toUpperCase() + category.slice(1);
                
                tableHtml += `
                    <div class="search-category-header" style="background: #f8f0ff; padding: 12px 20px; border-bottom: 2px solid #9C27B0; font-weight: 700; color: #4a148c; font-size: 1rem;">
                        ${categoryIcon} ${categoryName} (${places.length} result${places.length !== 1 ? 's' : ''})
                    </div>
                `;
                
                // Add places for this category
                places.forEach((place, index) => {
                    const distanceInMiles = (place.distance * 0.000621371).toFixed(2);
                    const openingHours = getCompactOpeningHours(place);
                    
                    // Get image source
                    let imageSrc = '';
                    if (place.images && place.images.length > 0) {
                        imageSrc = place.images[0].dataUrl;
                    } else if (place.photos && place.photos.length > 0 && place.photos[0].name) {
                        const encodedPhotoName = encodeURIComponent(place.photos[0].name);
                        imageSrc = `/api/place-photo/${encodedPhotoName}?maxHeightPx=100&maxWidthPx=100`;
                    }
                    
                    if (!imageSrc) {
                        const categoryIcon = CATEGORY_ICONS[category] || '📍';
                        imageSrc = `data:image/svg+xml;charset=utf-8,${encodeURIComponent(`
                            <svg width="70" height="70" viewBox="0 0 70 70" xmlns="http://www.w3.org/2000/svg">
                                <rect width="70" height="70" fill="#9C27B0" rx="8"/>
                                <text x="35" y="45" font-family="Arial, sans-serif" font-size="20" fill="white" text-anchor="middle">${categoryIcon}</text>
                            </svg>
                        `)}`;
                    }
                    
                    tableHtml += `
                        <div class="search-table-row" onclick="showPlaceDetails(${JSON.stringify(place).replace(/"/g, '&quot;')})">
                            <img class="search-table-image" src="${imageSrc}" alt="${place.name}" onerror="this.src='${imageSrc}'">
                            <div class="search-table-info">
                                <div class="search-table-name">${place.name}</div>
                                <div class="search-table-address">${place.address}</div>
                                ${openingHours ? `<div class="search-table-hours">🕒 ${openingHours}</div>` : ''}
                            </div>
                            <div class="search-table-stats">
                                ${place.rating > 0 ? `<div class="search-table-rating">⭐ ${place.rating.toFixed(1)}</div>` : ''}
                                <div class="search-table-distance">🚶 ${place.distance}m</div>
                                <div class="search-table-distance">🌍 ${distanceInMiles} mi</div>
                            </div>
                            <div class="search-table-actions">
                                <button class="search-table-btn" onclick="event.stopPropagation(); showPlaceDetails(${JSON.stringify(place).replace(/"/g, '&quot;')})">
                                    👁️ Details
                                </button>
                                <button class="search-table-btn secondary" onclick="event.stopPropagation(); openDirections(${place.location.latitude}, ${place.location.longitude}, '${encodeURIComponent(place.name)}')">
                                    🗺️ Directions
                                </button>
                            </div>
                        </div>
                    `;
                });
            });
            
            if (tableHtml === '') {
                tableHtml = `
                    <div style="text-align: center; padding: 40px 20px; color: #666;">
                        <div style="font-size: 2rem; margin-bottom: 16px;">🔍</div>
                        <div style="font-size: 1.1rem; font-weight: 600; margin-bottom: 8px;">No Results Found</div>
                        <div style="font-size: 0.9rem;">Try a different search term or clear the search to see all places.</div>
                    </div>
                `;
            }
            
            searchResultsTable.innerHTML = tableHtml;
            
            // Show search results section and hide regular places list
            searchResultsSection.style.display = 'block';
            placesListSection.style.display = 'none';
            searchTableViewActive = true;
            
            // Update toggle button
            const viewToggleBtn = document.getElementById('viewToggleBtn');
            viewToggleBtn.textContent = '📋 Switch to List View';
        }

        function hideSearchResultsTable() {
            console.log('📊 Hiding search results table');
            
            const searchResultsSection = document.getElementById('searchResultsSection');
            const placesListSection = document.getElementById('placesList');
            
            searchResultsSection.style.display = 'none';
            placesListSection.style.display = 'block';
            searchTableViewActive = false;
        }

        function toggleSearchResultsView() {
            console.log('🔄 Toggling search results view');
            
            const searchResultsSection = document.getElementById('searchResultsSection');
            const placesListSection = document.getElementById('placesList');
            const viewToggleBtn = document.getElementById('viewToggleBtn');
            
            if (searchTableViewActive) {
                // Switch to list view
                searchResultsSection.style.display = 'none';
                placesListSection.style.display = 'block';
                viewToggleBtn.textContent = '📊 Switch to Table View';
                searchTableViewActive = false;
            } else {
                // Switch to table view
                if (currentSearchFilter && currentSearchFilter.filteredPlaces) {
                    showSearchResultsTable(currentSearchFilter.query, currentSearchFilter.filteredPlaces);
                }
            }
        }
    </script>

    <!-- Load Google Maps API with Geometry Library -->
    <script async defer
        src="https://maps.googleapis.com/maps/api/js?key=AIzaSyAVdAZdO0tjOSoNImELNfi5HtZVzitN3Y4&libraries=geometry&callback=initMap">
    </script>
</body>
</html>