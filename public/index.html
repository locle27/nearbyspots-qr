<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nearby Places - 118 Hang Bac, Hanoi Old Quarter</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f5f5f5;
        }

        .header {
            background: linear-gradient(135deg, #1976D2 0%, #42a5f5 100%);
            color: white;
            padding: 20px;
            text-align: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .header h1 {
            margin-bottom: 5px;
            font-size: 1.8rem;
        }

        .header p {
            opacity: 0.9;
            font-size: 1rem;
        }

        /* Hotel Location Input Section */
        .hotel-location-section {
            background: white;
            padding: 20px;
            border-bottom: 1px solid #e0e0e0;
        }

        .location-input-header {
            text-align: center;
            margin-bottom: 20px;
        }

        .location-input-header h3 {
            margin: 0 0 5px 0;
            color: #1976D2;
            font-size: 1.3rem;
        }

        .location-input-header p {
            margin: 0;
            color: #666;
            font-size: 0.95rem;
        }

        .location-input-container {
            display: flex;
            gap: 15px;
            align-items: end;
            margin-bottom: 15px;
        }

        .btn-update-location {
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            white-space: nowrap;
            box-shadow: 0 2px 8px rgba(76, 175, 80, 0.3);
        }

        .btn-update-location:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(76, 175, 80, 0.4);
        }

        .btn-update-location:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .current-location-display {
            text-align: center;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #4CAF50;
        }

        .current-location-display span {
            color: #2e7d32;
            font-weight: 600;
            font-size: 0.95rem;
        }

        @media (max-width: 768px) {
            .location-input-container {
                flex-direction: column;
                align-items: stretch;
            }

            .btn-update-location {
                margin-top: 10px;
            }
        }

        .controls {
            background: white;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: center;
            justify-content: center;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }

        .control-group label {
            font-weight: 600;
            color: #333;
            font-size: 0.9rem;
        }

        .radius-select {
            padding: 8px 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 1rem;
            background: white;
            cursor: pointer;
            transition: border-color 0.2s;
        }

        .radius-select:focus {
            outline: none;
            border-color: #1976D2;
        }

        .category-filters {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .category-filter {
            padding: 10px 18px;
            border: 3px solid #e0e0e0;
            border-radius: 25px;
            background: white;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1rem;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 8px;
            user-select: none;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .category-filter.active {
            background: #1976D2;
            color: white;
            border-color: #1976D2;
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(25, 118, 210, 0.4);
        }

        .category-filter:hover {
            transform: translateY(-2px) scale(1.02);
            box-shadow: 0 6px 16px rgba(0,0,0,0.2);
            border-color: #1976D2;
        }

        .category-filter:active {
            transform: scale(0.98);
        }

        .load-btn {
            background: linear-gradient(135deg, #4caf50 0%, #66bb6a 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 4px 12px rgba(76, 175, 80, 0.3);
        }

        .load-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(76, 175, 80, 0.4);
        }

        .load-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .map-container {
            height: calc(100vh - 200px);
            margin: 0;
            position: relative;
        }

        #map {
            width: 100%;
            height: 100%;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            z-index: 1000;
            display: none;
        }

        .loading.show {
            display: block;
        }

        .info-panel {
            background: white;
            padding: 15px;
            margin: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .stats {
            display: flex;
            justify-content: space-around;
            text-align: center;
        }

        .stat {
            flex: 1;
        }

        .stat-number {
            font-size: 2rem;
            font-weight: bold;
            color: #1976D2;
        }

        .stat-label {
            color: #666;
            font-size: 0.9rem;
        }

        @media (max-width: 768px) {
            .controls {
                padding: 15px;
            }
            
            .category-filters {
                justify-content: center;
            }
            
            .header h1 {
                font-size: 1.5rem;
            }
            
            .map-container {
                height: calc(100vh - 250px);
            }
        }

        /* Custom marker info window styling */
        .marker-info {
            max-width: 280px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        .marker-info img {
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .marker-info h3 {
            margin: 8px 0 4px 0;
            color: #333;
            font-size: 1.1rem;
            font-weight: 600;
        }

        .marker-info p {
            margin: 4px 0;
            color: #666;
            font-size: 0.9rem;
            line-height: 1.4;
        }

        .marker-info .rating {
            color: #ff9800;
            font-weight: bold;
        }

        .marker-info .distance {
            color: #1976D2;
            font-weight: bold;
        }

        .marker-info button {
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .marker-info button:hover {
            background: #1565C0 !important;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        /* Split-Screen Interface Styling */
        .split-container {
            background: white;
            margin: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .split-header {
            background: linear-gradient(135deg, #1976D2 0%, #42a5f5 100%);
            color: white;
            padding: 20px;
            text-align: center;
        }

        .split-header h3 {
            margin: 0 0 5px 0;
            font-size: 1.3rem;
        }

        .split-header p {
            margin: 0;
            opacity: 0.9;
            font-size: 0.9rem;
        }

        .split-content {
            display: flex;
            height: 600px;
        }

        .split-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .list-panel {
            border-right: 2px solid #e9ecef;
            max-width: 50%;
        }

        .map-panel {
            max-width: 50%;
        }

        .panel-header {
            background: #f8f9fa;
            padding: 15px 20px;
            border-bottom: 1px solid #e9ecef;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .panel-header h4 {
            margin: 0;
            font-size: 1.1rem;
            color: #333;
        }

        .place-count, .map-info {
            font-size: 0.9rem;
            color: #666;
            font-weight: 500;
        }

        .map-container-split {
            flex: 1;
            position: relative;
        }

        .map-container-split #map {
            width: 100%;
            height: 100%;
        }

        /* Places List Styling */
        .places-list {
            flex: 1;
            padding: 15px;
            overflow-y: auto;
        }

        .no-places-message {
            text-align: center;
            color: #666;
            font-size: 1.1rem;
            padding: 40px 20px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 2px dashed #ddd;
        }

        .place-item {
            display: flex;
            gap: 12px;
            padding: 12px;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            margin-bottom: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            background: white;
        }

        .place-item:hover {
            border-color: #1976D2;
            box-shadow: 0 4px 12px rgba(25, 118, 210, 0.15);
            transform: translateY(-2px);
        }

        .place-item.highlighted {
            border-color: #FFD700;
            background: #FFFACD;
            box-shadow: 0 6px 20px rgba(255, 215, 0, 0.3);
            transform: translateY(-2px);
        }

        .place-image {
            width: 70px;
            height: 70px;
            border-radius: 6px;
            object-fit: cover;
            background: #f0f0f0;
            flex-shrink: 0;
            display: block !important;
            min-height: 70px;
            max-width: 70px;
            max-height: 70px;
        }

        .place-image-placeholder {
            width: 70px;
            height: 70px;
            border-radius: 6px;
            background: linear-gradient(135deg, #e0e0e0 0%, #f0f0f0 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.8rem;
            color: #999;
            flex-shrink: 0;
        }

        .place-details {
            flex: 1;
            min-width: 0;
        }

        .place-name {
            font-size: 1rem;
            font-weight: 600;
            color: #333;
            margin-bottom: 4px;
            line-height: 1.3;
        }

        .place-address {
            font-size: 0.85rem;
            color: #666;
            margin-bottom: 6px;
            line-height: 1.3;
        }

        .place-meta {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
        }

        .place-rating {
            color: #ff9800;
            font-weight: bold;
            font-size: 0.8rem;
        }

        .place-distance {
            color: #1976D2;
            font-weight: bold;
            font-size: 0.8rem;
        }

        .place-category {
            background: #e3f2fd;
            color: #1976D2;
            padding: 2px 6px;
            border-radius: 8px;
            font-size: 0.7rem;
            font-weight: 500;
        }

        /* Map View Styling */
        #mapTab {
            position: relative;
        }

        #mapTab #map {
            height: 500px;
            border-radius: 0;
        }

        /* Loading states */
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            z-index: 1000;
            display: none;
            text-align: center;
        }

        .loading.show {
            display: block;
        }

        /* Admin Panel Styling */
        .admin-toggle {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 1000;
        }

        .btn-admin {
            background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
            color: #333;
            border: none;
            padding: 12px 20px;
            border-radius: 25px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(255, 215, 0, 0.4);
            transition: all 0.3s ease;
        }

        .btn-admin:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 215, 0, 0.6);
        }

        .admin-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            width: 90%;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            z-index: 2000;
            padding: 0;
        }

        .admin-header {
            background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
            color: #333;
            padding: 20px;
            border-radius: 15px 15px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .admin-header h3 {
            margin: 0;
            font-size: 1.3rem;
        }

        .close-admin-btn {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #333;
            padding: 5px;
            border-radius: 50%;
            width: 35px;
            height: 35px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .close-admin-btn:hover {
            background: rgba(0,0,0,0.1);
        }

        #addRecommendationForm {
            padding: 20px;
        }

        .form-row {
            display: flex;
            gap: 15px;
        }

        .form-group {
            flex: 1;
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #333;
        }

        .form-group input,
        .form-group textarea {
            width: 100%;
            padding: 10px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 1rem;
            transition: border-color 0.2s;
        }

        .form-group input:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: #FFD700;
        }

        /* Image Upload Styles */
        .image-upload-area {
            width: 100%;
        }

        .image-drop-zone {
            border: 2px dashed #e0e0e0;
            border-radius: 8px;
            padding: 30px;
            text-align: center;
            background: #fafafa;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 15px;
        }

        .image-drop-zone:hover,
        .image-drop-zone.drag-over {
            border-color: #1976D2;
            background: #f3f7ff;
        }

        .drop-zone-content {
            pointer-events: none;
        }

        .drop-zone-icon {
            font-size: 3rem;
            display: block;
            margin-bottom: 10px;
        }

        .drop-zone-hint {
            font-size: 0.9rem;
            color: #666;
            margin-top: 5px;
        }

        .image-preview-container {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .image-preview-item {
            position: relative;
            border-radius: 8px;
            overflow: hidden;
            background: white;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .image-preview-item img {
            width: 120px;
            height: 120px;
            object-fit: cover;
            display: block;
        }

        .image-preview-remove {
            position: absolute;
            top: 5px;
            right: 5px;
            background: rgba(0,0,0,0.7);
            color: white;
            border: none;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            cursor: pointer;
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .image-preview-remove:hover {
            background: rgba(255,0,0,0.8);
        }

        /* Structured Content Styles */
        .structured-content-section {
            margin-bottom: 20px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #e9ecef;
        }

        .structured-content-actions {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .btn-parse {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-parse:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(40, 167, 69, 0.3);
        }

        .btn-quick-add {
            background: linear-gradient(135deg, #007bff 0%, #0056b3 100%);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-quick-add:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 123, 255, 0.3);
        }

        .parsed-content-preview {
            margin-top: 15px;
            padding: 15px;
            background: white;
            border-radius: 6px;
            border: 1px solid #dee2e6;
            font-size: 0.9rem;
        }

        .parsed-content-preview h4 {
            margin: 0 0 10px 0;
            color: #495057;
            font-size: 1rem;
        }

        .parsed-content-preview .parsed-item {
            margin-bottom: 8px;
            padding: 4px 0;
            border-bottom: 1px solid #f1f3f4;
        }

        .parsed-content-preview .parsed-item:last-child {
            border-bottom: none;
        }

        .parsed-content-preview .parsed-label {
            font-weight: 600;
            color: #495057;
            display: inline-block;
            min-width: 80px;
        }

        .parsed-content-preview .parsed-value {
            color: #6c757d;
        }

        /* URL Display Styles */
        .generated-url-display {
            margin-bottom: 15px;
            padding: 15px;
            background: #e8f5e8;
            border-radius: 8px;
            border: 1px solid #d4edda;
        }

        .url-display-box {
            padding: 10px;
            background: white;
            border-radius: 6px;
            border: 1px solid #c3e6cb;
        }

        .url-display-box a {
            color: #155724;
            text-decoration: none;
            font-weight: 500;
        }

        .url-display-box a:hover {
            text-decoration: underline;
        }

        /* Delete Button Styles */
        .delete-recommendation-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid #dc3545;
            border-radius: 50%;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
            z-index: 10;
        }

        .delete-recommendation-btn:hover {
            background: #dc3545;
            color: white;
            transform: scale(1.1);
        }

        .delete-recommendation-btn:active {
            transform: scale(0.95);
        }

        .place-item {
            position: relative;
        }

        .form-actions {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #e0e0e0;
        }

        .btn-primary {
            background: linear-gradient(135deg, #1976D2 0%, #42a5f5 100%);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-primary:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(25, 118, 210, 0.3);
        }

        .btn-secondary {
            background: #f5f5f5;
            color: #666;
            border: 1px solid #ddd;
            padding: 10px 20px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-secondary:hover {
            background: #e0e0e0;
        }

        .btn-extract {
            background: linear-gradient(135deg, #4CAF50 0%, #66bb6a 100%);
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 6px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            margin-left: 10px;
            transition: all 0.2s;
        }

        .btn-extract:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(76, 175, 80, 0.3);
        }

        .form-divider {
            text-align: center;
            color: #999;
            font-weight: 600;
            margin: 20px 0;
            position: relative;
        }

        .form-divider::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 0;
            right: 0;
            height: 1px;
            background: #e0e0e0;
            z-index: 1;
        }

        .form-divider::after {
            content: 'OR fill manually below:';
            background: white;
            padding: 0 15px;
            position: relative;
            z-index: 2;
        }

        #googleMapsUrl {
            margin-bottom: 0;
        }

        .url-input-row {
            display: flex;
            gap: 10px;
            align-items: flex-end;
        }

        .url-input-row .form-group {
            flex: 1;
            margin-bottom: 0;
        }

        /* Admin Panel Backdrop */
        .admin-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 1500;
            display: none;
        }

        .admin-backdrop.show {
            display: block;
        }

        /* Professional Mobile Place Details Modal */
        .image-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.75);
            z-index: 3000;
            display: none;
            align-items: flex-end;
            padding: 0;
            backdrop-filter: blur(4px);
        }

        .image-modal.show {
            display: flex;
        }

        .image-modal-content {
            position: relative;
            width: 100%;
            max-height: 95vh;
            background: white;
            border-radius: 20px 20px 0 0;
            overflow: hidden;
            box-shadow: 0 -10px 30px rgba(0,0,0,0.3);
            animation: slideUp 0.3s ease-out;
        }

        @keyframes slideUp {
            from {
                transform: translateY(100%);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .image-modal-header {
            background: linear-gradient(135deg, #1976D2 0%, #42a5f5 100%);
            color: white;
            padding: 20px 20px 16px 20px;
            position: relative;
        }

        .image-modal-header::before {
            content: '';
            position: absolute;
            top: 8px;
            left: 50%;
            transform: translateX(-50%);
            width: 40px;
            height: 4px;
            background: rgba(255,255,255,0.3);
            border-radius: 2px;
        }

        .image-modal-title {
            margin: 8px 0 0 0;
            font-size: 1.4rem;
            font-weight: 700;
            line-height: 1.3;
            padding-right: 50px;
        }

        .image-modal-close {
            position: absolute;
            top: 16px;
            right: 16px;
            background: rgba(255,255,255,0.15);
            border: none;
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 8px;
            border-radius: 50%;
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            backdrop-filter: blur(10px);
        }

        .image-modal-close:hover {
            background: rgba(255,255,255,0.25);
            transform: scale(1.1);
        }

        .image-modal-body {
            padding: 0;
            max-height: calc(95vh - 80px);
            overflow-y: auto;
            scroll-behavior: smooth;
        }

        /* Desktop styles for larger screens */
        @media (min-width: 768px) {
            .image-modal {
                align-items: center;
                justify-content: center;
                padding: 20px;
            }

            .image-modal-content {
                width: auto;
                max-width: 600px;
                max-height: 85vh;
                border-radius: 16px;
                animation: scaleIn 0.3s ease-out;
            }

            @keyframes scaleIn {
                from {
                    transform: scale(0.9);
                    opacity: 0;
                }
                to {
                    transform: scale(1);
                    opacity: 1;
                }
            }

            .image-modal-header::before {
                display: none;
            }

            .image-modal-title {
                padding-right: 60px;
                font-size: 1.5rem;
            }

            .image-modal-close {
                width: 44px;
                height: 44px;
                font-size: 1.6rem;
            }
        }

        /* Professional Mobile Content Layout */
        .place-details-full {
            padding: 24px 20px 0 20px;
        }

        .place-hero-section {
            margin-bottom: 24px;
        }

        .place-main-image {
            width: 100%;
            height: 240px;
            border-radius: 12px;
            object-fit: cover;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            margin-bottom: 16px;
        }

        .place-info-full {
            width: 100%;
        }

        .place-name-full {
            font-size: 1.5rem;
            font-weight: 800;
            color: #1a1a1a;
            margin-bottom: 8px;
            line-height: 1.2;
        }

        .place-address-full {
            color: #6b7280;
            margin-bottom: 16px;
            font-size: 1rem;
            line-height: 1.5;
            display: flex;
            align-items: flex-start;
            gap: 8px;
        }

        .place-address-full::before {
            content: 'üìç';
            flex-shrink: 0;
            margin-top: 1px;
        }

        .place-stats-full {
            display: flex;
            gap: 12px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .place-stat {
            display: flex;
            align-items: center;
            gap: 6px;
            background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
            padding: 10px 14px;
            border-radius: 50px;
            font-weight: 600;
            font-size: 0.875rem;
            border: 1px solid #e2e8f0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        .place-stat.rating {
            background: linear-gradient(135deg, #fef7cd 0%, #fde047 100%);
            color: #a16207;
            border-color: #fde047;
        }

        .place-stat.distance {
            background: linear-gradient(135deg, #dbeafe 0%, #93c5fd 100%);
            color: #1e40af;
            border-color: #93c5fd;
        }

        .place-stat.category {
            background: linear-gradient(135deg, #d1fae5 0%, #6ee7b7 100%);
            color: #065f46;
            border-color: #6ee7b7;
        }

        .place-description-full {
            color: #4b5563;
            line-height: 1.6;
            margin-bottom: 24px;
            font-size: 1rem;
            padding: 16px;
            background: #f9fafb;
            border-radius: 12px;
            border-left: 4px solid #1976D2;
        }

        .place-actions {
            display: flex;
            gap: 12px;
            margin-bottom: 24px;
            padding: 0 20px;
        }

        .btn-action {
            background: linear-gradient(135deg, #1976D2 0%, #1565C0 100%);
            color: white;
            border: none;
            padding: 14px 24px;
            border-radius: 50px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            font-size: 1rem;
            box-shadow: 0 4px 12px rgba(25, 118, 210, 0.3);
            flex: 1;
            justify-content: center;
        }

        .btn-action:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(25, 118, 210, 0.4);
        }

        /* Desktop adjustments */
        @media (min-width: 768px) {
            .place-details-full {
                display: flex;
                gap: 24px;
                padding: 24px;
            }

            .place-hero-section {
                flex-shrink: 0;
                width: 280px;
                margin-bottom: 0;
            }

            .place-main-image {
                height: 280px;
            }

            .place-info-full {
                flex: 1;
            }

            .place-actions {
                padding: 0;
            }

            .btn-action {
                flex: none;
            }
        }

        /* Professional Photo Gallery */
        .photo-gallery {
            background: #f8fafc;
            margin: 0 -20px;
            padding: 24px 20px;
            border-top: 1px solid #e2e8f0;
        }

        .gallery-title {
            font-size: 1.2rem;
            font-weight: 700;
            color: #1a1a1a;
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .gallery-title::before {
            content: 'üñºÔ∏è';
            font-size: 1.1rem;
        }

        .photo-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 16px;
        }

        /* Desktop gallery adjustments */
        @media (min-width: 768px) {
            .photo-gallery {
                margin: 0;
                background: white;
                border-top: 1px solid #e2e8f0;
                border-radius: 0 0 16px 16px;
            }

            .photo-grid {
                grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
                gap: 18px;
            }
        }

        .gallery-image-container {
            position: relative;
            width: 100%;
            height: 120px;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .gallery-image {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 8px;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .gallery-image:hover {
            transform: scale(1.05);
        }

        .gallery-loading {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #f8f9fa;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
        }

        .loading-spinner {
            width: 24px;
            height: 24px;
            border: 3px solid #e0e0e0;
            border-top: 3px solid #1976D2;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 8px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-text {
            font-size: 12px;
            color: #666;
            text-align: center;
        }

        .gallery-error {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #f5f5f5;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            border: 2px dashed #ddd;
        }

        .error-icon {
            font-size: 20px;
            margin-bottom: 4px;
        }

        .error-text {
            font-size: 10px;
            color: #999;
            text-align: center;
        }

        /* Loading animation */
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .no-photos {
            text-align: center;
            color: #666;
            font-style: italic;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 2px dashed #ddd;
        }

        /* Enhanced place items with better click indication */
        .place-item {
            position: relative;
        }

        .place-item::after {
            content: 'üëÅÔ∏è View Details';
            position: absolute;
            top: 50%;
            right: 15px;
            transform: translateY(-50%);
            background: linear-gradient(135deg, #1976D2 0%, #42a5f5 100%);
            color: white;
            padding: 6px 12px;
            border-radius: 15px;
            font-size: 0.8rem;
            font-weight: 600;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }

        .place-item:hover::after {
            opacity: 1;
        }

        /* Distance conversion display */
        .distance-conversion {
            font-size: 0.75rem;
            color: #888;
            margin-left: 5px;
        }

        /* Mobile responsiveness */
        @media (max-width: 768px) {
            .split-container {
                margin: 10px;
            }
            
            .split-content {
                flex-direction: column;
                height: auto;
            }
            
            .split-panel {
                max-width: 100%;
            }
            
            .list-panel {
                border-right: none;
                border-bottom: 2px solid #e9ecef;
                max-height: 400px;
            }
            
            .map-panel {
                height: 300px;
            }
            
            .map-container-split {
                height: 300px;
            }
            
            .place-item {
                flex-direction: row;
                text-align: left;
            }
            
            .place-image, .place-image-placeholder {
                width: 60px;
                height: 60px;
            }
            
            .place-meta {
                justify-content: flex-start;
            }

            .admin-panel {
                width: 95%;
                max-height: 90vh;
            }

            .form-row {
                flex-direction: column;
                gap: 0;
            }

            .admin-toggle {
                bottom: 10px;
                right: 10px;
            }
        }

        @media (max-width: 480px) {
            .split-header {
                padding: 15px;
            }
            
            .split-header h3 {
                font-size: 1.1rem;
            }
            
            .panel-header {
                padding: 10px 15px;
            }
            
            .places-list {
                padding: 10px;
            }
            
            .place-item {
                padding: 10px;
                gap: 10px;
            }
        }
    </style>
</head>
<body>
    <!-- Loading indicator for mobile -->
    <div id="loadingIndicator" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(25, 118, 210, 0.9); color: white; display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 10000; font-family: Arial;">
        <div style="width: 50px; height: 50px; border: 5px solid rgba(255,255,255,0.3); border-top: 5px solid white; border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 20px;"></div>
        <h2 style="margin: 0 0 10px 0;">üìç Loading Nearby Places</h2>
        <p style="margin: 0; text-align: center; padding: 0 20px;">Connecting to Google Maps and finding restaurants, landmarks, coffee shops & culture near you...</p>
    </div>

    <div class="header">
        <h1>üìç Nearby Places</h1>
        <p id="locationDescription">Discover restaurants, landmarks, coffee shops & culture near 118 Hang Bac, Hanoi Old Quarter</p>
    </div>

    <!-- Hotel Location Input Section -->
    <div class="hotel-location-section">
        <div class="location-input-header">
            <h3>üè® Hotel Location</h3>
            <p>Change your hotel location to find nearby places anywhere</p>
        </div>
        <div class="location-input-container">
            <div class="form-group" style="flex: 1;">
                <label for="hotelMapsUrl">üìç Google Maps URL of your hotel/accommodation</label>
                <input type="url" id="hotelMapsUrl" placeholder="Paste Google Maps link of your hotel location here..." style="width: 100%; padding: 12px; border: 2px solid #e0e0e0; border-radius: 8px; font-size: 1rem;">
            </div>
            <button type="button" id="updateLocationBtn" class="btn-update-location">
                üîÑ Update Location
            </button>
        </div>
        
        <!-- GPS Location Option -->
        <div class="gps-option-container" style="margin-top: 15px; text-align: center;">
            <p style="margin-bottom: 10px; color: #666; font-size: 0.9rem;">Or use your current location:</p>
            <button type="button" id="useGpsBtn" class="btn-gps" style="background: linear-gradient(135deg, #FF6B35 0%, #F7931E 100%); color: white; border: none; padding: 12px 24px; border-radius: 8px; font-weight: 600; cursor: pointer; transition: all 0.3s ease; box-shadow: 0 2px 8px rgba(255, 107, 53, 0.3);">
                üìç Use My Location (GPS)
            </button>
            <p style="margin-top: 8px; color: #999; font-size: 0.8rem;">Requires location permission</p>
        </div>
        <div class="current-location-display">
            <span id="currentLocationText">üìç Current: 118 Hang Bac, Hanoi Old Quarter</span>
        </div>
    </div>

    <div class="controls">
        <div class="control-group">
            <label>Search Radius:</label>
            <select class="radius-select" id="radiusSelect">
                <option value="500">500m - Walking</option>
                <option value="1000">1km - Short walk</option>
                <option value="2000" selected>2km - Bike ride</option>
                <option value="5000">5km - Scooter/taxi</option>
            </select>
        </div>

        <div class="control-group">
            <label>Select Category to Load:</label>
            <p style="font-size: 0.8rem; color: #666; margin: 5px 0;">Click to select one category (single selection for easier viewing)</p>
            <div class="category-filters">
                <div class="category-filter" data-category="recommend">
                    ‚≠ê Recommended
                </div>
                <div class="category-filter active" data-category="restaurants">
                    üçΩÔ∏è Restaurants
                </div>
                <div class="category-filter" data-category="landmarks">
                    üèõÔ∏è Landmarks
                </div>
                <div class="category-filter" data-category="coffee">
                    ‚òï Coffee
                </div>
                <div class="category-filter" data-category="culture">
                    üé≠ Culture
                </div>
            </div>
            <div id="selectedCategoriesDisplay" style="margin-top: 10px; font-size: 0.9rem; color: #1976D2; font-weight: bold;">
                No categories selected
            </div>
        </div>

        <div style="display: flex; gap: 10px; flex-wrap: wrap;">
            <button class="load-btn" id="clearPlacesBtn" style="background: #f44336; flex: 0 0 auto; min-width: 120px;">
                üóëÔ∏è Clear All
            </button>
        </div>
    </div>

    <div class="info-panel">
        <div class="stats" id="statsContainer">
            <div class="stat">
                <div class="stat-number" id="totalPlaces">0</div>
                <div class="stat-label">Total Places</div>
            </div>
            <div class="stat">
                <div class="stat-number" id="avgRating">0.0</div>
                <div class="stat-label">Avg Rating</div>
            </div>
            <div class="stat">
                <div class="stat-number" id="maxDistance">0</div>
                <div class="stat-label">Max Distance</div>
            </div>
            <div class="stat">
                <div class="stat-number" id="topCategory">-</div>
                <div class="stat-label">Most Places</div>
            </div>
        </div>
    </div>

    <!-- Admin Panel for Adding Recommendations -->
    <div class="admin-panel" id="adminPanel" style="display: none;">
        <div class="admin-header">
            <h3>‚≠ê Add New Recommendation</h3>
            <button class="close-admin-btn" id="closeAdminBtn">‚úï</button>
        </div>
        <form id="addRecommendationForm">
            <div class="url-input-row">
                <div class="form-group">
                    <label for="googleMapsUrl">üó∫Ô∏è Google Maps URL (Easy Option)</label>
                    <input type="url" id="googleMapsUrl" placeholder="Paste Google Maps link here - we'll extract everything automatically!">
                </div>
                <button type="button" id="extractFromUrlBtn" class="btn-extract">Extract Info</button>
            </div>
            <div class="generated-url-display" id="generatedUrlDisplay" style="display: none;">
                <div class="form-group">
                    <label>üîó Generated Google Maps URL:</label>
                    <div class="url-display-box" id="urlDisplayBox">
                        <a href="#" target="_blank" id="generatedUrlLink">Click to view on Google Maps</a>
                    </div>
                </div>
            </div>
            
            <div class="form-divider">OR paste structured content below:</div>
            
            <div class="structured-content-section">
                <div class="form-group">
                    <label for="structuredContent">üìù Structured Content (Auto-Parse)</label>
                    <textarea id="structuredContent" rows="8" placeholder="Paste content like:
File: Restaurant_name_1752583415.mp3
Prices: 30k, 33k, 38k
Addresses: 74 Lac Trung Hai Ba Trung
Places: Lac Trung Hai Ba Trung, Be bakery
Hours: 8am to 9pm
Food Items: cheese panini, egg panini, chicken burger
Sentiment: positive
Summary: Description of the place..."></textarea>
                </div>
                <div class="structured-content-actions">
                    <button type="button" id="parseContentBtn" class="btn-parse">Parse Content</button>
                    <button type="button" id="quickAddBtn" class="btn-quick-add" style="display: none;">Quick Add Recommendation</button>
                </div>
                <div class="parsed-content-preview" id="parsedContentPreview" style="display: none;"></div>
            </div>
            
            <div class="form-divider">OR fill manually below:</div>
            
            <div class="form-row">
                <div class="form-group">
                    <label for="recName">Place Name *</label>
                    <input type="text" id="recName" required placeholder="e.g., Temple of Literature">
                </div>
                <div class="form-group">
                    <label for="recRating">Rating (0-5)</label>
                    <input type="number" id="recRating" min="0" max="5" step="0.1" placeholder="4.5">
                </div>
            </div>
            <div class="form-group">
                <label for="recAddress">Address *</label>
                <input type="text" id="recAddress" required placeholder="e.g., 58 Quoc Tu Giam, Hanoi">
            </div>
            <div class="form-row">
                <div class="form-group">
                    <label for="recLatitude">Latitude *</label>
                    <input type="number" id="recLatitude" step="any" required placeholder="21.0285">
                </div>
                <div class="form-group">
                    <label for="recLongitude">Longitude *</label>
                    <input type="number" id="recLongitude" step="any" required placeholder="105.8355">
                </div>
            </div>
            <div class="form-group">
                <label for="recDescription">Description</label>
                <textarea id="recDescription" rows="3" placeholder="Brief description of this place..."></textarea>
            </div>
            <div class="form-group">
                <label for="recImages">üì∏ Images (Paste or Upload)</label>
                <div class="image-upload-area" id="imageUploadArea">
                    <div class="image-drop-zone" id="imageDropZone">
                        <div class="drop-zone-content">
                            <span class="drop-zone-icon">üì∑</span>
                            <p>Paste images (Ctrl+V) or click to upload</p>
                            <p class="drop-zone-hint">Supports JPG, PNG, GIF ‚Ä¢ Max 5MB per image</p>
                        </div>
                        <input type="file" id="imageFileInput" accept="image/*" multiple style="display: none;">
                    </div>
                    <div class="image-preview-container" id="imagePreviewContainer"></div>
                </div>
            </div>
            <div class="form-row">
                <div class="form-group">
                    <label for="recWebsite">Website URL</label>
                    <input type="url" id="recWebsite" placeholder="https://example.com">
                </div>
                <div class="form-group">
                    <label>
                        <input type="checkbox" id="recFeatured"> Featured Recommendation
                    </label>
                </div>
            </div>
            <div class="form-actions">
                <button type="button" class="btn-secondary" id="cancelAddBtn">Cancel</button>
                <button type="submit" class="btn-primary">Add Recommendation</button>
            </div>
        </form>
    </div>

    <!-- Show Admin Panel Button -->
    <div class="admin-toggle">
        <button class="btn-admin" id="showAdminBtn">‚≠ê Add Recommendation</button>
    </div>

    <!-- Admin Panel Backdrop -->
    <div class="admin-backdrop" id="adminBackdrop"></div>

    <!-- Image Modal for Place Details -->
    <div class="image-modal" id="imageModal">
        <div class="image-modal-content">
            <div class="image-modal-header">
                <h3 class="image-modal-title" id="modalPlaceName">Place Details</h3>
                <button class="image-modal-close" id="closeImageModal">‚úï</button>
            </div>
            <div class="image-modal-body" id="modalPlaceDetails">
                <!-- Content will be populated by JavaScript -->
            </div>
        </div>
    </div>

    <!-- Combined Split-Screen Interface -->
    <div class="split-container">
        <div class="split-header">
            <h3>üéØ Recommendations Overview</h3>
            <p>üìã Details on the left ‚Ä¢ üó∫Ô∏è Map locations on the right</p>
        </div>
        
        <div class="split-content">
            <!-- Left Side: List View with Details -->
            <div class="split-panel list-panel">
                <div class="panel-header">
                    <h4>üìã Place Details</h4>
                    <span class="place-count" id="placeCount">0 places</span>
                </div>
                <div class="loading" id="loadingList">
                    <div style="text-align: center;">
                        <div style="font-size: 1.5rem; margin-bottom: 10px;">üîç</div>
                        <div>Loading places...</div>
                    </div>
                </div>
                <div class="places-list" id="placesList">
                    <div class="no-places-message">
                        Select categories and click "Load" to see recommendations
                    </div>
                </div>
            </div>
            
            <!-- Right Side: Map View -->
            <div class="split-panel map-panel">
                <div class="panel-header">
                    <h4>üó∫Ô∏è Map Overview</h4>
                    <span class="map-info" id="mapInfo">Visual distance reference</span>
                </div>
                <div class="loading" id="loadingMap">
                    <div style="text-align: center;">
                        <div style="font-size: 1.5rem; margin-bottom: 10px;">üîç</div>
                        <div>Loading places on map...</div>
                    </div>
                </div>
                <div class="map-container-split">
                    <div id="map"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let map;
        let hotelMarker;
        let placeMarkers = [];
        let allPlaces = {};
        let activeCategories = new Set(['restaurants']); // Start with restaurants selected by default (single selection)
        let currentInfoWindow = null; // Track currently open info window
        let currentRadius = 2000; // Track current search radius (default to 2km for better coverage)
        let placeMarkerMap = new Map(); // Map place IDs to markers for cross-tab interaction

        // Hotel location
        const HOTEL_LOCATION = {
            lat: 21.034087,
            lng: 105.85114,
            name: "Old Quarter Hotel",
            address: "118 Hang Bac, Hoan Kiem, Hanoi, Vietnam"
        };

        // Category colors
        const CATEGORY_COLORS = {
            recommend: '#FFD700',
            restaurants: '#FF6B35',
            landmarks: '#4CAF50', 
            coffee: '#795548',
            culture: '#9C27B0'
        };

        // Category icons
        const CATEGORY_ICONS = {
            recommend: '‚≠ê',
            restaurants: 'üçΩÔ∏è',
            landmarks: 'üèõÔ∏è',
            coffee: '‚òï',
            culture: 'üé≠'
        };

        // Initialize map (internal function)
        function initializeGoogleMap() {
            console.log('initMap called');
            if (map) {
                console.log('Map already exists, skipping initialization');
                return;
            }

            // Hide loading indicator
            const loadingIndicator = document.getElementById('loadingIndicator');
            if (loadingIndicator) {
                loadingIndicator.style.display = 'none';
                console.log('‚úÖ Loading indicator hidden');
            }
            
            map = new google.maps.Map(document.getElementById('map'), {
                center: HOTEL_LOCATION,
                zoom: 14, // Slightly wider view to show more context
                styles: [
                    {
                        featureType: "poi",
                        elementType: "labels", 
                        stylers: [{ visibility: "off" }]
                    }
                ],
                mapTypeControl: true,
                mapTypeControlOptions: {
                    style: google.maps.MapTypeControlStyle.HORIZONTAL_BAR,
                    position: google.maps.ControlPosition.TOP_CENTER
                },
                zoomControl: true,
                zoomControlOptions: {
                    position: google.maps.ControlPosition.RIGHT_BOTTOM
                },
                streetViewControl: false,
                fullscreenControl: false
            });

            // Add map click listener to reset selection when clicking on empty areas
            map.addListener('click', (event) => {
                // Only reset if not clicking on a marker
                console.log('Map clicked, resetting selection');
                resetMarkerHighlighting();
                
                // Remove selection arrow
                if (selectionArrow) {
                    selectionArrow.setMap(null);
                    selectionArrow = null;
                }
            });

            // Add hotel marker
            addHotelMarker();

            // Set up event listeners  
            setupEventListeners();
            
            // If there was a pending map update, do it now
            if (window.retryMapUpdate) {
                console.log('Retrying map update now that Google Maps is loaded...');
                window.retryMapUpdate = false;
                updateMapMarkers();
            }
        }

        function addHotelMarker() {
            hotelMarker = new google.maps.Marker({
                position: HOTEL_LOCATION,
                map: map,
                title: HOTEL_LOCATION.name,
                icon: {
                    url: 'data:image/svg+xml;charset=UTF-8,' + encodeURIComponent(`
                        <svg width="60" height="75" viewBox="0 0 60 75" xmlns="http://www.w3.org/2000/svg">
                            <defs>
                                <filter id="hotel-shadow" x="-50%" y="-50%" width="200%" height="200%">
                                    <feGaussianBlur in="SourceAlpha" stdDeviation="3"/>
                                    <feOffset dx="0" dy="3" result="offset"/>
                                    <feComponentTransfer>
                                        <feFuncA type="linear" slope="0.4"/>
                                    </feComponentTransfer>
                                    <feMerge> 
                                        <feMergeNode/>
                                        <feMergeNode in="SourceGraphic"/>
                                    </feMerge>
                                </filter>
                            </defs>
                            <!-- Main hotel icon -->
                            <circle cx="30" cy="30" r="26" fill="#FF1744" stroke="white" stroke-width="5" filter="url(#hotel-shadow)"/>
                            <circle cx="30" cy="30" r="18" fill="#D32F2F" stroke="white" stroke-width="2"/>
                            <text x="30" y="38" text-anchor="middle" fill="white" font-size="24" font-weight="bold">üè®</text>
                            <!-- Hotel label moved further down and with background -->
                            <rect x="15" y="60" width="30" height="12" fill="white" stroke="#FF1744" stroke-width="1" rx="6" filter="url(#hotel-shadow)"/>
                            <text x="30" y="68" text-anchor="middle" fill="#FF1744" font-size="7" font-weight="bold">YOUR HOTEL</text>
                        </svg>
                    `),
                    scaledSize: new google.maps.Size(60, 75),
                    anchor: new google.maps.Point(30, 30)
                }
            });

            const hotelInfoWindow = new google.maps.InfoWindow({
                content: `
                    <div class="marker-info">
                        <h3>üè® ${HOTEL_LOCATION.name}</h3>
                        <p><strong>Your Hotel Location</strong></p>
                        <p>üìç ${HOTEL_LOCATION.address}</p>
                        <p>üéØ All places are shown relative to this location</p>
                    </div>
                `
            });

            hotelMarker.addListener('click', () => {
                // Close any currently open info window
                if (currentInfoWindow) {
                    currentInfoWindow.close();
                }
                // Open this info window and track it
                hotelInfoWindow.open(map, hotelMarker);
                currentInfoWindow = hotelInfoWindow;
            });
        }

        let eventListenersSetup = false;
        
        function setupEventListeners() {
            if (eventListenersSetup) {
                console.log('Event listeners already set up, skipping');
                return;
            }
            
            console.log('Setting up event listeners');
            eventListenersSetup = true;
            
            // Category filter selection (single selection only)
            document.querySelectorAll('.category-filter').forEach(filter => {
                filter.addEventListener('click', () => {
                    const category = filter.dataset.category;
                    console.log('Category clicked:', category);
                    
                    // Single selection: deactivate all categories first
                    document.querySelectorAll('.category-filter').forEach(f => {
                        f.classList.remove('active');
                    });
                    activeCategories.clear();
                    
                    // Activate the clicked category
                    activeCategories.add(category);
                    filter.classList.add('active');
                    console.log('Selected single category:', category);
                    
                    console.log('Active categories:', Array.from(activeCategories));
                    
                    // Update displays
                    // updateLoadButtonText(); // Removed since no load button
                    updateSelectedCategoriesDisplay();
                    
                    // Only update map if we already have data loaded
                    if (Object.keys(allPlaces).length > 0) {
                        updateMapMarkers();
                        updateStats();
                    }
                });
            });

            // Auto-load places on page load
            // loadPlaces functionality will be called automatically

            // Hotel location update button
            document.getElementById('updateLocationBtn').addEventListener('click', updateHotelLocation);
            
            // GPS location button
            document.getElementById('useGpsBtn').addEventListener('click', useGPSLocation);
            
            // Clear places button
            document.getElementById('clearPlacesBtn').addEventListener('click', clearAllPlaces);

            // Radius change
            document.getElementById('radiusSelect').addEventListener('change', () => {
                if (Object.keys(allPlaces).length > 0 && activeCategories.size > 0) {
                    loadPlaces(); // Reload with new radius
                }
            });

            // Admin panel
            setupAdminPanel();
            
            // Image modal
            setupImageModal();
        }
        
        function setupImageModal() {
            const modal = document.getElementById('imageModal');
            const closeBtn = document.getElementById('closeImageModal');
            
            // Close modal when clicking close button
            closeBtn.addEventListener('click', hideImageModal);
            
            // Close modal when clicking outside the content
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    hideImageModal();
                }
            });
            
            // Close modal with Escape key
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && modal.classList.contains('show')) {
                    hideImageModal();
                }
            });
        }

        function updatePlacesList() {
            console.log('Updating places list...');
            const placesList = document.getElementById('placesList');
            
            if (!placesList) {
                console.error('Places list container not found');
                return;
            }
            
            // Clear existing content
            placesList.innerHTML = '';
            
            // Collect all active places
            const activePlaces = [];
            Object.entries(allPlaces).forEach(([category, places]) => {
                if (activeCategories.has(category)) {
                    places.forEach(place => {
                        activePlaces.push({
                            ...place,
                            category: category
                        });
                    });
                }
            });
            
            console.log(`Found ${activePlaces.length} active places to display`);
            
            // Update place count and map info
            const placeCount = document.getElementById('placeCount');
            const mapInfo = document.getElementById('mapInfo');
            
            if (placeCount) {
                placeCount.textContent = `${activePlaces.length} place${activePlaces.length !== 1 ? 's' : ''}`;
            }
            
            if (mapInfo && activePlaces.length > 0) {
                const distances = activePlaces.map(place => place.distance);
                const minDistance = Math.min(...distances);
                const maxDistance = Math.max(...distances);
                mapInfo.textContent = `${minDistance}m - ${maxDistance}m from hotel`;
            } else if (mapInfo) {
                mapInfo.textContent = 'Visual distance reference';
            }
            
            if (activePlaces.length === 0) {
                placesList.innerHTML = `
                    <div class="no-places-message">
                        ${activeCategories.size === 0 
                            ? 'Select categories and click "Load" to see recommendations' 
                            : 'No places found. Try expanding your search radius or selecting different categories.'}
                    </div>
                `;
                return;
            }
            
            // Sort places by distance
            activePlaces.sort((a, b) => a.distance - b.distance);
            
            // Create place items
            activePlaces.forEach((place, index) => {
                const placeItem = createPlaceListItem(place, index);
                placesList.appendChild(placeItem);
            });
        }

        function createPlaceListItem(place, index) {
            const item = document.createElement('div');
            item.className = 'place-item';
            item.dataset.placeId = place.id;
            item.dataset.category = place.category;
            
            // Get category icon and color
            const categoryIcon = CATEGORY_ICONS[place.category] || 'üìç';
            const categoryColor = CATEGORY_COLORS[place.category] || '#1976D2';
            
            // Convert distance to miles (1 meter = 0.000621371 miles)
            const distanceInMiles = (place.distance * 0.000621371).toFixed(2);
            
            // Create image element with fallback
            let imageElement;
            
            // Default images based on category - using URL encoding instead of btoa to avoid emoji issues
            const defaultImages = {
                recommend: 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(`
                    <svg width="70" height="70" viewBox="0 0 70 70" xmlns="http://www.w3.org/2000/svg">
                        <defs>
                            <linearGradient id="starGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                                <stop offset="0%" style="stop-color:#FFD700;stop-opacity:1" />
                                <stop offset="100%" style="stop-color:#FFA500;stop-opacity:1" />
                            </linearGradient>
                        </defs>
                        <rect width="70" height="70" fill="url(#starGrad)" rx="6"/>
                        <circle cx="35" cy="35" r="12" fill="white"/>
                        <polygon points="35,25 37,31 43,31 38,35 40,41 35,37 30,41 32,35 27,31 33,31" fill="#FFD700"/>
                    </svg>
                `),
                restaurants: 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(`
                    <svg width="70" height="70" viewBox="0 0 70 70" xmlns="http://www.w3.org/2000/svg">
                        <defs>
                            <linearGradient id="foodGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                                <stop offset="0%" style="stop-color:#FF6B35;stop-opacity:1" />
                                <stop offset="100%" style="stop-color:#F7931E;stop-opacity:1" />
                            </linearGradient>
                        </defs>
                        <rect width="70" height="70" fill="url(#foodGrad)" rx="6"/>
                        <circle cx="35" cy="35" r="12" fill="white"/>
                        <circle cx="35" cy="30" r="6" fill="#FF6B35"/>
                        <rect x="32" y="36" width="6" height="8" fill="#FF6B35"/>
                    </svg>
                `),
                landmarks: 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(`
                    <svg width="70" height="70" viewBox="0 0 70 70" xmlns="http://www.w3.org/2000/svg">
                        <defs>
                            <linearGradient id="landmarkGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                                <stop offset="0%" style="stop-color:#4CAF50;stop-opacity:1" />
                                <stop offset="100%" style="stop-color:#66BB6A;stop-opacity:1" />
                            </linearGradient>
                        </defs>
                        <rect width="70" height="70" fill="url(#landmarkGrad)" rx="6"/>
                        <circle cx="35" cy="35" r="12" fill="white"/>
                        <rect x="28" y="40" width="14" height="8" fill="#4CAF50"/>
                        <polygon points="28,40 35,28 42,40" fill="#4CAF50"/>
                    </svg>
                `),
                coffee: 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(`
                    <svg width="70" height="70" viewBox="0 0 70 70" xmlns="http://www.w3.org/2000/svg">
                        <defs>
                            <linearGradient id="coffeeGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                                <stop offset="0%" style="stop-color:#795548;stop-opacity:1" />
                                <stop offset="100%" style="stop-color:#A1887F;stop-opacity:1" />
                            </linearGradient>
                        </defs>
                        <rect width="70" height="70" fill="url(#coffeeGrad)" rx="6"/>
                        <circle cx="35" cy="35" r="12" fill="white"/>
                        <ellipse cx="35" cy="35" rx="8" ry="10" fill="#795548"/>
                        <ellipse cx="35" cy="32" rx="6" ry="3" fill="#A1887F"/>
                    </svg>
                `),
                culture: 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(`
                    <svg width="70" height="70" viewBox="0 0 70 70" xmlns="http://www.w3.org/2000/svg">
                        <defs>
                            <linearGradient id="cultureGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                                <stop offset="0%" style="stop-color:#9C27B0;stop-opacity:1" />
                                <stop offset="100%" style="stop-color:#BA68C8;stop-opacity:1" />
                            </linearGradient>
                        </defs>
                        <rect width="70" height="70" fill="url(#cultureGrad)" rx="6"/>
                        <circle cx="35" cy="35" r="12" fill="white"/>
                        <path d="M28,35 Q35,25 42,35 Q35,45 28,35" fill="#9C27B0"/>
                    </svg>
                `)
            };
            
            // Check for uploaded images first (custom images take priority)
            if (place.images && place.images.length > 0) {
                // Use uploaded image (base64 data URL)
                const uploadedImage = place.images[0];
                console.log(`üì∏ Place ${place.name} has uploaded image`);
                
                imageElement = `<img class="place-image" src="${uploadedImage.dataUrl}" alt="${place.name}" style="display: block;">`;
            } else if (place.photos && place.photos.length > 0) {
                // Validate photo reference
                const photo = place.photos[0];
                const hasValidPhoto = photo && photo.name && photo.name.trim().length > 0 && 
                                    !photo.name.includes('undefined') && !photo.name.includes('null');
                
                if (hasValidPhoto) {
                    console.log(`‚úÖ Place ${place.name} has valid photo:`, photo.name.substring(0, 50) + '...');
                    
                    // Encode the photo name properly to handle special characters
                    const encodedPhotoName = encodeURIComponent(photo.name);
                    const photoUrl = `/api/place-photo/${encodedPhotoName}?maxHeightPx=140&maxWidthPx=140`;
                    const fallbackImage = defaultImages[place.category] || defaultImages.recommend;
                    
                    imageElement = `
                        <img class="place-image" 
                             src="${fallbackImage}" 
                             data-real-src="${photoUrl}"
                             alt="${place.name}" 
                             loading="lazy" 
                             onload="console.log('‚úÖ Image loaded for ${place.name}'); this.style.display='block';"
                             onerror="console.log('‚ùå Photo failed for ${place.name}, using fallback'); this.src='${fallbackImage}'; this.style.display='block';">`;
                    
                    // Try to load the real photo after a short delay
                    setTimeout(() => {
                        const img = document.querySelector(`img[data-real-src="${photoUrl}"]`);
                        if (img && img.dataset.realSrc) {
                            const testImg = new Image();
                            testImg.onload = () => {
                                console.log(`üñºÔ∏è Real photo verified for ${place.name}, switching...`);
                                img.src = photoUrl;
                            };
                            testImg.onerror = () => {
                                console.log(`‚ùå Real photo failed for ${place.name}, keeping fallback`);
                                // Keep fallback image
                            };
                            testImg.src = photoUrl;
                        }
                    }, 500);
                } else {
                    console.log(`‚ùå Place ${place.name} has invalid photo data, using category image`);
                    const fallbackImage = defaultImages[place.category] || defaultImages.recommend;
                    imageElement = `<img class="place-image" src="${fallbackImage}" alt="${place.name}" style="display: block;">`;
                }
            } else {
                console.log(`‚ÑπÔ∏è Place ${place.name} has no photos, using category image for: ${place.category}`);
                const fallbackImage = defaultImages[place.category] || defaultImages.recommend;
                imageElement = `<img class="place-image" src="${fallbackImage}" alt="${place.name}" style="display: block;">`;
            }
            
            console.log(`Final imageElement HTML for ${place.name}:`, imageElement);
            
            // Test to ensure the image container exists
            console.log(`Setting innerHTML for place item ${place.name}`);
            
            // Add delete button only for recommendations
            const deleteButtonHtml = place.category === 'recommend' ? `
                <button class="delete-recommendation-btn" onclick="deleteRecommendation('${place.id}', event)" title="Delete this recommendation">
                    üóëÔ∏è
                </button>
            ` : '';

            item.innerHTML = `
                ${imageElement}
                <div class="place-details">
                    <div class="place-name">${place.name}</div>
                    <div class="place-address">üìç ${place.address}</div>
                    <div class="place-meta">
                        ${place.rating > 0 ? `<span class="place-rating">‚≠ê ${place.rating.toFixed(1)} (${place.userRatingCount})</span>` : ''}
                        <span class="place-distance">üö∂ ${place.distance}m<span class="distance-conversion">(${distanceInMiles} mi)</span></span>
                        <span class="place-category" style="background-color: ${categoryColor}20; color: ${categoryColor};">
                            ${categoryIcon} ${place.category}
                        </span>
                    </div>
                </div>
                ${deleteButtonHtml}
            `;
            
            // Debug: Check if the image was actually added to the DOM
            setTimeout(() => {
                const addedImage = item.querySelector('.place-image');
                if (addedImage) {
                    console.log(`‚úÖ Image element found for ${place.name}:`, addedImage.src);
                    console.log(`Image dimensions:`, addedImage.offsetWidth, 'x', addedImage.offsetHeight);
                    console.log(`Image style:`, addedImage.style.cssText);
                } else {
                    console.error(`‚ùå No image element found for ${place.name}!`);
                    console.log(`Item HTML:`, item.innerHTML);
                }
            }, 100);
            
            // Add click handler to open detailed view
            item.addEventListener('click', () => {
                showPlaceDetails(place);
                highlightPlaceOnMap(place.id);
            });
            
            return item;
        }

        async function fetchManualRecommendations() {
            try {
                console.log('Fetching manual recommendations from API...');
                
                const response = await fetch(`/api/recommendations?latitude=${HOTEL_LOCATION.lat}&longitude=${HOTEL_LOCATION.lng}`);
                
                if (!response.ok) {
                    throw new Error(`Failed to fetch recommendations: ${response.status}`);
                }
                
                const data = await response.json();
                console.log('Manual recommendations response:', data);
                
                if (data.success && data.recommendations) {
                    // Store recommendations in allPlaces under 'recommend' category
                    if (!allPlaces.recommend) {
                        allPlaces.recommend = [];
                    }
                    
                    // Merge with existing recommendations (avoid duplicates)
                    const existingIds = new Set(allPlaces.recommend.map(place => place.id));
                    const newRecommendations = data.recommendations.filter(rec => !existingIds.has(rec.id));
                    
                    allPlaces.recommend.push(...newRecommendations);
                    
                    // Sort by distance
                    allPlaces.recommend.sort((a, b) => a.distance - b.distance);
                    
                    console.log(`Added ${newRecommendations.length} new manual recommendations, total: ${allPlaces.recommend.length}`);
                } else {
                    console.warn('No recommendations received from API');
                }
            } catch (error) {
                console.error('Error fetching manual recommendations:', error);
                // Don't show alert for recommendations - it's not critical
            }
        }

        function setupAdminPanel() {
            console.log('Setting up admin panel...');
            
            const showAdminBtn = document.getElementById('showAdminBtn');
            const adminPanel = document.getElementById('adminPanel');
            const adminBackdrop = document.getElementById('adminBackdrop');
            const closeAdminBtn = document.getElementById('closeAdminBtn');
            const cancelAddBtn = document.getElementById('cancelAddBtn');
            const addRecommendationForm = document.getElementById('addRecommendationForm');
            
            // Show admin panel
            showAdminBtn.addEventListener('click', () => {
                adminPanel.style.display = 'block';
                adminBackdrop.classList.add('show');
                document.body.style.overflow = 'hidden';
            });
            
            // Hide admin panel
            function hideAdminPanel() {
                adminPanel.style.display = 'none';
                adminBackdrop.classList.remove('show');
                document.body.style.overflow = 'auto';
                addRecommendationForm.reset();
                clearImagePreviews();
            }
            
            closeAdminBtn.addEventListener('click', hideAdminPanel);
            cancelAddBtn.addEventListener('click', hideAdminPanel);
            adminBackdrop.addEventListener('click', hideAdminPanel);
            
            // Handle form submission
            addRecommendationForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                await addNewRecommendation();
            });
            
            // Handle Google Maps URL extraction
            document.getElementById('extractFromUrlBtn').addEventListener('click', extractFromGoogleMapsUrl);
        }

        async function extractFromGoogleMapsUrl() {
            const urlInput = document.getElementById('googleMapsUrl');
            const url = urlInput.value.trim();
            
            if (!url) {
                alert('Please paste a Google Maps URL first');
                return;
            }
            
            console.log('Extracting from URL:', url);
            
            // Disable button during processing
            const extractBtn = document.getElementById('extractFromUrlBtn');
            extractBtn.disabled = true;
            extractBtn.textContent = 'Processing...';
            
            try {
                let workingUrl = url;
                
                // If it's a shortened URL, resolve it first
                if (url.includes('goo.gl') || url.includes('maps.app.goo.gl')) {
                    console.log('Detected shortened URL, resolving...');
                    
                    const resolveResponse = await fetch('/api/resolve-maps-url', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ url: url })
                    });
                    
                    if (resolveResponse.ok) {
                        const resolveData = await resolveResponse.json();
                        if (resolveData.success) {
                            workingUrl = resolveData.resolvedUrl;
                            console.log('Resolved to:', workingUrl);
                        } else {
                            throw new Error('Could not resolve shortened URL');
                        }
                    } else {
                        throw new Error('Failed to resolve shortened URL');
                    }
                }
                
                // Now extract from the resolved URL
                await extractCoordinatesFromUrl(workingUrl);
                
            } catch (error) {
                console.error('Error processing URL:', error);
                alert('‚ùå Error processing URL: ' + error.message);
            } finally {
                // Re-enable button
                extractBtn.disabled = false;
                extractBtn.textContent = 'Extract Info';
            }
        }

        async function extractCoordinatesFromUrl(url) {
            console.log('Extracting coordinates from:', url);
            
            // Parse different Google Maps URL formats
            let coordinates = null;
            let placeName = '';
            
            // Format 1: https://maps.google.com/maps?q=21.0285,105.8355
            // Format 2: https://www.google.com/maps/@21.0285,105.8355,15z
            // Format 3: https://www.google.com/maps/place/Temple+of+Literature/@21.0285,105.8355,17z
            // Format 4: https://www.google.com/maps/place/Temple+of+Literature/data=...!3d21.0285!4d105.8355
            
            // Try to extract coordinates from various URL patterns
            const patterns = [
                // @lat,lng,zoom pattern
                /@(-?\d+\.?\d*),(-?\d+\.?\d*),/,
                // q=lat,lng pattern  
                /[?&]q=(-?\d+\.?\d*),(-?\d+\.?\d*)/,
                // /maps/@lat,lng pattern
                /\/maps\/@(-?\d+\.?\d*),(-?\d+\.?\d*)/,
                // place coordinates
                /place\/[^\/]+\/@(-?\d+\.?\d*),(-?\d+\.?\d*)/,
                // data format !3d(lat)!4d(lng)
                /!3d(-?\d+\.?\d*)!4d(-?\d+\.?\d*)/
            ];
            
            for (const pattern of patterns) {
                const match = url.match(pattern);
                if (match) {
                    coordinates = {
                        latitude: parseFloat(match[1]),
                        longitude: parseFloat(match[2])
                    };
                    console.log('Found coordinates:', coordinates);
                    break;
                }
            }
            
            // Extract place name from URL
            const placeMatch = url.match(/\/place\/([^\/]+)/);
            if (placeMatch) {
                placeName = decodeURIComponent(placeMatch[1].replace(/\+/g, ' '));
                console.log('Found place name:', placeName);
            }
            
            if (coordinates) {
                // Validate coordinates
                if (coordinates.latitude >= -90 && coordinates.latitude <= 90 && 
                    coordinates.longitude >= -180 && coordinates.longitude <= 180) {
                    
                    // Auto-fill the form
                    document.getElementById('recLatitude').value = coordinates.latitude;
                    document.getElementById('recLongitude').value = coordinates.longitude;
                    
                    if (placeName) {
                        document.getElementById('recName').value = placeName;
                    }
                    
                    // Try to get more info using Google Geocoding API
                    geocodeCoordinates(coordinates.latitude, coordinates.longitude);
                    
                    alert('‚úÖ Coordinates extracted successfully! Check the form fields.');
                    
                    // Clear the URL field
                    document.getElementById('googleMapsUrl').value = '';
                    
                } else {
                    throw new Error('Invalid coordinates found');
                }
            } else {
                throw new Error('Could not extract coordinates from this URL. Please try:\n\n1. Share from Google Maps app\n2. Copy the URL from maps.google.com\n3. Make sure the URL contains location coordinates');
            }
        }

        async function geocodeCoordinates(lat, lng) {
            try {
                console.log(`Geocoding coordinates: ${lat}, ${lng}`);
                
                const response = await fetch('/api/geocode-coordinates', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        latitude: lat,
                        longitude: lng
                    })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    if (data.success && data.address) {
                        document.getElementById('recAddress').value = data.address;
                        console.log('Auto-filled address:', data.address);
                    }
                }
            } catch (error) {
                console.warn('Could not auto-fill address:', error);
                // Not critical - user can fill manually
            }
        }

        let isSubmitting = false; // Global flag to prevent duplicate submissions
        
        async function addNewRecommendation() {
            // Prevent duplicate submissions
            if (isSubmitting) {
                console.log('‚ö†Ô∏è Submission already in progress, ignoring duplicate request');
                return;
            }
            
            const form = document.getElementById('addRecommendationForm');
            const submitBtn = form.querySelector('button[type="submit"]');
            const formData = new FormData(form);
            
            // Set submission state with visual feedback
            isSubmitting = true;
            submitBtn.disabled = true;
            submitBtn.innerHTML = '<span style="display: inline-block; animation: spin 1s linear infinite;">‚è≥</span> Adding...';
            
            // Add spinner animation if not already defined
            if (!document.querySelector('#spinner-style')) {
                const style = document.createElement('style');
                style.id = 'spinner-style';
                style.textContent = `
                    @keyframes spin {
                        0% { transform: rotate(0deg); }
                        100% { transform: rotate(360deg); }
                    }
                `;
                document.head.appendChild(style);
            }
            
            try {
                const recommendation = {
                    name: document.getElementById('recName').value.trim(),
                    address: document.getElementById('recAddress').value.trim(),
                    latitude: parseFloat(document.getElementById('recLatitude').value),
                    longitude: parseFloat(document.getElementById('recLongitude').value),
                    rating: parseFloat(document.getElementById('recRating').value) || 0,
                    description: document.getElementById('recDescription').value.trim(),
                    websiteUri: document.getElementById('recWebsite').value.trim(),
                    featured: document.getElementById('recFeatured').checked,
                    images: uploadedImages.map(img => ({
                        id: img.id,
                        name: img.name,
                        dataUrl: img.dataUrl
                    }))
                };
                
                // Validation
                if (!recommendation.name || !recommendation.address || !recommendation.latitude || !recommendation.longitude) {
                    alert('Please fill in all required fields (Name, Address, Latitude, Longitude)');
                    return;
                }
                
                if (isNaN(recommendation.latitude) || isNaN(recommendation.longitude)) {
                    alert('Please enter valid coordinates');
                    return;
                }
                
                console.log('Adding new recommendation:', recommendation);
                
                const response = await fetch('/api/recommendations', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(recommendation)
                });
                
                const result = await response.json();
                
                if (response.ok && result.success) {
                    alert(`‚úÖ Successfully added: ${recommendation.name}`);
                    
                    // Add to local data and refresh display
                    if (!allPlaces.recommend) {
                        allPlaces.recommend = [];
                    }
                    
                    // Calculate distance from hotel
                    const distance = Math.round(calculateDistance(
                        HOTEL_LOCATION.lat, HOTEL_LOCATION.lng,
                        recommendation.latitude, recommendation.longitude
                    ));
                    
                    const newRec = {
                        ...result.recommendation,
                        distance: distance
                    };
                    
                    allPlaces.recommend.push(newRec);
                    allPlaces.recommend.sort((a, b) => a.distance - b.distance);
                    
                    // Update displays
                    updateMapMarkers();
                    updateStats();
                    updatePlacesList();
                    
                    // Hide admin panel
                    document.getElementById('adminPanel').style.display = 'none';
                    document.getElementById('adminBackdrop').classList.remove('show');
                    document.body.style.overflow = 'auto';
                    form.reset();
                    clearImagePreviews();
                    
                    console.log(`Added recommendation: ${newRec.name} at ${distance}m from hotel`);
                } else {
                    alert(`‚ùå Failed to add recommendation: ${result.error || 'Unknown error'}`);
                }
            } catch (error) {
                console.error('Error adding recommendation:', error);
                alert('‚ùå Network error. Please try again.');
            } finally {
                // Reset submission state
                isSubmitting = false;
                submitBtn.disabled = false;
                submitBtn.innerHTML = 'Add Recommendation';
            }
        }

        // Utility function to calculate distance (if not already defined)
        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 6371e3; // Earth's radius in meters
            const œÜ1 = lat1 * Math.PI / 180;
            const œÜ2 = lat2 * Math.PI / 180;
            const ŒîœÜ = (lat2 - lat1) * Math.PI / 180;
            const ŒîŒª = (lon2 - lon1) * Math.PI / 180;

            const a = Math.sin(ŒîœÜ / 2) * Math.sin(ŒîœÜ / 2) +
                Math.cos(œÜ1) * Math.cos(œÜ2) *
                Math.sin(ŒîŒª / 2) * Math.sin(ŒîŒª / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

            return R * c; // Distance in meters
        }

        function highlightPlaceOnMap(placeId) {
            console.log(`Highlighting place on map: ${placeId}`);
            
            // Find the marker for this place
            const marker = placeMarkerMap.get(placeId);
            if (!marker) {
                console.warn(`Marker not found for place ID: ${placeId}`);
                return;
            }
            
            // Close any currently open info window
            if (currentInfoWindow) {
                currentInfoWindow.close();
            }
            
            // Open the info window for this marker
            const infoWindow = marker.infoWindow;
            if (infoWindow) {
                infoWindow.open(map, marker);
                currentInfoWindow = infoWindow;
            }
            
            // Center the map on this marker
            map.setCenter(marker.getPosition());
            if (map.getZoom() < 16) {
                map.setZoom(16);
            }
            
            // Add a temporary highlight effect to the marker
            const originalIcon = marker.getIcon();
            
            // Create a highlighted version of the icon
            const highlightIcon = {
                ...originalIcon,
                url: originalIcon.url.replace('stroke-width="2"', 'stroke-width="4"').replace('stroke="white"', 'stroke="#FFD700"')
            };
            
            marker.setIcon(highlightIcon);
            
            // Reset the icon after 2 seconds
            setTimeout(() => {
                marker.setIcon(originalIcon);
            }, 2000);
        }

        function highlightPlaceInList(placeId) {
            console.log(`Highlighting place in list: ${placeId}`);
            
            // Remove any existing highlights
            document.querySelectorAll('.place-item.highlighted').forEach(item => {
                item.classList.remove('highlighted');
            });
            
            // Find and highlight the place item
            const placeItem = document.querySelector(`[data-place-id="${placeId}"]`);
            if (placeItem) {
                placeItem.classList.add('highlighted');
                
                // Scroll to the highlighted item if it's not visible
                placeItem.scrollIntoView({
                    behavior: 'smooth',
                    block: 'center'
                });
                
                // Remove highlight after 3 seconds
                setTimeout(() => {
                    placeItem.classList.remove('highlighted');
                }, 3000);
            } else {
                console.warn(`Place item not found for ID: ${placeId}`);
            }
        }

        async function loadPlaces() {
            console.log('Auto-loading places! Current activeCategories:', Array.from(activeCategories), 'Size:', activeCategories.size);
            
            // Auto-select recommend category if no categories are selected
            if (activeCategories.size === 0) {
                console.log('No categories selected, auto-selecting recommend category');
                activeCategories.add('recommend');
                
                // Update UI to show recommend category as selected
                document.querySelectorAll('.category-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                const recommendBtn = document.querySelector('.category-btn[data-category="recommend"]');
                if (recommendBtn) {
                    recommendBtn.classList.add('active');
                }
                updateSelectedCategoriesDisplay();
            }
            
            console.log('Categories selected, proceeding with load...');

            const radius = parseInt(document.getElementById('radiusSelect').value);
            const previousRadius = currentRadius;
            currentRadius = radius;
            
            console.log(`Radius change: ${previousRadius}m ‚Üí ${radius}m`);
            
            const loadingMap = document.getElementById('loadingMap');
            const loadingList = document.getElementById('loadingList');
            
            // Show loading indicators on both tabs
            if (loadingMap) loadingMap.classList.add('show');
            if (loadingList) loadingList.classList.add('show');

            try {
                // Handle radius changes intelligently
                if (radius < previousRadius && Object.keys(allPlaces).length > 0) {
                    console.log('Smaller radius: filtering existing places without API call');
                    // For smaller radius, just filter existing places (no API call needed)
                    Object.keys(allPlaces).forEach(category => {
                        if (allPlaces[category]) {
                            allPlaces[category] = allPlaces[category].filter(place => place.distance <= radius);
                        }
                    });
                    
                    console.log('Places filtered for smaller radius:', allPlaces);
                    updateMapMarkers();
                    updateStats();
                    adjustMapBounds();
                } else {
                    console.log('Larger radius or first load: fetching from API');
                    
                    // Check if we need to fetch manual recommendations
                    if (activeCategories.has('recommend')) {
                        console.log('Fetching manual recommendations...');
                        await fetchManualRecommendations();
                    }
                    
                    // For larger radius or first load, fetch from API
                    const response = await fetch('/api/search-nearby', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            latitude: HOTEL_LOCATION.lat,
                            longitude: HOTEL_LOCATION.lng,
                            radius: radius
                        })
                    });

                    console.log('Response status:', response.status);

                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({}));
                        console.error('API Error Response:', errorData);
                        throw new Error(errorData.message || `Server error: ${response.status}`);
                    }

                    const data = await response.json();
                    console.log('API response:', data);
                    
                    // Enhanced error handling with debug info
                    if (data.debug) {
                        console.log('üîç Debug info from server:', data.debug);
                        if (data.debug.totalPlacesFound === 0) {
                            console.warn('‚ö†Ô∏è Server returned 0 places despite successful API call');
                            console.warn('üîë API Key present on server:', data.debug.apiKeyPresent);
                        }
                    }
                    
                    if (data.success && data.results) {
                        console.log('Merging new places with existing');
                        // Merge new places with existing ones
                        Object.entries(data.results).forEach(([category, newPlaces]) => {
                            if (!allPlaces[category]) {
                                allPlaces[category] = [];
                            }
                            
                            // Combine existing and new places
                            const existingPlaces = allPlaces[category];
                            const combinedPlaces = [...existingPlaces, ...newPlaces];
                            
                            // Remove duplicates based on place ID and keep closest ones
                            const uniquePlaces = new Map();
                            combinedPlaces.forEach(place => {
                                const existing = uniquePlaces.get(place.id);
                                if (!existing || place.distance < existing.distance) {
                                    uniquePlaces.set(place.id, place);
                                }
                            });
                            
                            // Sort by distance and keep reasonable number of places
                            allPlaces[category] = Array.from(uniquePlaces.values())
                                .sort((a, b) => a.distance - b.distance)
                                .slice(0, 50); // Keep max 50 places per category for better coverage
                        });
                        
                        console.log('Places merged and updated:', allPlaces);
                        updateMapMarkers();
                        updateStats();
                        adjustMapBounds();
                    } else {
                        console.error('API returned no results:', data);
                        
                        // Enhanced no results message with debug info
                        let errorMessage = 'No places found. ';
                        if (data.debug && !data.debug.apiKeyPresent) {
                            errorMessage += 'API configuration issue detected. ';
                        } else if (data.debug && data.debug.totalPlacesFound === 0) {
                            errorMessage += 'Google Places API returned empty results. ';
                        }
                        errorMessage += 'Try expanding your search radius or selecting different categories.';
                        
                        // Check if API returned error or empty results
                        if (data.error) {
                            console.error('API Error:', data.error);
                            alert(`API Error: ${data.error}\n\nPlease check:\n- Google Maps API key is valid\n- Places API (New) is enabled\n- Billing is set up in Google Cloud\n- API quotas not exceeded`);
                            return;
                        }
                        
                        alert(errorMessage);
                    }
                }

            } catch (error) {
                console.error('Error loading places:', error);
                
                // Enhanced error message based on error type
                let errorMessage = 'Failed to load places. ';
                if (error.message.includes('API key')) {
                    errorMessage += 'API configuration issue. Please check server logs.';
                } else if (error.message.includes('network') || error.message.includes('fetch')) {
                    errorMessage += 'Network connection issue. Please check your internet connection.';
                } else if (error.message.includes('Server error: 403')) {
                    errorMessage += 'API permissions issue. Check Google Cloud Console.';
                } else if (error.message.includes('Server error: 429')) {
                    errorMessage += 'API quota exceeded. Please try again later.';
                } else {
                    errorMessage += 'Please try again or contact support if the issue persists.';
                }
                
                alert(errorMessage);
            } finally {                
                // Hide loading indicators on both tabs
                if (loadingMap) loadingMap.classList.remove('show');
                if (loadingList) loadingList.classList.remove('show');
            }
        }

        function updateMapMarkers() {
            // Check if Google Maps is available and map is initialized
            if (typeof google === 'undefined' || !map) {
                console.log('Google Maps not ready yet, skipping marker update');
                // Just update the places list for now
                updatePlacesList();
                return;
            }

            // Clear existing markers
            placeMarkers.forEach(marker => marker.setMap(null));
            placeMarkers = [];
            placeMarkerMap.clear();
            
            // Reset any selection when updating markers
            resetMarkerHighlighting();
            if (selectionArrow) {
                selectionArrow.setMap(null);
                selectionArrow = null;
            }

            // Add markers for active categories
            Object.entries(allPlaces).forEach(([category, places]) => {
                if (!activeCategories.has(category)) return;

                places.forEach(place => {
                    addPlaceMarker(place, category);
                });
            });
            
            // Always update places list in split-screen view
            updatePlacesList();
        }

        function addPlaceMarker(place, category) {
            const color = CATEGORY_COLORS[category];
            const icon = CATEGORY_ICONS[category];

            const marker = new google.maps.Marker({
                position: {
                    lat: place.location.latitude,
                    lng: place.location.longitude
                },
                map: map,
                title: place.name,
                icon: {
                    url: 'data:image/svg+xml;charset=UTF-8,' + encodeURIComponent(`
                        <svg width="40" height="50" viewBox="0 0 40 50" xmlns="http://www.w3.org/2000/svg">
                            <defs>
                                <filter id="marker-shadow-${category}" x="-50%" y="-50%" width="200%" height="200%">
                                    <feGaussianBlur in="SourceAlpha" stdDeviation="2"/>
                                    <feOffset dx="0" dy="2" result="offset"/>
                                    <feFlood flood-color="#000000" flood-opacity="0.3"/>
                                    <feComposite in2="offset" operator="in"/>
                                    <feMerge>
                                        <feMergeNode/>
                                        <feMergeNode in="SourceGraphic"/>
                                    </feMerge>
                                </filter>
                            </defs>
                            <!-- Drop pin shape -->
                            <path d="M20 5 C12 5, 6 11, 6 19 C6 27, 20 45, 20 45 C20 45, 34 27, 34 19 C34 11, 28 5, 20 5 Z" 
                                  fill="${color}" 
                                  stroke="white" 
                                  stroke-width="3" 
                                  filter="url(#marker-shadow-${category})"/>
                            <!-- Inner circle -->
                            <circle cx="20" cy="19" r="10" fill="white"/>
                            <!-- Category icon -->
                            <text x="20" y="25" text-anchor="middle" fill="${color}" font-size="16" font-weight="bold">${icon}</text>
                        </svg>
                    `),
                    scaledSize: new google.maps.Size(40, 50),
                    anchor: new google.maps.Point(20, 45)
                }
            });

            const infoWindow = new google.maps.InfoWindow({
                content: `
                    <div class="marker-info" style="max-width: 180px; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;">
                        <h3 style="margin: 0 0 6px 0; font-size: 0.95rem; color: #333; line-height: 1.2;">${icon} ${place.name}</h3>
                        <p style="margin: 2px 0; color: #1976D2; font-weight: bold; font-size: 0.8rem;">üö∂ ${place.distance}m away</p>
                        ${place.rating > 0 ? `<p style="margin: 2px 0; color: #ff9800; font-weight: bold; font-size: 0.8rem;">‚≠ê ${place.rating.toFixed(1)}</p>` : ''}
                        <button onclick="openDirections(${place.location.latitude}, ${place.location.longitude}, '${place.name}')" 
                                style="background: #1976D2; color: white; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 0.8rem; font-weight: bold; margin-top: 6px; width: 100%;">
                            üó∫Ô∏è Directions
                        </button>
                    </div>
                `
            });

            marker.addListener('click', () => {
                // Highlight this place on map (adds selection marker and effects)
                highlightPlaceOnMap(place.id);
                
                // Highlight corresponding place in list view
                highlightPlaceInList(place.id);
                
                // Show place details in modal
                showPlaceDetails(Object.assign(place, { category }));
            });

            // Store the info window reference on the marker for cross-tab interaction
            marker.infoWindow = infoWindow;
            
            // Store marker in the map for cross-tab interaction
            placeMarkerMap.set(place.id, marker);
            
            placeMarkers.push(marker);
        }

        function updateStats() {
            // Only count places from active categories
            const activePlacesList = [];
            
            Object.entries(allPlaces).forEach(([category, places]) => {
                if (activeCategories.has(category)) {
                    activePlacesList.push(...places);
                }
            });
            
            const totalPlaces = activePlacesList.length;
            
            const avgRating = totalPlaces > 0 
                ? (activePlacesList.reduce((sum, place) => sum + (place.rating || 0), 0) / totalPlaces).toFixed(1)
                : '0.0';
                
            const maxDistance = totalPlaces > 0 
                ? Math.max(...activePlacesList.map(place => place.distance))
                : 0;
                
            const categoryCounts = Object.entries(allPlaces)
                .filter(([cat]) => activeCategories.has(cat))
                .map(([cat, places]) => ({
                    category: cat,
                    count: places.length
                }))
                .sort((a, b) => b.count - a.count);
            
            const topCategory = categoryCounts[0]?.category || '-';

            document.getElementById('totalPlaces').textContent = totalPlaces;
            document.getElementById('avgRating').textContent = avgRating;
            document.getElementById('maxDistance').textContent = maxDistance + 'm';
            document.getElementById('topCategory').textContent = CATEGORY_ICONS[topCategory] || '-';
        }

        function clearAllPlaces() {
            console.log('Clearing all places');
            
            // Clear all markers from map
            placeMarkers.forEach(marker => marker.setMap(null));
            placeMarkers = [];
            placeMarkerMap.clear();
            
            // Clear places data
            allPlaces = {};
            
            // Close any open info window
            if (currentInfoWindow) {
                currentInfoWindow.close();
                currentInfoWindow = null;
            }
            
            // Update stats and displays
            updateStats();
            
            // Update places list
            updatePlacesList();
            
            console.log('All places cleared');
        }

        function updateLoadButtonText() {
            const loadBtn = document.getElementById('loadPlacesBtn');
            if (!loadBtn) {
                console.log('Load button not found yet');
                return;
            }
            
            const selectedCount = activeCategories.size;
            console.log('Updating button text, selected count:', selectedCount);
            
            if (selectedCount === 0) {
                loadBtn.textContent = 'üó∫Ô∏è Select Categories First';
                loadBtn.style.background = '#ccc';
                loadBtn.style.cursor = 'not-allowed';
                console.log('Button updated: No categories');
            } else {
                const categories = Array.from(activeCategories).map(cat => CATEGORY_ICONS[cat]).join('');
                loadBtn.textContent = `üó∫Ô∏è Load ${categories} (${selectedCount} categories)`;
                loadBtn.style.background = 'linear-gradient(135deg, #4caf50 0%, #66bb6a 100%)';
                loadBtn.style.cursor = 'pointer';
                console.log('Button updated:', loadBtn.textContent, 'Background:', loadBtn.style.background);
            }
        }

        function updateSelectedCategoriesDisplay() {
            const display = document.getElementById('selectedCategoriesDisplay');
            if (!display) return;
            
            if (activeCategories.size === 0) {
                display.textContent = 'No categories selected';
                display.style.color = '#666';
            } else {
                const categoryNames = Array.from(activeCategories).map(cat => {
                    const icon = CATEGORY_ICONS[cat];
                    const name = cat.charAt(0).toUpperCase() + cat.slice(1);
                    return `${icon} ${name}`;
                }).join(', ');
                display.textContent = `Selected: ${categoryNames}`;
                display.style.color = '#1976D2';
            }
        }

        function adjustMapBounds() {
            if (placeMarkers.length === 0) {
                // If no markers, show wider area around hotel
                map.setCenter(HOTEL_LOCATION);
                map.setZoom(13);
                return;
            }

            const bounds = new google.maps.LatLngBounds();
            
            // Always include hotel location
            bounds.extend(HOTEL_LOCATION);
            
            // Add all place markers
            placeMarkers.forEach(marker => {
                bounds.extend(marker.getPosition());
            });

            // Add some padding to show context around the area
            const padding = {
                top: 50,
                right: 50,
                bottom: 50,
                left: 50
            };

            map.fitBounds(bounds, padding);
            
            // Ensure minimum and maximum zoom levels for better overview
            const listener = google.maps.event.addListener(map, "idle", () => {
                const currentZoom = map.getZoom();
                if (currentZoom > 16) {
                    map.setZoom(16); // Don't zoom in too much
                } else if (currentZoom < 12) {
                    map.setZoom(12); // Don't zoom out too much
                }
                google.maps.event.removeListener(listener);
            });
        }

        // Global variable to store current selection arrow
        let selectionArrow = null;
        
        // Cross-tab interaction functions
        function highlightPlaceOnMap(placeId) {
            console.log('Highlighting place on map:', placeId);
            
            // Get the marker for this place
            const marker = placeMarkerMap.get(placeId);
            if (!marker) {
                console.log('No marker found for place:', placeId);
                return;
            }
            
            // Close any currently open info window
            if (currentInfoWindow) {
                currentInfoWindow.close();
                currentInfoWindow = null;
            }
            
            // Remove previous selection arrow if exists
            if (selectionArrow) {
                selectionArrow.setMap(null);
            }
            
            // Center map on this marker with a slight animation
            map.panTo(marker.getPosition());
            
            // Add bounce animation to selected marker
            marker.setAnimation(google.maps.Animation.BOUNCE);
            setTimeout(() => {
                marker.setAnimation(null);
            }, 2100); // Stop bouncing after 2.1 seconds
            
            // Create a selection arrow pointing down to the marker
            const markerPosition = marker.getPosition();
            const arrowPosition = new google.maps.LatLng(
                markerPosition.lat() + 0.0015, // Position arrow higher above the marker
                markerPosition.lng()
            );
            
            // Zoom in to show the location better
            map.setZoom(17); // Closer zoom level
            map.panTo(markerPosition);
            
            selectionArrow = new google.maps.Marker({
                position: markerPosition,
                map: map,
                icon: {
                    url: 'data:image/svg+xml;charset=UTF-8,' + encodeURIComponent(`
                        <svg width="80" height="80" viewBox="0 0 80 80" xmlns="http://www.w3.org/2000/svg">
                            <defs>
                                <filter id="glow" x="-50%" y="-50%" width="200%" height="200%">
                                    <feGaussianBlur stdDeviation="3" result="coloredBlur"/>
                                    <feMerge> 
                                        <feMergeNode in="coloredBlur"/>
                                        <feMergeNode in="SourceGraphic"/>
                                    </feMerge>
                                </filter>
                            </defs>
                            
                            <!-- Outer pulsing ring (Google Maps style) -->
                            <circle cx="40" cy="40" r="35" fill="none" stroke="#1976D2" stroke-width="4" opacity="0.3">
                                <animate attributeName="r" values="35;45;35" dur="2s" repeatCount="indefinite"/>
                                <animate attributeName="opacity" values="0.3;0.1;0.3" dur="2s" repeatCount="indefinite"/>
                            </circle>
                            
                            <!-- Middle ring -->
                            <circle cx="40" cy="40" r="28" fill="none" stroke="#1976D2" stroke-width="3" opacity="0.5">
                                <animate attributeName="r" values="28;35;28" dur="1.5s" repeatCount="indefinite"/>
                                <animate attributeName="opacity" values="0.5;0.2;0.5" dur="1.5s" repeatCount="indefinite"/>
                            </circle>
                            
                            <!-- Inner solid circle -->
                            <circle cx="40" cy="40" r="20" fill="#1976D2" opacity="0.8" filter="url(#glow)"/>
                            
                            <!-- Center dot -->
                            <circle cx="40" cy="40" r="8" fill="white"/>
                            <circle cx="40" cy="40" r="4" fill="#1976D2"/>
                        </svg>
                    `),
                    scaledSize: new google.maps.Size(80, 80),
                    anchor: new google.maps.Point(40, 40),
                    zIndex: 1000 // Above normal markers but below other UI
                },
                zIndex: 1000
            });
            
            // Dim all other markers and highlight the selected one
            dimOtherMarkers(placeId);
            
            // Add a subtle pulse animation to the selected marker
            marker.setAnimation(google.maps.Animation.BOUNCE);
            setTimeout(() => {
                marker.setAnimation(null);
            }, 1000); // Shorter bounce duration
            
            // Arrow will stay visible until another location is selected
        }
        
        // Global variable to track currently selected place
        let currentlySelectedPlaceId = null;
        
        function dimOtherMarkers(selectedPlaceId) {
            console.log('Dimming other markers, highlighting:', selectedPlaceId);
            currentlySelectedPlaceId = selectedPlaceId;
            
            // Iterate through all markers
            placeMarkerMap.forEach((marker, placeId) => {
                const originalIcon = marker.getIcon();
                
                if (placeId === selectedPlaceId) {
                    // Highlight selected marker - make it more prominent
                    const highlightedIcon = {
                        ...originalIcon,
                        scaledSize: new google.maps.Size(50, 62), // Slightly larger
                        anchor: new google.maps.Point(25, 56)
                    };
                    marker.setIcon(highlightedIcon);
                    marker.setZIndex(2000); // Bring to front
                } else {
                    // Dim other markers - make them semi-transparent
                    const dimmedIcon = {
                        ...originalIcon,
                        url: originalIcon.url.replace(/opacity="1"/g, 'opacity="0.4"')
                                          .replace(/opacity: 1/g, 'opacity: 0.4')
                                          .replace(/fill-opacity="1"/g, 'fill-opacity="0.4"')
                                          .replace(/<svg/, '<svg style="opacity: 0.4"'),
                        scaledSize: new google.maps.Size(32, 40), // Slightly smaller
                        anchor: new google.maps.Point(16, 36)
                    };
                    marker.setIcon(dimmedIcon);
                    marker.setZIndex(100); // Send to back
                }
            });
        }
        
        function resetMarkerHighlighting() {
            console.log('Resetting all marker highlighting');
            currentlySelectedPlaceId = null;
            
            // Reset all markers to normal appearance
            placeMarkerMap.forEach((marker, placeId) => {
                // Find the original place data to recreate the correct icon
                let originalCategory = null;
                let originalPlace = null;
                
                Object.entries(allPlaces).forEach(([category, places]) => {
                    const place = places.find(p => p.id === placeId);
                    if (place) {
                        originalCategory = category;
                        originalPlace = place;
                    }
                });
                
                if (originalCategory && originalPlace) {
                    // Recreate the original icon
                    const color = CATEGORY_COLORS[originalCategory];
                    const icon = CATEGORY_ICONS[originalCategory];
                    
                    const originalIcon = {
                        url: 'data:image/svg+xml;charset=UTF-8,' + encodeURIComponent(`
                            <svg width="40" height="50" viewBox="0 0 40 50" xmlns="http://www.w3.org/2000/svg">
                                <defs>
                                    <filter id="marker-shadow-${originalCategory}" x="-50%" y="-50%" width="200%" height="200%">
                                        <feGaussianBlur in="SourceAlpha" stdDeviation="2"/>
                                        <feOffset dx="0" dy="2" result="offset"/>
                                        <feFlood flood-color="#000000" flood-opacity="0.3"/>
                                        <feComposite in2="offset" operator="in"/>
                                        <feMerge>
                                            <feMergeNode/>
                                            <feMergeNode in="SourceGraphic"/>
                                        </feMerge>
                                    </filter>
                                </defs>
                                <path d="M20 5 C12 5, 6 11, 6 19 C6 27, 20 45, 20 45 C20 45, 34 27, 34 19 C34 11, 28 5, 20 5 Z" 
                                      fill="${color}" 
                                      stroke="white" 
                                      stroke-width="3" 
                                      filter="url(#marker-shadow-${originalCategory})"/>
                                <circle cx="20" cy="19" r="10" fill="white"/>
                                <text x="20" y="25" text-anchor="middle" fill="${color}" font-size="16" font-weight="bold">${icon}</text>
                            </svg>
                        `),
                        scaledSize: new google.maps.Size(40, 50),
                        anchor: new google.maps.Point(20, 45)
                    };
                    
                    marker.setIcon(originalIcon);
                    marker.setZIndex(500); // Normal z-index
                }
            });
        }
        
        function highlightPlaceInList(placeId) {
            console.log('Highlighting place in list:', placeId);
            
            // Remove previous highlights
            document.querySelectorAll('.place-item.highlighted').forEach(item => {
                item.classList.remove('highlighted');
            });
            
            // Find and highlight the corresponding list item
            const listItem = document.querySelector(`.place-item[data-place-id="${placeId}"]`);
            if (listItem) {
                listItem.classList.add('highlighted');
                
                // Scroll the list to show this item
                listItem.scrollIntoView({
                    behavior: 'smooth',
                    block: 'center',
                    inline: 'nearest'
                });
                
                // Remove highlight after 3 seconds
                setTimeout(() => {
                    listItem.classList.remove('highlighted');
                }, 3000);
            } else {
                console.log('No list item found for place:', placeId);
            }
        }

        // Professional Place Details Modal Functions
        function showPlaceDetails(place) {
            console.log('Showing place details for:', place.name);
            
            const modal = document.getElementById('imageModal');
            const modalTitle = document.getElementById('modalPlaceName');
            const modalBody = document.getElementById('modalPlaceDetails');
            
            // Convert distance to miles
            const distanceInMiles = (place.distance * 0.000621371).toFixed(2);
            
            // Get category details
            const categoryIcon = CATEGORY_ICONS[place.category] || 'üìç';
            const categoryColor = CATEGORY_COLORS[place.category] || '#1976D2';
            
            // Set modal title with professional formatting
            modalTitle.innerHTML = `${categoryIcon} ${place.name}`;
            
            // Define default images for modal (same as in createPlaceListItem)
            const defaultImages = {
                recommend: 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(`
                    <svg width="200" height="200" viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg">
                        <defs>
                            <linearGradient id="starGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                                <stop offset="0%" style="stop-color:#FFD700;stop-opacity:1" />
                                <stop offset="100%" style="stop-color:#FFA500;stop-opacity:1" />
                            </linearGradient>
                        </defs>
                        <rect width="200" height="200" fill="url(#starGrad)" rx="15"/>
                        <circle cx="100" cy="100" r="40" fill="white"/>
                        <polygon points="100,70 110,90 130,90 115,105 120,125 100,115 80,125 85,105 70,90 90,90" fill="#FFD700"/>
                    </svg>
                `),
                restaurants: 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(`
                    <svg width="200" height="200" viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg">
                        <rect width="200" height="200" fill="#FF6B35" rx="15"/>
                        <circle cx="100" cy="100" r="40" fill="white"/>
                        <circle cx="100" cy="85" r="20" fill="#FF6B35"/>
                        <rect x="85" y="105" width="30" height="25" fill="#FF6B35"/>
                    </svg>
                `),
                landmarks: 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(`
                    <svg width="200" height="200" viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg">
                        <rect width="200" height="200" fill="#4CAF50" rx="15"/>
                        <circle cx="100" cy="100" r="40" fill="white"/>
                        <rect x="70" y="115" width="60" height="25" fill="#4CAF50"/>
                        <polygon points="70,115 100,75 130,115" fill="#4CAF50"/>
                    </svg>
                `),
                coffee: 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(`
                    <svg width="200" height="200" viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg">
                        <rect width="200" height="200" fill="#795548" rx="15"/>
                        <circle cx="100" cy="100" r="40" fill="white"/>
                        <ellipse cx="100" cy="100" rx="25" ry="30" fill="#795548"/>
                        <ellipse cx="100" cy="85" rx="20" ry="10" fill="#A1887F"/>
                    </svg>
                `),
                culture: 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(`
                    <svg width="200" height="200" viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg">
                        <rect width="200" height="200" fill="#9C27B0" rx="15"/>
                        <circle cx="100" cy="100" r="40" fill="white"/>
                        <path d="M75,100 Q100,70 125,100 Q100,130 75,100" fill="#9C27B0"/>
                    </svg>
                `)
            };
            
            // Get main image - prioritize uploaded images
            let mainImageHtml = '';
            if (place.images && place.images.length > 0) {
                // Use uploaded image as main image
                const uploadedImage = place.images[0];
                mainImageHtml = `<img class="place-main-image" src="${uploadedImage.dataUrl}" alt="${place.name}" style="display: block;">`;
            } else if (place.photos && place.photos.length > 0) {
                const photo = place.photos[0];
                const hasValidPhoto = photo && photo.name && photo.name.trim().length > 0 && 
                                    !photo.name.includes('undefined') && !photo.name.includes('null');
                
                if (hasValidPhoto) {
                    const encodedPhotoName = encodeURIComponent(photo.name);
                    const mainPhotoUrl = `/api/place-photo/${encodedPhotoName}?maxHeightPx=400&maxWidthPx=400`;
                    const fallbackImage = defaultImages[place.category] || defaultImages.recommend;
                    
                    mainImageHtml = `<img class="place-main-image" src="${fallbackImage}" data-real-src="${mainPhotoUrl}" alt="${place.name}" onload="this.style.display='block';" onerror="this.style.display='block';">`;
                    
                    // Try to load real photo
                    setTimeout(() => {
                        const testImg = new Image();
                        testImg.onload = () => {
                            const modalImg = document.querySelector('.place-main-image[data-real-src="' + mainPhotoUrl + '"]');
                            if (modalImg) modalImg.src = mainPhotoUrl;
                        };
                        testImg.onerror = () => {
                            console.log('Modal photo failed, keeping fallback');
                        };
                        testImg.src = mainPhotoUrl;
                    }, 300);
                } else {
                    const fallbackImage = defaultImages[place.category] || defaultImages.recommend;
                    mainImageHtml = `<img class="place-main-image" src="${fallbackImage}" alt="${place.name}">`;
                }
            } else {
                // Use category default image
                const fallbackImage = defaultImages[place.category] || defaultImages.recommend;
                mainImageHtml = `<img class="place-main-image" src="${fallbackImage}" alt="${place.name}">`;
            }
            
            // Build photo gallery - include uploaded images
            let galleryHtml = '';
            let allGalleryImages = [];
            
            // Add uploaded images first (starting from index 1 if we used first image as main)
            if (place.images && place.images.length > 0) {
                const startIndex = 1; // Skip first image as it's used as main
                const uploadedGalleryImages = place.images.slice(startIndex).map((uploadedImage, index) => {
                    const timestamp = Date.now();
                    const imageId = `gallery-uploaded-${timestamp}-${index}`;
                    return `
                        <div class="gallery-image-container" id="container-${imageId}">
                            <img class="gallery-image" 
                                 id="${imageId}"
                                 src="${uploadedImage.dataUrl}" 
                                 alt="${place.name}" 
                                 onclick="openFullImage('${uploadedImage.dataUrl}', '${place.name}')" 
                                 style="cursor: pointer; display: block;">
                        </div>
                    `;
                });
                allGalleryImages.push(...uploadedGalleryImages);
            }
            
            // Add Google Places photos
            if (place.photos && place.photos.length > 0) {
                const startIndex = (place.images && place.images.length > 0) ? 0 : 1; // If we have uploaded images, include all photos in gallery
                const photoGalleryImages = place.photos.slice(startIndex, 9).map((photo, index) => {
                    if (photo && photo.name && photo.name.trim().length > 0 && 
                        !photo.name.includes('undefined') && !photo.name.includes('null')) {
                        const encodedPhotoName = encodeURIComponent(photo.name);
                        const photoUrl = `/api/place-photo/${encodedPhotoName}?maxHeightPx=250&maxWidthPx=250`;
                        const fallbackImage = defaultImages[place.category] || defaultImages.recommend;
                        const timestamp = Date.now();
                        const imageId = `gallery-img-${timestamp}-${index}`;
                        const loadingId = `loading-${timestamp}-${index}`;
                        const errorId = `error-${timestamp}-${index}`;
                        return `
                            <div class="gallery-image-container" id="container-${imageId}">
                                <div class="gallery-loading" id="${loadingId}">
                                    <div class="loading-spinner"></div>
                                    <div class="loading-text">Loading...</div>
                                </div>
                                <img class="gallery-image" 
                                     id="${imageId}"
                                     src="${fallbackImage}" 
                                     data-real-src="${photoUrl}" 
                                     data-loading-id="${loadingId}"
                                     data-error-id="${errorId}"
                                     alt="${place.name}" 
                                     onclick="openFullImage('${photoUrl}', '${place.name}')" 
                                     style="cursor: pointer; display: none;">
                                <div class="gallery-error" id="${errorId}" style="display: none;">
                                    <div class="error-icon">‚ùå</div>
                                    <div class="error-text">Failed to load</div>
                                </div>
                            </div>
                        `;
                    }
                    return '';
                }).filter(img => img.length > 0);
                allGalleryImages.push(...photoGalleryImages);
            }
            
            const galleryImagesHtml = allGalleryImages.join('');
            
            // Generate gallery HTML
            if (allGalleryImages.length > 0) {
                const totalImages = (place.images ? place.images.length - 1 : 0) + (place.photos ? place.photos.length - (place.images && place.images.length > 0 ? 0 : 1) : 0);
                galleryHtml = `
                    <div class="photo-gallery">
                        <div class="gallery-title">üì∏ More Photos (${totalImages})</div>
                        <div class="photo-grid">
                            ${galleryImagesHtml}
                        </div>
                    </div>
                `;
            } else {
                galleryHtml = `
                    <div class="photo-gallery">
                        <div class="no-photos">
                            üì∑ No additional photos available for this location
                        </div>
                    </div>
                `;
            }
            
            // Create professional mobile modal content
            modalBody.innerHTML = `
                <div class="place-details-full">
                    <div class="place-hero-section">
                        ${mainImageHtml}
                    </div>
                    <div class="place-info-full">
                        <div class="place-name-full">${place.name}</div>
                        <div class="place-address-full">${place.address}</div>
                        <div class="place-stats-full">
                            ${place.rating > 0 ? `<div class="place-stat rating">‚≠ê ${place.rating.toFixed(1)}</div>` : ''}
                            <div class="place-stat distance">üö∂ ${place.distance}m</div>
                            <div class="place-stat distance">üåç ${distanceInMiles} mi</div>
                            <div class="place-stat category">${categoryIcon} ${place.category.charAt(0).toUpperCase() + place.category.slice(1)}</div>
                        </div>
                        ${place.description ? `<div class="place-description-full">üí≠ ${place.description}</div>` : `<div class="place-description-full">üì± Tap the buttons below to get directions or visit their website for more information about this ${place.category}.</div>`}
                    </div>
                </div>
                <div class="place-actions">
                    <button class="btn-action" onclick="openDirections(${place.location.latitude}, ${place.location.longitude}, '${encodeURIComponent(place.name)}')">
                        üó∫Ô∏è Get Directions
                    </button>
                    ${place.websiteUri ? `<a href="${place.websiteUri}" target="_blank" class="btn-action">üåê Website</a>` : `<button class="btn-action" onclick="sharePlace('${encodeURIComponent(place.name)}', ${place.location.latitude}, ${place.location.longitude})">üì§ Share</button>`}
                </div>
                ${galleryHtml}
            `;
            
            // Show modal
            modal.classList.add('show');
            document.body.style.overflow = 'hidden';
            
            // Load gallery images with proper error handling
            setTimeout(() => {
                loadGalleryImages(place);
            }, 100);
        }
        
        // Global variables for adaptive loading
        let currentLoadingDelay = 300; // Start with 300ms delay
        let recentFailures = 0;
        
        function loadGalleryImages(place) {
            console.log('Loading gallery images for:', place.name);
            
            // Get all gallery images
            const galleryImages = document.querySelectorAll('.gallery-image');
            
            if (galleryImages.length === 0) return;
            
            // Reset adaptive delay for new gallery
            currentLoadingDelay = 300;
            recentFailures = 0;
            
            // Load first 2 images in parallel for faster initial display
            if (galleryImages.length >= 2) {
                console.log('üöÄ Loading first 2 images in parallel for faster display');
                
                const img1 = galleryImages[0];
                const img2 = galleryImages[1];
                
                if (img1.getAttribute('data-real-src')) {
                    loadImageWithRetry(img1, img1.getAttribute('data-real-src'), 
                        document.getElementById(img1.getAttribute('data-loading-id')),
                        document.getElementById(img1.getAttribute('data-error-id')), 1, 0, (success) => {
                            if (!success) recentFailures++;
                        });
                }
                
                setTimeout(() => {
                    if (img2.getAttribute('data-real-src')) {
                        loadImageWithRetry(img2, img2.getAttribute('data-real-src'),
                            document.getElementById(img2.getAttribute('data-loading-id')),
                            document.getElementById(img2.getAttribute('data-error-id')), 2, 0, (success) => {
                                if (!success) recentFailures++;
                            });
                    }
                }, 150); // Small delay for second image
                
                // Continue with remaining images sequentially
                setTimeout(() => {
                    loadImageSequentially(galleryImages, 2);
                }, currentLoadingDelay);
            } else {
                // Single image or fallback to sequential
                loadImageSequentially(galleryImages, 0);
            }
        }
        
        function loadImageSequentially(galleryImages, currentIndex) {
            if (currentIndex >= galleryImages.length) {
                console.log('‚úÖ All gallery images processed');
                return;
            }
            
            const img = galleryImages[currentIndex];
            const loadingId = img.getAttribute('data-loading-id');
            const errorId = img.getAttribute('data-error-id');
            const loadingEl = document.getElementById(loadingId);
            const errorEl = document.getElementById(errorId);
            const realSrc = img.getAttribute('data-real-src');
            
            if (!realSrc) {
                console.log(`Skipping image ${currentIndex + 1} - no source`);
                // Move to next image immediately
                setTimeout(() => loadImageSequentially(galleryImages, currentIndex + 1), 100);
                return;
            }
            
            console.log(`Loading gallery image ${currentIndex + 1}/${galleryImages.length}:`, realSrc);
            
            // Try loading with retry logic
            loadImageWithRetry(img, realSrc, loadingEl, errorEl, currentIndex + 1, 0, (success) => {
                // Adjust delay based on success/failure
                if (!success) {
                    recentFailures++;
                    if (recentFailures >= 2) {
                        // Increase delay if we're getting rate limited
                        currentLoadingDelay = Math.min(currentLoadingDelay * 1.5, 1000);
                        console.log(`‚ö†Ô∏è Increased loading delay to ${currentLoadingDelay}ms due to failures`);
                    }
                } else {
                    // Decrease delay on success
                    if (recentFailures > 0) recentFailures--;
                    if (recentFailures === 0 && currentLoadingDelay > 300) {
                        currentLoadingDelay = Math.max(currentLoadingDelay * 0.8, 300);
                        console.log(`‚úÖ Decreased loading delay to ${currentLoadingDelay}ms`);
                    }
                }
                
                // Move to next image with adaptive delay
                setTimeout(() => loadImageSequentially(galleryImages, currentIndex + 1), currentLoadingDelay);
            });
        }
        
        function loadImageWithRetry(img, realSrc, loadingEl, errorEl, imageNumber, retryCount, onComplete) {
            const maxRetries = 2;
            
            // Create a test image to check if it loads
            const testImg = new Image();
            
            testImg.onload = () => {
                console.log(`‚úÖ Gallery image ${imageNumber} loaded successfully`);
                // Hide loading indicator
                if (loadingEl) {
                    loadingEl.style.display = 'none';
                }
                // Show actual image
                img.src = realSrc;
                img.style.display = 'block';
                onComplete(true); // Success
            };
            
            testImg.onerror = () => {
                console.log(`‚ùå Gallery image ${imageNumber} failed to load (attempt ${retryCount + 1})`);
                
                if (retryCount < maxRetries) {
                    // Faster retry delays: 500ms, 1s
                    const delay = (retryCount + 1) * 500; // 500ms, 1000ms
                    console.log(`Retrying image ${imageNumber} in ${delay}ms...`);
                    setTimeout(() => {
                        loadImageWithRetry(img, realSrc, loadingEl, errorEl, imageNumber, retryCount + 1, onComplete);
                    }, delay);
                } else {
                    // Final failure - show error state
                    console.log(`Final failure for image ${imageNumber} after ${maxRetries} retries`);
                    if (loadingEl) {
                        loadingEl.style.display = 'none';
                    }
                    if (errorEl) {
                        errorEl.style.display = 'flex';
                    }
                    onComplete(false); // Failure
                }
            };
            
            // Start loading
            testImg.src = realSrc;
        }
        
        function openFullImage(imageUrl, placeName) {
            const fullImageWindow = window.open('', '_blank');
            fullImageWindow.document.write(`
                <html>
                    <head>
                        <title>${placeName} - Photo</title>
                        <style>
                            body { margin: 0; background: #000; display: flex; justify-content: center; align-items: center; min-height: 100vh; }
                            img { max-width: 95%; max-height: 95%; object-fit: contain; border-radius: 8px; }
                        </style>
                    </head>
                    <body>
                        <img src="${imageUrl}" alt="${placeName}">
                    </body>
                </html>
            `);
        }

        function sharePlace(placeName, latitude, longitude) {
            const shareText = `Check out ${placeName}! üìç`;
            const shareUrl = `https://maps.google.com/maps?q=${latitude},${longitude}`;
            
            if (navigator.share) {
                // Use native share API on mobile
                navigator.share({
                    title: placeName,
                    text: shareText,
                    url: shareUrl
                }).catch(err => console.log('Error sharing:', err));
            } else {
                // Fallback: copy to clipboard
                const fullText = `${shareText}\n${shareUrl}`;
                navigator.clipboard.writeText(fullText).then(() => {
                    alert('üìã Location copied to clipboard!');
                }).catch(() => {
                    // Final fallback: open in new window
                    window.open(shareUrl, '_blank');
                });
            }
        }

        // Hotel Location Update Functions
        function extractCoordinatesFromGoogleMapsUrl(url) {
            console.log('Extracting coordinates from URL:', url);
            
            // Remove any whitespace
            url = url.trim();
            
            // Different Google Maps URL patterns
            const patterns = [
                // Standard coordinates: @lat,lng,zoom
                /@(-?\d+\.?\d*),(-?\d+\.?\d*),?\d*z?/,
                // Query coordinates: q=lat,lng
                /q=(-?\d+\.?\d*),(-?\d+\.?\d*)/,
                // Place coordinates: !3d-lat!4d-lng
                /!3d(-?\d+\.?\d*)!4d(-?\d+\.?\d*)/,
                // Another format: ll=lat,lng
                /ll=(-?\d+\.?\d*),(-?\d+\.?\d*)/,
                // Data coordinates: data=lat,lng
                /data=.*?(-?\d+\.?\d*),(-?\d+\.?\d*)/
            ];
            
            for (const pattern of patterns) {
                const match = url.match(pattern);
                if (match) {
                    const lat = parseFloat(match[1]);
                    const lng = parseFloat(match[2]);
                    
                    // Validate coordinates
                    if (lat >= -90 && lat <= 90 && lng >= -180 && lng <= 180) {
                        console.log('Found coordinates:', { lat, lng });
                        return { lat, lng };
                    }
                }
            }
            
            console.log('No valid coordinates found in URL');
            return null;
        }

        // GPS Location Functions
        async function getCurrentLocationGPS() {
            return new Promise((resolve, reject) => {
                if (!navigator.geolocation) {
                    reject(new Error('Geolocation is not supported by this browser'));
                    return;
                }

                const options = {
                    enableHighAccuracy: true,
                    timeout: 10000,
                    maximumAge: 300000 // 5 minutes
                };

                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        resolve({
                            latitude: position.coords.latitude,
                            longitude: position.coords.longitude,
                            accuracy: position.coords.accuracy
                        });
                    },
                    (error) => {
                        let errorMessage = 'Unable to get your location';
                        switch (error.code) {
                            case error.PERMISSION_DENIED:
                                errorMessage = 'Location access denied. Please enable location permissions and try again.';
                                break;
                            case error.POSITION_UNAVAILABLE:
                                errorMessage = 'Location information unavailable. Please check your GPS and try again.';
                                break;
                            case error.TIMEOUT:
                                errorMessage = 'Location request timed out. Please try again.';
                                break;
                        }
                        reject(new Error(errorMessage));
                    },
                    options
                );
            });
        }

        async function useGPSLocation() {
            const gpsBtn = document.getElementById('useGpsBtn');
            const originalText = gpsBtn.innerHTML;
            
            try {
                // Update button to show loading
                gpsBtn.innerHTML = 'üîÑ Getting location...';
                gpsBtn.disabled = true;
                
                console.log('üåç Requesting GPS location...');
                const location = await getCurrentLocationGPS();
                
                console.log('‚úÖ GPS location obtained:', location);
                
                // Update the hotel location with GPS coordinates
                HOTEL_LOCATION.lat = location.latitude;
                HOTEL_LOCATION.lng = location.longitude;
                
                // Reverse geocode to get address
                try {
                    const response = await fetch('/api/geocode-coordinates', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            latitude: location.latitude,
                            longitude: location.longitude
                        })
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        HOTEL_LOCATION.address = data.address;
                        HOTEL_LOCATION.name = 'Your GPS Location';
                        document.getElementById('currentLocationText').textContent = `üìç Current: ${data.address}`;
                    } else {
                        const coordsText = `${location.latitude.toFixed(6)}, ${location.longitude.toFixed(6)}`;
                        HOTEL_LOCATION.address = coordsText;
                        HOTEL_LOCATION.name = 'Your GPS Location';
                        document.getElementById('currentLocationText').textContent = `üìç Current: ${coordsText}`;
                    }
                } catch (geocodeError) {
                    console.warn('Reverse geocoding failed:', geocodeError);
                    const coordsText = `${location.latitude.toFixed(6)}, ${location.longitude.toFixed(6)}`;
                    HOTEL_LOCATION.address = coordsText;
                    HOTEL_LOCATION.name = 'Your GPS Location';
                    document.getElementById('currentLocationText').textContent = `üìç Current: ${coordsText}`;
                }
                
                // Clear the URL input since we're using GPS
                document.getElementById('hotelMapsUrl').value = '';
                
                // Update map center if map is initialized
                if (map) {
                    map.setCenter(HOTEL_LOCATION);
                    map.setZoom(15);
                    
                    // Add or update hotel marker
                    if (hotelMarker) {
                        hotelMarker.setPosition(HOTEL_LOCATION);
                    } else {
                        hotelMarker = new google.maps.Marker({
                            position: HOTEL_LOCATION,
                            map: map,
                            title: 'Your Location (GPS)',
                            icon: {
                                url: 'data:image/svg+xml;charset=UTF-8,' + encodeURIComponent(`
                                    <svg width="40" height="50" viewBox="0 0 40 50" xmlns="http://www.w3.org/2000/svg">
                                        <path d="M20 0C8.95 0 0 8.95 0 20c0 11.05 20 30 20 30s20-18.95 20-30C40 8.95 31.05 0 20 0z" fill="#FF6B35"/>
                                        <circle cx="20" cy="20" r="8" fill="white"/>
                                        <text x="20" y="26" text-anchor="middle" fill="#FF6B35" font-size="12" font-weight="bold">üìç</text>
                                    </svg>
                                `),
                                scaledSize: new google.maps.Size(40, 50),
                                anchor: new google.maps.Point(20, 50)
                            }
                        });
                    }
                }
                
                // Success feedback
                gpsBtn.innerHTML = '‚úÖ Location Updated!';
                gpsBtn.style.background = 'linear-gradient(135deg, #4CAF50 0%, #45a049 100%)';
                
                // Clear all current places since location changed
                clearAllPlaces();
                
                console.log('üéØ GPS location set successfully!');
                
                // Reset button after 2 seconds
                setTimeout(() => {
                    gpsBtn.innerHTML = originalText;
                    gpsBtn.style.background = 'linear-gradient(135deg, #FF6B35 0%, #F7931E 100%)';
                    gpsBtn.disabled = false;
                }, 2000);
                
            } catch (error) {
                console.error('‚ùå GPS location error:', error);
                
                // Show error message
                alert(`GPS Error: ${error.message}\n\nPlease:\n1. Enable location permissions in your browser\n2. Make sure GPS is enabled on your device\n3. Try using WiFi for better location accuracy\n4. Use the manual URL input as an alternative`);
                
                // Reset button
                gpsBtn.innerHTML = originalText;
                gpsBtn.disabled = false;
            }
        }

        async function updateHotelLocation() {
            const urlInput = document.getElementById('hotelMapsUrl');
            const updateBtn = document.getElementById('updateLocationBtn');
            const currentLocationText = document.getElementById('currentLocationText');
            const locationDescription = document.getElementById('locationDescription');
            
            const url = urlInput.value.trim();
            
            if (!url) {
                alert('Please paste a Google Maps URL first');
                return;
            }
            
            // Disable button and show loading
            updateBtn.disabled = true;
            updateBtn.textContent = 'üîÑ Extracting...';
            
            try {
                // Extract coordinates from URL
                const coordinates = extractCoordinatesFromGoogleMapsUrl(url);
                
                if (!coordinates) {
                    throw new Error('Could not extract coordinates from the URL. Please make sure it\'s a valid Google Maps link.');
                }
                
                // Update the global hotel location
                HOTEL_LOCATION.lat = coordinates.lat;
                HOTEL_LOCATION.lng = coordinates.lng;
                
                // Try to get address from coordinates using reverse geocoding
                updateBtn.textContent = 'üåê Getting address...';
                
                try {
                    const response = await fetch('/api/geocode-coordinates', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            latitude: coordinates.lat,
                            longitude: coordinates.lng
                        })
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        HOTEL_LOCATION.address = data.address;
                        HOTEL_LOCATION.name = 'Your Hotel Location';
                        
                        // Update displays
                        currentLocationText.textContent = `üìç Current: ${data.address}`;
                        locationDescription.textContent = `Discover restaurants, landmarks, coffee shops & culture near ${data.address}`;
                    } else {
                        // Use coordinates if reverse geocoding fails
                        const coordsText = `${coordinates.lat.toFixed(4)}, ${coordinates.lng.toFixed(4)}`;
                        HOTEL_LOCATION.address = coordsText;
                        HOTEL_LOCATION.name = 'Your Hotel Location';
                        
                        currentLocationText.textContent = `üìç Current: ${coordsText}`;
                        locationDescription.textContent = `Discover restaurants, landmarks, coffee shops & culture near ${coordsText}`;
                    }
                } catch (geocodeError) {
                    console.log('Reverse geocoding failed, using coordinates:', geocodeError);
                    const coordsText = `${coordinates.lat.toFixed(4)}, ${coordinates.lng.toFixed(4)}`;
                    HOTEL_LOCATION.address = coordsText;
                    HOTEL_LOCATION.name = 'Your Hotel Location';
                    
                    currentLocationText.textContent = `üìç Current: ${coordsText}`;
                    locationDescription.textContent = `Discover restaurants, landmarks, coffee shops & culture near ${coordsText}`;
                }
                
                // Update map if it exists
                if (map && hotelMarker) {
                    map.setCenter(HOTEL_LOCATION);
                    hotelMarker.setPosition(HOTEL_LOCATION);
                    map.setZoom(14);
                }
                
                // Clear existing places so user knows to reload
                clearAllPlaces();
                
                // Clear the input
                urlInput.value = '';
                
                alert('‚úÖ Hotel location updated successfully! Click "Load Places on Map" to find nearby places.');
                
            } catch (error) {
                console.error('Error updating hotel location:', error);
                alert('‚ùå Error: ' + error.message);
            } finally {
                // Re-enable button
                updateBtn.disabled = false;
                updateBtn.textContent = 'üîÑ Update Location';
            }
        }
        
        function hideImageModal() {
            const modal = document.getElementById('imageModal');
            modal.classList.remove('show');
            document.body.style.overflow = 'auto';
        }

        function openDirections(lat, lng, placeName) {
            const url = `https://www.google.com/maps/dir/?api=1&destination=${lat},${lng}&destination_place_id=${encodeURIComponent(placeName)}`;
            window.open(url, '_blank');
        }

        // Global initMap function for Google Maps callback
        window.initMap = function() {
            console.log('üó∫Ô∏è Google Maps API callback triggered');
            initializeMapInternal();
        };

        // Define the actual initialization function
        function initializeMapInternal() {
            console.log('üó∫Ô∏è Initializing Google Maps...');
            // Call the actual map initialization function
            try {
                initializeGoogleMap();
            } catch (error) {
                console.error('Error initializing map:', error);
            }
        }

        // Initialize when page loads - with better timing and mobile support
        window.addEventListener('load', () => {
            console.log('üì± Page loaded, checking for Google Maps API...');
            
            // Check if Google Maps API is already loaded
            if (typeof google !== 'undefined' && google.maps) {
                console.log('‚úÖ Google Maps API already available');
                initializeMapInternal();
            } else {
                console.log('‚è≥ Waiting for Google Maps API to load...');
                // Set up a callback for when the API loads
                let attempts = 0;
                const checkForGoogle = setInterval(() => {
                    attempts++;
                    if (typeof google !== 'undefined' && google.maps) {
                        console.log('‚úÖ Google Maps API loaded after', attempts, 'attempts');
                        clearInterval(checkForGoogle);
                        initializeMapInternal();
                    } else if (attempts > 20) {
                        console.error('‚ùå Google Maps API failed to load after 20 attempts');
                        clearInterval(checkForGoogle);
                        // Show error message to user
                        document.body.innerHTML += '<div style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #ff4444; color: white; padding: 20px; border-radius: 10px; z-index: 10000; text-align: center;"><h3>üö® Map Loading Error</h3><p>Please refresh the page or check your internet connection.</p></div>';
                    }
                }, 500);
            }
        });

        // Initialize when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            updateLoadButtonText(); // Initialize button text
            updateSelectedCategoriesDisplay(); // Initialize category display
            updatePlacesList(); // Initialize places list
            
            // Auto-load manual recommendations since 'recommend' is selected by default
            if (activeCategories.has('recommend')) {
                console.log('Auto-loading manual recommendations on page load...');
                fetchManualRecommendations().then(() => {
                    updateMapMarkers();
                    updateStats();
                    
                    // If Google Maps isn't ready yet, set up a retry
                    if (typeof google === 'undefined' || !map) {
                        console.log('Map not ready, will retry when Google Maps loads...');
                        // Set up a flag to retry map updates when Google Maps loads
                        window.retryMapUpdate = true;
                    }
                });
            }
        });

        // Image upload functionality
        let uploadedImages = [];

        function initImageUpload() {
            const dropZone = document.getElementById('imageDropZone');
            const fileInput = document.getElementById('imageFileInput');
            const previewContainer = document.getElementById('imagePreviewContainer');

            // Click to upload
            dropZone.addEventListener('click', () => {
                fileInput.click();
            });

            // File input change
            fileInput.addEventListener('change', (e) => {
                handleFiles(e.target.files);
            });

            // Drag and drop
            dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropZone.classList.add('drag-over');
            });

            dropZone.addEventListener('dragleave', (e) => {
                e.preventDefault();
                dropZone.classList.remove('drag-over');
            });

            dropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                dropZone.classList.remove('drag-over');
                handleFiles(e.dataTransfer.files);
            });

            // Global paste event for images
            document.addEventListener('paste', (e) => {
                const adminPanel = document.getElementById('adminPanel');
                if (adminPanel.style.display !== 'none') {
                    const items = e.clipboardData.items;
                    for (let item of items) {
                        if (item.type.startsWith('image/')) {
                            const file = item.getAsFile();
                            handleFiles([file]);
                        }
                    }
                }
            });
        }

        function handleFiles(files) {
            for (let file of files) {
                if (file.type.startsWith('image/')) {
                    if (file.size > 5 * 1024 * 1024) { // 5MB limit
                        alert('Image size must be less than 5MB');
                        continue;
                    }
                    addImagePreview(file);
                }
            }
        }

        function addImagePreview(file) {
            const reader = new FileReader();
            const imageId = 'img_' + Date.now() + '_' + Math.random().toString(36).substring(7);
            
            reader.onload = (e) => {
                const previewContainer = document.getElementById('imagePreviewContainer');
                const previewItem = document.createElement('div');
                previewItem.className = 'image-preview-item';
                previewItem.dataset.imageId = imageId;
                
                previewItem.innerHTML = `
                    <img src="${e.target.result}" alt="Preview">
                    <button type="button" class="image-preview-remove" onclick="removeImagePreview('${imageId}')">√ó</button>
                `;
                
                previewContainer.appendChild(previewItem);
                
                // Store image data
                uploadedImages.push({
                    id: imageId,
                    file: file,
                    dataUrl: e.target.result,
                    name: file.name
                });
            };
            
            reader.readAsDataURL(file);
        }

        function removeImagePreview(imageId) {
            // Remove from DOM
            const previewItem = document.querySelector(`[data-image-id="${imageId}"]`);
            if (previewItem) {
                previewItem.remove();
            }
            
            // Remove from uploaded images array
            uploadedImages = uploadedImages.filter(img => img.id !== imageId);
        }

        function clearImagePreviews() {
            uploadedImages = [];
            const previewContainer = document.getElementById('imagePreviewContainer');
            previewContainer.innerHTML = '';
        }

        // Initialize image upload when DOM is ready
        document.addEventListener('DOMContentLoaded', initImageUpload);

        // Delete recommendation functionality
        async function deleteRecommendation(recommendationId, event) {
            // Prevent triggering the place click event
            event.stopPropagation();
            
            // Find the recommendation
            const recommendation = allPlaces.recommend?.find(rec => rec.id === recommendationId);
            if (!recommendation) {
                alert('Recommendation not found');
                return;
            }
            
            // Confirm deletion
            const confirmDelete = confirm(`Are you sure you want to delete "${recommendation.name}"?`);
            if (!confirmDelete) {
                return;
            }
            
            try {
                // Call the delete API
                const response = await fetch(`/api/recommendations/${recommendationId}`, {
                    method: 'DELETE',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                const result = await response.json();
                
                if (response.ok && result.success) {
                    // Remove from local data
                    allPlaces.recommend = allPlaces.recommend.filter(rec => rec.id !== recommendationId);
                    
                    // Update displays
                    updateMapMarkers();
                    updateStats();
                    updatePlacesList();
                    
                    alert(`‚úÖ Successfully deleted: ${recommendation.name}`);
                    console.log(`Deleted recommendation: ${recommendation.name}`);
                } else {
                    alert(`‚ùå Failed to delete recommendation: ${result.error || 'Unknown error'}`);
                }
            } catch (error) {
                console.error('Error deleting recommendation:', error);
                alert('‚ùå Network error. Please try again.');
            }
        }

        // Structured content parsing functionality
        let parsedData = null;

        function parseStructuredContent(content) {
            const lines = content.split('\n').filter(line => line.trim());
            const parsed = {};
            
            lines.forEach(line => {
                const parts = line.split(':');
                if (parts.length >= 2) {
                    const key = parts[0].trim().toLowerCase();
                    const value = parts.slice(1).join(':').trim();
                    
                    switch (key) {
                        case 'file':
                            // Extract business name from filename
                            const filename = value.split('/').pop().replace(/\.[^/.]+$/, '');
                            parsed.filename = filename;
                            break;
                        case 'prices':
                            parsed.prices = value;
                            break;
                        case 'addresses':
                        case 'address':
                            parsed.address = value;
                            break;
                        case 'places':
                        case 'place':
                            parsed.places = value;
                            // Extract business name from places
                            const placeParts = value.split(',').map(p => p.trim());
                            parsed.businessName = placeParts.length > 1 ? placeParts[1] : placeParts[0];
                            break;
                        case 'hours':
                            parsed.hours = value;
                            break;
                        case 'food items':
                        case 'items':
                            parsed.foodItems = value;
                            break;
                        case 'sentiment':
                            parsed.sentiment = value;
                            break;
                        case 'summary':
                            parsed.summary = value;
                            break;
                    }
                }
            });
            
            return parsed;
        }

        async function displayParsedContent(parsed) {
            const previewContainer = document.getElementById('parsedContentPreview');
            const quickAddBtn = document.getElementById('quickAddBtn');
            
            let previewHTML = '<h4>üìã Parsed Content:</h4>';
            
            if (parsed.businessName) {
                previewHTML += `<div class="parsed-item"><span class="parsed-label">Name:</span> <span class="parsed-value">${parsed.businessName}</span></div>`;
            }
            if (parsed.prices) {
                previewHTML += `<div class="parsed-item"><span class="parsed-label">Prices:</span> <span class="parsed-value">${parsed.prices}</span></div>`;
            }
            if (parsed.address) {
                previewHTML += `<div class="parsed-item"><span class="parsed-label">Address:</span> <span class="parsed-value">${parsed.address}</span></div>`;
            }
            if (parsed.hours) {
                previewHTML += `<div class="parsed-item"><span class="parsed-label">Hours:</span> <span class="parsed-value">${parsed.hours}</span></div>`;
            }
            if (parsed.foodItems) {
                previewHTML += `<div class="parsed-item"><span class="parsed-label">Menu:</span> <span class="parsed-value">${parsed.foodItems}</span></div>`;
            }
            if (parsed.summary) {
                previewHTML += `<div class="parsed-item"><span class="parsed-label">Summary:</span> <span class="parsed-value">${parsed.summary}</span></div>`;
            }
            
            // Generate and display Google Maps URL
            let googleMapsUrl = '';
            let coordinates = null;
            
            if (parsed.address) {
                googleMapsUrl = await generateGoogleMapsUrl(parsed.address);
                if (googleMapsUrl) {
                    // Get coordinates for form population
                    coordinates = await getCoordinatesFromAddress(parsed.address);
                    
                    previewHTML += `<div class="parsed-item"><span class="parsed-label">Maps URL:</span> <span class="parsed-value"><a href="${googleMapsUrl}" target="_blank">${googleMapsUrl}</a></span></div>`;
                    
                    // Also show in the main URL display
                    const urlDisplay = document.getElementById('generatedUrlDisplay');
                    const urlLink = document.getElementById('generatedUrlLink');
                    urlLink.href = googleMapsUrl;
                    urlLink.textContent = googleMapsUrl;
                    urlDisplay.style.display = 'block';
                }
            }
            
            // Auto-populate form fields
            await populateFormFromParsedData(parsed, coordinates, googleMapsUrl);
            
            previewContainer.innerHTML = previewHTML;
            previewContainer.style.display = 'block';
            quickAddBtn.style.display = 'inline-block';
        }

        async function getCoordinatesFromAddress(address) {
            try {
                const response = await fetch('/api/geocode-address', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ address: address })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    if (data.success) {
                        return {
                            latitude: data.latitude,
                            longitude: data.longitude
                        };
                    }
                }
            } catch (error) {
                console.error('Error getting coordinates:', error);
            }
            return null;
        }

        async function populateFormFromParsedData(parsed, coordinates, googleMapsUrl) {
            // Populate form fields with parsed data
            if (parsed.businessName) {
                document.getElementById('recName').value = parsed.businessName;
            }
            
            if (parsed.address) {
                document.getElementById('recAddress').value = parsed.address;
            }
            
            if (coordinates) {
                document.getElementById('recLatitude').value = coordinates.latitude;
                document.getElementById('recLongitude').value = coordinates.longitude;
            }
            
            // Create comprehensive description
            let description = '';
            if (parsed.summary) {
                description = parsed.summary;
            } else {
                description = `${parsed.businessName || 'Restaurant'}`;
            }
            
            // Add additional details to description
            const details = [];
            if (parsed.hours) details.push(`Hours: ${parsed.hours}`);
            if (parsed.prices) details.push(`Prices: ${parsed.prices}`);
            if (parsed.foodItems) details.push(`Menu: ${parsed.foodItems}`);
            
            if (details.length > 0) {
                description += (description ? '\n\n' : '') + details.join('\n');
            }
            
            document.getElementById('recDescription').value = description;
            
            // Populate Google Maps URL field
            if (googleMapsUrl) {
                document.getElementById('googleMapsUrl').value = googleMapsUrl;
            }
            
            // Set a default rating if not provided
            document.getElementById('recRating').value = '4.0';
        }

        async function generateGoogleMapsUrl(address) {
            if (!address) return '';
            
            try {
                // Use the existing geocoding endpoint to get coordinates
                const response = await fetch('/api/geocode-address', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ address: address })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    if (data.success) {
                        // Generate Google Maps URL with directions (more useful for navigation)
                        return `https://www.google.com/maps/dir/?api=1&destination=${data.latitude},${data.longitude}&destination_place_id=${encodeURIComponent(data.address)}`;
                    }
                }
            } catch (error) {
                console.error('Error generating Google Maps URL:', error);
            }
            
            // Fallback: generate directions URL from address
            return `https://www.google.com/maps/dir/?api=1&destination=${encodeURIComponent(address)}`;
        }

        async function quickAddRecommendation() {
            if (!parsedData) {
                alert('Please parse content first');
                return;
            }
            
            // Prevent duplicate submissions
            if (isSubmitting) {
                console.log('‚ö†Ô∏è Submission already in progress, ignoring quick add request');
                return;
            }
            
            const quickAddBtn = document.getElementById('quickAddBtn');
            isSubmitting = true;
            quickAddBtn.disabled = true;
            quickAddBtn.innerHTML = '<span style="display: inline-block; animation: spin 1s linear infinite;">‚è≥</span> Adding...';
            
            try {
                // Generate Google Maps URL
                const googleMapsUrl = await generateGoogleMapsUrl(parsedData.address);
                
                // Create description from parsed data
                let description = '';
                if (parsedData.summary) {
                    description = parsedData.summary;
                } else {
                    description = `${parsedData.businessName || 'Restaurant'}`;
                    if (parsedData.hours) description += `. Hours: ${parsedData.hours}`;
                    if (parsedData.prices) description += `. Prices: ${parsedData.prices}`;
                    if (parsedData.foodItems) description += `. Menu: ${parsedData.foodItems}`;
                }
                
                // Try to extract coordinates from the generated URL
                if (googleMapsUrl.includes('query=') && googleMapsUrl.includes(',')) {
                    const coords = googleMapsUrl.split('query=')[1].split(',');
                    if (coords.length >= 2) {
                        const lat = parseFloat(coords[0]);
                        const lng = parseFloat(coords[1]);
                        
                        if (!isNaN(lat) && !isNaN(lng)) {
                            const recommendation = {
                                name: parsedData.businessName || 'Parsed Location',
                                address: parsedData.address || 'Address not provided',
                                latitude: lat,
                                longitude: lng,
                                rating: 0,
                                description: description,
                                websiteUri: '',
                                featured: false,
                                images: uploadedImages.map(img => ({
                                    id: img.id,
                                    name: img.name,
                                    dataUrl: img.dataUrl
                                })),
                                parsedData: {
                                    prices: parsedData.prices || '',
                                    hours: parsedData.hours || '',
                                    foodItems: parsedData.foodItems || '',
                                    googleMapsUrl: googleMapsUrl
                                }
                            };
                            
                            // Submit the recommendation
                            const response = await fetch('/api/recommendations', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json'
                                },
                                body: JSON.stringify(recommendation)
                            });
                            
                            const result = await response.json();
                            
                            if (response.ok && result.success) {
                                alert(`‚úÖ Successfully added: ${recommendation.name}`);
                                
                                // Update the display
                                if (!allPlaces.recommend) {
                                    allPlaces.recommend = [];
                                }
                                
                                const distance = Math.round(calculateDistance(
                                    HOTEL_LOCATION.lat, HOTEL_LOCATION.lng,
                                    recommendation.latitude, recommendation.longitude
                                ));
                                
                                const newRec = {
                                    ...result.recommendation,
                                    distance: distance
                                };
                                
                                allPlaces.recommend.push(newRec);
                                allPlaces.recommend.sort((a, b) => a.distance - b.distance);
                                
                                // Update displays
                                updateMapMarkers();
                                updateStats();
                                updatePlacesList();
                                
                                // Hide admin panel and clear form
                                document.getElementById('adminPanel').style.display = 'none';
                                document.getElementById('adminBackdrop').classList.remove('show');
                                document.body.style.overflow = 'auto';
                                document.getElementById('addRecommendationForm').reset();
                                clearImagePreviews();
                                
                                // Clear parsed content
                                parsedData = null;
                                document.getElementById('parsedContentPreview').style.display = 'none';
                                document.getElementById('quickAddBtn').style.display = 'none';
                                document.getElementById('structuredContent').value = '';
                                
                            } else {
                                alert(`‚ùå Failed to add recommendation: ${result.error || 'Unknown error'}`);
                            }
                        } else {
                            alert('‚ùå Could not extract valid coordinates from address');
                        }
                    } else {
                        alert('‚ùå Could not extract coordinates from address');
                    }
                } else {
                    alert('‚ùå Could not generate valid Google Maps URL');
                }
                
            } catch (error) {
                console.error('Error in quick add:', error);
                alert('‚ùå Error adding recommendation: ' + error.message);
            } finally {
                isSubmitting = false;
                quickAddBtn.disabled = false;
                quickAddBtn.innerHTML = 'Quick Add Recommendation';
            }
        }

        // Event listeners for structured content
        document.addEventListener('DOMContentLoaded', function() {
            document.getElementById('parseContentBtn').addEventListener('click', async function() {
                const content = document.getElementById('structuredContent').value.trim();
                if (!content) {
                    alert('Please paste some structured content first');
                    return;
                }
                
                const parseBtn = this;
                parseBtn.disabled = true;
                parseBtn.textContent = 'Parsing...';
                
                try {
                    parsedData = parseStructuredContent(content);
                    await displayParsedContent(parsedData);
                } catch (error) {
                    console.error('Error parsing content:', error);
                    alert('Error parsing content: ' + error.message);
                } finally {
                    parseBtn.disabled = false;
                    parseBtn.textContent = 'Parse Content';
                }
            });
            
            document.getElementById('quickAddBtn').addEventListener('click', quickAddRecommendation);
            
            // Auto-load places when page loads
            console.log('Page loaded, auto-loading places...');
            loadPlaces();
        });
    </script>

    <!-- Load Google Maps API -->
    <script async defer
        src="https://maps.googleapis.com/maps/api/js?key=AIzaSyAVdAZdO0tjOSoNImELNfi5HtZVzitN3Y4&callback=initMap">
    </script>
</body>
</html>